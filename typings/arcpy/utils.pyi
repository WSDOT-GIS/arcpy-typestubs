"""
This type stub file was generated by pyright.
"""

__all__ = [
    "inProcess",
    "noisy",
    "logcall",
    "ArgAdaptor",
    "listofnamedtuples",
    "getstartingpage",
    "fetchautocomplete",
    "py3_syntax_report",
]

def inProcess():  # -> bool:
    """Checks if a script is running in process or not.
    Returns a boolean."""
    ...

def noisy():  # -> None:
    """Turns on the noisiest level of logging for the logging module."""
    ...

def logcall():  # -> None:
    """Performs a logging.debug line with the current function stack's
    function name with arguments. Useful as a sort of inline tracing.
    Use noisy() to ensure the visibility of these logging calls."""
    ...

class ArgAdaptor:
    """Function call argument hook -- meant to allow for string
    mappings to integer values.

     Sample usage:

     class MappingConstants(ArgAdaptor):
         __args__ = {
             "format": {"pdf": 1,
                        "svg": 2,
                        "eps": 3
                       }
         }

     @MappingConstants.maskargs
     def exportToVector(filename, format=1):
         full_filename = "%s.%s" % (filename,
                                    {1: 'pdf', 2: 'svg', 3: 'eps'}[format])
         return _c_api.export(full_filename, format)

     Then instead of

     >>> exportToVector("c:\\hello", 2)

     you can call

     >>> exportToVector("c:\\hello", "svg")

     which is easier to understand when inspecting source, and then you can
     add/change literal values as needed without breaking other parts of
     the codebase.

     This function masker will also treat args that are recognized in the
     class as mappings as bitmasks if a collection (set, list, tuple) are
     passed in. For example:

     class BitMaskedFunction(ArgAdaptor):
         __args__ = { "permissions": {"read": 1, "write": 2, "execute": 4} }

     @BitMaskedFunction.maskargs
     def createfile(filename, permissions):
         return _c_api.touchfile(filename, permissions)

     A call to

     >>> createfile("hello.txt", ("read", "execute"))

     will call the function with the value of permissions set to 5
     (composed of 4 | 1).

     PLEASE NOTE: Any STRING value being passed through will be LOWERCASED
     (for case insensitivity reasons), so ensure any string keys are in
     lowercase in the __args__ definition.
    """

    __args__ = ...
    @classmethod
    def maskargs(
        cls, fn
    ):  # -> _Wrapped[(...), Unknown, (*a: Unknown, **k: Unknown), Unknown]:
        """Wraps a function so arguments map to the name/value pairs specified in cls.__args__"""
        ...
    @classmethod
    def maskmethods(cls, otherclass):  # -> None:
        "Mask the methods"
        ...

WHITESPACE_RE = ...
IDENTIFIER_RE_STRING = ...
CALL_RE_STRING = ...
STRING_RE_STRING = ...
CLOSE_CALL_RE_STRING = ...
IDENTIFIER_RE = ...
CALL_RE = ...
STRING_RE = ...
CLOSE_CALL_RE = ...
SENTINEL = ...
ADDITIONAL_ITEMS = ...
KEYWORD = ...

class RASTER_SENTINEL:
    __esri_toolinfo__ = ...

def reformat_doc_string(obj_tokens, object_of_interest, object_parent=...): ...
def fixdocstring(object_to_fetch, _builtins, _globals, _locals):  # -> Literal['']:
    "Function for ArcGIS desktop - fetches side-panel help for objects"
    ...

def find_autocomplete_candidates(code, string_index, var_dict):
    """Find automatic completion candidates for a string, given the namespace
    represented as a dictionary var_dict."""
    ...

def in_index(string_index, start, end): ...
def call_ranges(
    code, string_index
):  # -> list[tuple[Unknown, Unknown, Unknown, Unknown, Unknown | Literal[-1]]]:
    """Finds a list of what look like function calls in the currect text block
    that overlap with the current cursor position."""
    ...

def function_call_in_context(
    code, string_index, var_dict
):  # -> tuple[Unknown, Unknown | Literal[-1], list[Unknown], Unknown | Any | None] | tuple[Literal[''], Literal[-1], list[Unknown], None]:
    """Finds a reference to the current "function call" the code is currently
    in, given the code as a unicode object, the (zero-indexed) position of
    the cursor, and the flattened namespace represented in var_dict.

    Returns a tuple of the form ([list, of, string, tokens],
                                 reference_to_object)"""
    ...

CALL_STACK_MAP = ...

def split_call_string(call_string): ...
def arg_index_for_call_string(call_string): ...
def parse_spec(call_prototype): ...
def values_for_dropdown_function(args): ...
def get_index_and_argvals_for_dropdown_call(call_string, index): ...
def tool_popup_items(found_item, call_str, start_index): ...
def tool_item_items(found_item, call_str, start_index): ...
def help_tip(
    call_str, call_index, obj_tokens, found_item, start_index
):  # -> tuple[Unknown | str | LiteralString, Unknown | list[Unknown]]:
    """Returns the plain text for the help tooltip in the Python window
    for the current function call. The Python window allows for
    non-overlapping, non-nested, HTML-like tags (<T>TEXT</T>) where T is:

        B: Bold
        I: Italic
        H: Highlighted
        S: Small
        R: Regular (non-monospaced) font
        U: Underline

    Tags can be <I>like this</I> or <SB>composed together</SB>"""
    ...

def find_autocomplete_xml(code, string_index, var_dict):  # -> Any | None:
    """Return the XML equivalent of what find_autocomplete_candidates
    returns to forward to ArcGIS Desktop's Python window"""
    ...

def fetchautocomplete(code, string_index):  # -> Any | None:
    """Function for ArcGIS desktop - fetches autocomplete candidates for
    python window"""
    ...

def listofnamedtuples(list_of_dicts, tuple_name=...):  # -> list[namedtuple]:
    """Return a list of named tuples from a list of dicts
    (for gp.ListUsers)"""
    ...

PRG_RE = ...

def getstartingpage(page_range_string):  # -> int:
    "Get the first specified number in a string like 5-10,11,12"
    ...

ALL_FIX_NAMES = ...
REFACTORING_TOOL = ...

def get_all_fix_names():  # -> list[Unknown]:
    """Return a sorted list of all available fix names in the given package.
    Modified from get_all_fix_names implementation in Python's stdlib to
    look at .pyc and .pyo files as well."""
    ...

def code_to_python_3(code_block, filename):  # -> str:
    """Python 2 goes in, Python 3 comes out."""
    ...

def code_diff_report(python_source, new_source, filename):  # -> LiteralString:
    """Helper function for py3_syntax_report: turn a difflib-generated diff
    between two scripts into an intelligible report"""
    ...

def py3_syntax_report(
    python_source, filename=...
):  # -> LiteralString | Literal['Python 3 OK', 'Syntax Error in Python 2']:
    "Return a report on Python 3 compatibility"
    ...
