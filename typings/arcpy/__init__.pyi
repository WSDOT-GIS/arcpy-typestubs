"""
This type stub file was generated by pyright.
"""

# import glob
# import importlib
# import os
# import pathlib
# import sys
from types import ModuleType
from typing import Iterable, NamedTuple, Optional, Any, Sequence
from typing_extensions import deprecated, Literal

# ruff: noqa: F401, F403
# cspell: disable
from . import da
import arcpy.charts
import arcpy.sa
import arcpy.utils as utils
import arcpy.ia
import arcpy._utbx
from itertools import chain
from .geoprocessing import env, gp
from arcpy.geoprocessing._base import gptooldoc as _gptooldoc

from .toolbox import *
from .toolbox_linux import *
from .arcobjects import *

# from arcgisscripting import (
#     ClearCredentials as _ClearCredentials,
#     ExecuteError,
#     ExecuteWarning,
#     ImportCredentials as _ImportCredentials,
#     NumPyArrayToRaster as _NumPyArrayToRaster,
#     RasterToNumPyArray as _RasterToNumPyArray,
#     SignInToPortal as _SignInToPortal,
# )
from . import metadata, mp, nax, sharing
from .charts import Chart
from .sa import Raster, RasterInfo
from .ia import Mensuration, Render
from .cmanagers import EnvManager
from . import management
from . import analysis

# region analysis aliases

ApportionPolygon_analysis = analysis.ApportionPolygon
Buffer_analysis = analysis.Buffer
Clip_analysis = analysis.Clip
CountOverlappingFeatures_analysis = analysis.CountOverlappingFeatures
CreateThiessenPolygons_analysis = analysis.CreateThiessenPolygons
Enrich_analysis = analysis.Enrich
EnrichLayer_analysis = analysis.EnrichLayer
Erase_analysis = analysis.Erase
Frequency_analysis = analysis.Frequency
GenerateNearTable_analysis = analysis.GenerateNearTable
GenerateOriginDestinationLinks_analysis = analysis.GenerateOriginDestinationLinks
GeographicallyWeightedRegression_analysis = analysis.GeographicallyWeightedRegression
GraphicBuffer_analysis = analysis.GraphicBuffer
Identity_analysis = analysis.Identity
Intersect_analysis = analysis.Intersect
MultipleRingBuffer_analysis = analysis.MultipleRingBuffer
Near_analysis = analysis.Near
PairwiseBuffer_analysis = analysis.PairwiseBuffer
PairwiseClip_analysis = analysis.PairwiseClip
PairwiseDissolve_analysis = analysis.PairwiseDissolve
PairwiseErase_analysis = analysis.PairwiseErase
PairwiseIntegrate_analysis = analysis.PairwiseIntegrate
PairwiseIntersect_analysis = analysis.PairwiseIntersect
PointDistance_analysis = analysis.PointDistance
PolygonNeighbors_analysis = analysis.PolygonNeighbors
RemoveOverlapMultiple_analysis = analysis.RemoveOverlapMultiple
Select_analysis = analysis.Select
SpatialJoin_analysis = analysis.SpatialJoin
Split_analysis = analysis.Split
SplitByAttributes_analysis = analysis.SplitByAttributes
Statistics_analysis = analysis.Statistics
SummarizeNearby_analysis = analysis.SummarizeNearby
SummarizeWithin_analysis = analysis.SummarizeWithin
SymDiff_analysis = analysis.SymDiff
TableSelect_analysis = analysis.TableSelect
TabulateIntersection_analysis = analysis.TabulateIntersection
Union_analysis = analysis.Union
Update_analysis = analysis.Update

# endregion

# region management aliases

#  names = [d for d in dir(management) if not d.startswith("_")]
# stmts = [f"{n} as {n}_management" for n in names]

Add3DFormats_management = management.Add3DFormats
AddAttachments_management = management.AddAttachments
AddAttributeRule_management = management.AddAttributeRule
AddCodedValueToDomain_management = management.AddCodedValueToDomain
AddColormap_management = management.AddColormap
AddContingentValue_management = management.AddContingentValue
AddDataToTrajectoryDataset_management = management.AddDataToTrajectoryDataset
AddFeatureClassToTopology_management = management.AddFeatureClassToTopology
AddField_management = management.AddField
AddFieldConflictFilter_management = management.AddFieldConflictFilter
AddFields_management = management.AddFields
AddFilesToLasDataset_management = management.AddFilesToLasDataset
AddGPSMetadataFields_management = management.AddGPSMetadataFields
AddGeometryAttributes_management = management.AddGeometryAttributes
AddGlobalIDs_management = management.AddGlobalIDs
AddIncrementingIDField_management = management.AddIncrementingIDField
AddIndex_management = management.AddIndex
AddItemsToCatalogDataset_management = management.AddItemsToCatalogDataset
AddJoin_management = management.AddJoin
AddPortalItemsToCatalogDataset_management = management.AddPortalItemsToCatalogDataset
AddRastersToMosaicDataset_management = management.AddRastersToMosaicDataset
AddRelate_management = management.AddRelate
AddRuleToRelationshipClass_management = management.AddRuleToRelationshipClass
AddRuleToTopology_management = management.AddRuleToTopology
AddSpatialIndex_management = management.AddSpatialIndex
AddSpatialJoin_management = management.AddSpatialJoin
AddSubtype_management = management.AddSubtype
AddXY_management = management.AddXY
Adjust3DZ_management = management.Adjust3DZ
AlterAttributeRule_management = management.AlterAttributeRule
AlterDomain_management = management.AlterDomain
AlterField_management = management.AlterField
AlterFieldGroup_management = management.AlterFieldGroup
AlterMosaicDatasetSchema_management = management.AlterMosaicDatasetSchema
AlterVersion_management = management.AlterVersion
Analyze_management = management.Analyze
AnalyzeControlPoints_management = management.AnalyzeControlPoints
AnalyzeDatasets_management = management.AnalyzeDatasets
AnalyzeMosaicDataset_management = management.AnalyzeMosaicDataset
AnalyzeToolboxForVersion_management = management.AnalyzeToolboxForVersion
AnalyzeToolsForPro_management = management.AnalyzeToolsForPro
Append_management = management.Append
AppendAnnotation_management = management.AppendAnnotation
AppendControlPoints_management = management.AppendControlPoints
ApplyBlockAdjustment_management = management.ApplyBlockAdjustment
ApplySymbologyFromLayer_management = management.ApplySymbologyFromLayer
AssignDefaultToField_management = management.AssignDefaultToField
AssignDomainToField_management = management.AssignDomainToField
BatchBuildPyramids_management = management.BatchBuildPyramids
BatchCalculateStatistics_management = management.BatchCalculateStatistics
BatchProject_management = management.BatchProject
BatchUpdateFields_management = management.BatchUpdateFields
BearingDistanceToLine_management = management.BearingDistanceToLine
BuildBoundary_management = management.BuildBoundary
BuildFootprints_management = management.BuildFootprints
BuildLasDatasetPyramid_management = management.BuildLasDatasetPyramid
BuildMosaicDatasetItemCache_management = management.BuildMosaicDatasetItemCache
BuildMultidimensionalInfo_management = management.BuildMultidimensionalInfo
BuildMultidimensionalTranspose_management = management.BuildMultidimensionalTranspose
BuildOverviews_management = management.BuildOverviews
BuildPyramids_management = management.BuildPyramids
BuildPyramidsandStatistics_management = management.BuildPyramidsandStatistics
BuildRasterAttributeTable_management = management.BuildRasterAttributeTable
BuildSeamlines_management = management.BuildSeamlines
BuildStereoModel_management = management.BuildStereoModel
CalculateCellSizeRanges_management = management.CalculateCellSizeRanges
CalculateDefaultClusterTolerance_management = (
    management.CalculateDefaultClusterTolerance
)
CalculateDefaultGridIndex_management = management.CalculateDefaultGridIndex
CalculateEndTime_management = management.CalculateEndTime
CalculateField_management = management.CalculateField
CalculateFields_management = management.CalculateFields
CalculateGeometryAttributes_management = management.CalculateGeometryAttributes
CalculateStatistics_management = management.CalculateStatistics
CalculateValue_management = management.CalculateValue
ChangePrivileges_management = management.ChangePrivileges
ChangeVersion_management = management.ChangeVersion
CheckGeometry_management = management.CheckGeometry
ClearPixelCache_management = management.ClearPixelCache
ClearWorkspaceCache_management = management.ClearWorkspaceCache
Clip_management = management.Clip
ColorBalanceMosaicDataset_management = management.ColorBalanceMosaicDataset
Compact_management = management.Compact
CompareReplicaSchema_management = management.CompareReplicaSchema
CompositeBands_management = management.CompositeBands
Compress_management = management.Compress
CompressFileGeodatabaseData_management = management.CompressFileGeodatabaseData
ComputeBlockAdjustment_management = management.ComputeBlockAdjustment
ComputeCameraModel_management = management.ComputeCameraModel
ComputeControlPoints_management = management.ComputeControlPoints
ComputeDirtyArea_management = management.ComputeDirtyArea
ComputeFiducials_management = management.ComputeFiducials
ComputeMosaicCandidates_management = management.ComputeMosaicCandidates
ComputePansharpenWeights_management = management.ComputePansharpenWeights
ComputeTiePoints_management = management.ComputeTiePoints
ConfigureGeodatabaseLogFileTables_management = (
    management.ConfigureGeodatabaseLogFileTables
)
ConsolidateLayer_management = management.ConsolidateLayer
ConsolidateLocator_management = management.ConsolidateLocator
ConsolidateMap_management = management.ConsolidateMap
ConsolidateProject_management = management.ConsolidateProject
ConsolidateToolbox_management = management.ConsolidateToolbox
ConvertCoordinateNotation_management = management.ConvertCoordinateNotation
ConvertRasterFunctionTemplate_management = management.ConvertRasterFunctionTemplate
ConvertTimeField_management = management.ConvertTimeField
ConvertTimeZone_management = management.ConvertTimeZone
Copy_management = management.Copy
CopyFeatures_management = management.CopyFeatures
CopyRaster_management = management.CopyRaster
CopyRows_management = management.CopyRows
Create3DObjectSceneLayerPackage_management = management.Create3DObjectSceneLayerPackage
CreateBuildingSceneLayerPackage_management = management.CreateBuildingSceneLayerPackage
CreateCatalogDataset_management = management.CreateCatalogDataset
CreateCloudStorageConnectionFile_management = (
    management.CreateCloudStorageConnectionFile
)
CreateColorComposite_management = management.CreateColorComposite
CreateConnectionString_management = management.CreateConnectionString
CreateCustomGeoTransformation_management = management.CreateCustomGeoTransformation
CreateDatabaseConnection_management = management.CreateDatabaseConnection
CreateDatabaseConnectionString_management = management.CreateDatabaseConnectionString
CreateDatabaseSequence_management = management.CreateDatabaseSequence
CreateDatabaseUser_management = management.CreateDatabaseUser
CreateDatabaseView_management = management.CreateDatabaseView
CreateDomain_management = management.CreateDomain
CreateEnterpriseGeodatabase_management = management.CreateEnterpriseGeodatabase
CreateFeatureDataset_management = management.CreateFeatureDataset
CreateFeatureclass_management = management.CreateFeatureclass
CreateFieldGroup_management = management.CreateFieldGroup
CreateFileGDB_management = management.CreateFileGDB
CreateFishnet_management = management.CreateFishnet
CreateFolder_management = management.CreateFolder
CreateIntegratedMeshSceneLayerPackage_management = (
    management.CreateIntegratedMeshSceneLayerPackage
)
CreateLasDataset_management = management.CreateLasDataset
CreateMapTilePackage_management = management.CreateMapTilePackage
CreateMobileGDB_management = management.CreateMobileGDB
CreateMobileMapPackage_management = management.CreateMobileMapPackage
CreateMobileScenePackage_management = management.CreateMobileScenePackage
CreateMosaicDataset_management = management.CreateMosaicDataset
CreateOrthoCorrectedRasterDataset_management = (
    management.CreateOrthoCorrectedRasterDataset
)
CreatePansharpenedRasterDataset_management = management.CreatePansharpenedRasterDataset
CreatePointCloudSceneLayerPackage_management = (
    management.CreatePointCloudSceneLayerPackage
)
CreatePointSceneLayerPackage_management = management.CreatePointSceneLayerPackage
CreateRandomPoints_management = management.CreateRandomPoints
CreateRandomRaster_management = management.CreateRandomRaster
CreateRasterDataset_management = management.CreateRasterDataset
CreateRasterType_management = management.CreateRasterType
CreateReferencedMosaicDataset_management = management.CreateReferencedMosaicDataset
CreateRelationshipClass_management = management.CreateRelationshipClass
CreateReplica_management = management.CreateReplica
CreateReplicaFromServer_management = management.CreateReplicaFromServer
CreateRole_management = management.CreateRole
CreateSQLiteDatabase_management = management.CreateSQLiteDatabase
CreateSceneLayerPackage_management = management.CreateSceneLayerPackage
CreateSpatialReference_management = management.CreateSpatialReference
CreateSpatialType_management = management.CreateSpatialType
CreateTable_management = management.CreateTable
CreateTopology_management = management.CreateTopology
CreateTrajectoryDataset_management = management.CreateTrajectoryDataset
CreateUnRegisteredFeatureclass_management = management.CreateUnRegisteredFeatureclass
CreateUnRegisteredTable_management = management.CreateUnRegisteredTable
CreateVectorTileIndex_management = management.CreateVectorTileIndex
CreateVectorTilePackage_management = management.CreateVectorTilePackage
CreateVersion_management = management.CreateVersion
CreateVersionedView_management = management.CreateVersionedView
CreateVoxelSceneLayerContent_management = management.CreateVoxelSceneLayerContent
DefineMosaicDatasetNoData_management = management.DefineMosaicDatasetNoData
DefineOverviews_management = management.DefineOverviews
DefineProjection_management = management.DefineProjection
Delete_management = management.Delete
DeleteAttributeRule_management = management.DeleteAttributeRule
DeleteCodedValueFromDomain_management = management.DeleteCodedValueFromDomain
DeleteColormap_management = management.DeleteColormap
DeleteDatabaseSequence_management = management.DeleteDatabaseSequence
DeleteDomain_management = management.DeleteDomain
DeleteFeatures_management = management.DeleteFeatures
DeleteField_management = management.DeleteField
DeleteFieldGroup_management = management.DeleteFieldGroup
DeleteIdentical_management = management.DeleteIdentical
DeleteMosaicDataset_management = management.DeleteMosaicDataset
DeleteRasterAttributeTable_management = management.DeleteRasterAttributeTable
DeleteRows_management = management.DeleteRows
DeleteSchemaGeodatabase_management = management.DeleteSchemaGeodatabase
DeleteVersion_management = management.DeleteVersion
DetectFeatureChanges_management = management.DetectFeatureChanges
DiagnoseVersionMetadata_management = management.DiagnoseVersionMetadata
DiagnoseVersionTables_management = management.DiagnoseVersionTables
Dice_management = management.Dice
DisableArchiving_management = management.DisableArchiving
DisableAttachments_management = management.DisableAttachments
DisableAttributeRules_management = management.DisableAttributeRules
DisableCOGO_management = management.DisableCOGO
DisableEditorTracking_management = management.DisableEditorTracking
DisableFeatureBinning_management = management.DisableFeatureBinning
DisableReplicaTracking_management = management.DisableReplicaTracking
Dissolve_management = management.Dissolve
DomainToTable_management = management.DomainToTable
DowngradeAttachments_management = management.DowngradeAttachments
DownloadRasters_management = management.DownloadRasters
EditRasterFunction_management = management.EditRasterFunction
Eliminate_management = management.Eliminate
EliminatePolygonPart_management = management.EliminatePolygonPart
EnableArchiving_management = management.EnableArchiving
EnableAttachments_management = management.EnableAttachments
EnableAttributeRules_management = management.EnableAttributeRules
EnableCOGO_management = management.EnableCOGO
EnableEditorTracking_management = management.EnableEditorTracking
EnableEnterpriseGeodatabase_management = management.EnableEnterpriseGeodatabase
EnableFeatureBinning_management = management.EnableFeatureBinning
EnableReplicaTracking_management = management.EnableReplicaTracking
EncodeField_management = management.EncodeField
EvaluateRules_management = management.EvaluateRules
ExportAcknowledgementMessage_management = management.ExportAcknowledgementMessage
ExportAttributeRules_management = management.ExportAttributeRules
ExportContingentValues_management = management.ExportContingentValues
ExportDataChangeMessage_management = management.ExportDataChangeMessage
ExportFrameAndCameraParameters_management = management.ExportFrameAndCameraParameters
ExportGeodatabaseConfigurationKeywords_management = (
    management.ExportGeodatabaseConfigurationKeywords
)
ExportMosaicDatasetGeometry_management = management.ExportMosaicDatasetGeometry
ExportMosaicDatasetItems_management = management.ExportMosaicDatasetItems
ExportMosaicDatasetPaths_management = management.ExportMosaicDatasetPaths
ExportRasterWorldFile_management = management.ExportRasterWorldFile
ExportReplicaSchema_management = management.ExportReplicaSchema
ExportReportToPDF_management = management.ExportReportToPDF
ExportTileCache_management = management.ExportTileCache
ExportTopologyErrors_management = management.ExportTopologyErrors
ExportXMLWorkspaceDocument_management = management.ExportXMLWorkspaceDocument
ExtractPackage_management = management.ExtractPackage
ExtractSubDataset_management = management.ExtractSubDataset
FeatureCompare_management = management.FeatureCompare
FeatureEnvelopeToPolygon_management = management.FeatureEnvelopeToPolygon
FeatureToLine_management = management.FeatureToLine
FeatureToPoint_management = management.FeatureToPoint
FeatureToPolygon_management = management.FeatureToPolygon
FeatureVerticesToPoints_management = management.FeatureVerticesToPoints
FieldStatisticsToTable_management = management.FieldStatisticsToTable
FileCompare_management = management.FileCompare
FindIdentical_management = management.FindIdentical
Flip_management = management.Flip
GenerateAttachmentMatchTable_management = management.GenerateAttachmentMatchTable
GenerateBlockAdjustmentReport_management = management.GenerateBlockAdjustmentReport
GenerateExcludeArea_management = management.GenerateExcludeArea
GenerateFgdbLicense_management = management.GenerateFgdbLicense
GenerateLicensedFgdb_management = management.GenerateLicensedFgdb
GeneratePointCloud_management = management.GeneratePointCloud
GeneratePointsAlongLines_management = management.GeneratePointsAlongLines
GenerateRasterCollection_management = management.GenerateRasterCollection
GenerateRasterFromRasterFunction_management = (
    management.GenerateRasterFromRasterFunction
)
GenerateRectanglesAlongLines_management = management.GenerateRectanglesAlongLines
GenerateTableFromRasterFunction_management = management.GenerateTableFromRasterFunction
GenerateTessellation_management = management.GenerateTessellation
GenerateTileCacheTilingScheme_management = management.GenerateTileCacheTilingScheme
GenerateTransectsAlongLines_management = management.GenerateTransectsAlongLines
GeoTaggedPhotosToPoints_management = management.GeoTaggedPhotosToPoints
GeodeticDensify_management = management.GeodeticDensify
GetCellValue_management = management.GetCellValue
GetCount_management = management.GetCount
GetRasterProperties_management = management.GetRasterProperties
ImportAttributeRules_management = management.ImportAttributeRules
ImportContingentValues_management = management.ImportContingentValues
ImportGeodatabaseConfigurationKeywords_management = (
    management.ImportGeodatabaseConfigurationKeywords
)
ImportMessage_management = management.ImportMessage
ImportMosaicDatasetGeometry_management = management.ImportMosaicDatasetGeometry
ImportReplicaSchema_management = management.ImportReplicaSchema
ImportTileCache_management = management.ImportTileCache
ImportXMLWorkspaceDocument_management = management.ImportXMLWorkspaceDocument
Integrate_management = management.Integrate
InterpolateFromPointCloud_management = management.InterpolateFromPointCloud
JoinField_management = management.JoinField
LasDatasetStatistics_management = management.LasDatasetStatistics
LasPointStatsAsRaster_management = management.LasPointStatsAsRaster
MakeAggregationQueryLayer_management = management.MakeAggregationQueryLayer
MakeBuildingLayer_management = management.MakeBuildingLayer
MakeFeatureLayer_management = management.MakeFeatureLayer
MakeImageServerLayer_management = management.MakeImageServerLayer
MakeLasDatasetLayer_management = management.MakeLasDatasetLayer
MakeMosaicLayer_management = management.MakeMosaicLayer
MakeQueryLayer_management = management.MakeQueryLayer
MakeQueryTable_management = management.MakeQueryTable
MakeRasterLayer_management = management.MakeRasterLayer
MakeSceneLayer_management = management.MakeSceneLayer
MakeTableView_management = management.MakeTableView
MakeTinLayer_management = management.MakeTinLayer
MakeTrajectoryLayer_management = management.MakeTrajectoryLayer
MakeWCSLayer_management = management.MakeWCSLayer
MakeXYEventLayer_management = management.MakeXYEventLayer
ManageFeatureBinCache_management = management.ManageFeatureBinCache
ManageTileCache_management = management.ManageTileCache
MatchControlPoints_management = management.MatchControlPoints
MatchLayerSymbologyToAStyle_management = management.MatchLayerSymbologyToAStyle
MatchPhotosToRowsByTime_management = management.MatchPhotosToRowsByTime
Merge_management = management.Merge
MergeMosaicDatasetItems_management = management.MergeMosaicDatasetItems
MigrateObjectIDTo64Bit_management = management.MigrateObjectIDTo64Bit
MigrateRelationshipClass_management = management.MigrateRelationshipClass
MigrateStorage_management = management.MigrateStorage
MinimumBoundingGeometry_management = management.MinimumBoundingGeometry
Mirror_management = management.Mirror
Mosaic_management = management.Mosaic
MosaicDatasetToMobileMosaicDataset_management = (
    management.MosaicDatasetToMobileMosaicDataset
)
MosaicToNewRaster_management = management.MosaicToNewRaster
MultipartToSinglepart_management = management.MultipartToSinglepart
PackageLayer_management = management.PackageLayer
PackageLocator_management = management.PackageLocator
PackageMap_management = management.PackageMap
PackageProject_management = management.PackageProject
PackageResult_management = management.PackageResult
PivotTable_management = management.PivotTable
PointsToLine_management = management.PointsToLine
PolygonToLine_management = management.PolygonToLine
Project_management = management.Project
ProjectRaster_management = management.ProjectRaster
RasterCompare_management = management.RasterCompare
RasterToDTED_management = management.RasterToDTED
ReExportUnacknowledgedMessages_management = management.ReExportUnacknowledgedMessages
RebuildIndexes_management = management.RebuildIndexes
RecalculateFeatureClassExtent_management = management.RecalculateFeatureClassExtent
ReclassifyField_management = management.ReclassifyField
ReconcileVersion_management = management.ReconcileVersion
ReconcileVersions_management = management.ReconcileVersions
RecoverFileGDB_management = management.RecoverFileGDB
RefreshExcel_management = management.RefreshExcel
RegisterAsVersioned_management = management.RegisterAsVersioned
RegisterRaster_management = management.RegisterRaster
RegisterWithGeodatabase_management = management.RegisterWithGeodatabase
Remove3DFormats_management = management.Remove3DFormats
RemoveAttachments_management = management.RemoveAttachments
RemoveContingentValue_management = management.RemoveContingentValue
RemoveDomainFromField_management = management.RemoveDomainFromField
RemoveFeatureClassFromTopology_management = management.RemoveFeatureClassFromTopology
RemoveFieldConflictFilter_management = management.RemoveFieldConflictFilter
RemoveFilesFromLasDataset_management = management.RemoveFilesFromLasDataset
RemoveIndex_management = management.RemoveIndex
RemoveJoin_management = management.RemoveJoin
RemoveRastersFromMosaicDataset_management = management.RemoveRastersFromMosaicDataset
RemoveRelate_management = management.RemoveRelate
RemoveRuleFromRelationshipClass_management = management.RemoveRuleFromRelationshipClass
RemoveRuleFromTopology_management = management.RemoveRuleFromTopology
RemoveSpatialIndex_management = management.RemoveSpatialIndex
RemoveSubtype_management = management.RemoveSubtype
Rename_management = management.Rename
ReorderAttributeRule_management = management.ReorderAttributeRule
RepairGeometry_management = management.RepairGeometry
RepairMosaicDatasetPaths_management = management.RepairMosaicDatasetPaths
RepairTrajectoryDatasetPaths_management = management.RepairTrajectoryDatasetPaths
RepairVersionMetadata_management = management.RepairVersionMetadata
RepairVersionTables_management = management.RepairVersionTables
Resample_management = management.Resample
Rescale_management = management.Rescale
Rotate_management = management.Rotate
SaveToLayerFile_management = management.SaveToLayerFile
SaveToolboxToVersion_management = management.SaveToolboxToVersion
SelectData_management = management.SelectData
SelectLayerByAttribute_management = management.SelectLayerByAttribute
SelectLayerByLocation_management = management.SelectLayerByLocation
SetClusterTolerance_management = management.SetClusterTolerance
SetDefaultSubtype_management = management.SetDefaultSubtype
SetFeatureClassSplitModel_management = management.SetFeatureClassSplitModel
SetMosaicDatasetProperties_management = management.SetMosaicDatasetProperties
SetRasterProperties_management = management.SetRasterProperties
SetRelationshipClassSplitPolicy_management = management.SetRelationshipClassSplitPolicy
SetSubtypeField_management = management.SetSubtypeField
SetValueForRangeDomain_management = management.SetValueForRangeDomain
SharePackage_management = management.SharePackage
Shift_management = management.Shift
Sort_management = management.Sort
SortCodedValueDomain_management = management.SortCodedValueDomain
SplitLine_management = management.SplitLine
SplitLineAtPoint_management = management.SplitLineAtPoint
SplitMosaicDatasetItems_management = management.SplitMosaicDatasetItems
SplitRaster_management = management.SplitRaster
StandardizeField_management = management.StandardizeField
SubdividePolygon_management = management.SubdividePolygon
SynchronizeChanges_management = management.SynchronizeChanges
SynchronizeMosaicDataset_management = management.SynchronizeMosaicDataset
TINCompare_management = management.TINCompare
TableCompare_management = management.TableCompare
TableToDomain_management = management.TableToDomain
TableToEllipse_management = management.TableToEllipse
TableToRelationshipClass_management = management.TableToRelationshipClass
TransferFiles_management = management.TransferFiles
TransformField_management = management.TransformField
TransposeFields_management = management.TransposeFields
TrimArchiveHistory_management = management.TrimArchiveHistory
TruncateTable_management = management.TruncateTable
UncompressFileGeodatabaseData_management = management.UncompressFileGeodatabaseData
UnregisterAsVersioned_management = management.UnregisterAsVersioned
UnregisterReplica_management = management.UnregisterReplica
UnsplitLine_management = management.UnsplitLine
UpdateEnterpriseGeodatabaseLicense_management = (
    management.UpdateEnterpriseGeodatabaseLicense
)
UpdateGeodatabaseConnectionPropertiesToBranch_management = (
    management.UpdateGeodatabaseConnectionPropertiesToBranch
)
UpdateInteriorOrientation_management = management.UpdateInteriorOrientation
UpdatePortalDatasetOwner_management = management.UpdatePortalDatasetOwner
UpgradeAttachments_management = management.UpgradeAttachments
UpgradeDataset_management = management.UpgradeDataset
UpgradeGDB_management = management.UpgradeGDB
UpgradeSceneLayer_management = management.UpgradeSceneLayer
ValidateJoin_management = management.ValidateJoin
ValidateSceneLayerPackage_management = management.ValidateSceneLayerPackage
ValidateTopology_management = management.ValidateTopology
Warp_management = management.Warp
WarpFromFile_management = management.WarpFromFile
WorkspaceToRasterDataset_management = management.WorkspaceToRasterDataset
XYTableToPoint_management = management.XYTableToPoint
XYToLine_management = management.XYToLine

# endregion

# msg = ...
# if sys.platform.startswith("win"):
#     fnf_exception = ...
# else: ...
# if sys.platform.startswith("win"): ...
# else: ...
# if notsys.platform.startswith("win"): ...
# local_appdata = ...
# uuid_paths = ...
# module_paths = ...
# if local_appdata and os.path.exists(local_appdata):
#     addin_toolbox_path = ...
# sitepackpths = ...

# cspell: enable

MessageSeverity = Literal[0, 1, 2]

FieldType = Literal[
    # All field types are returned. This is the default.
    "All",
    # Only field types of BLOB are returned.
    "BLOB",
    # Only field types of Date are returned.
    "Date",
    # Only field types of Double are returned.
    "Double",
    # Only field types of Geometry are returned.
    "Geometry",
    # Only field types of GlobalID are returned.
    "GlobalID",
    # Only field types of GUID are returned.
    "GUID",
    # Only field types of Integer are returned.
    "Integer",
    # Only field types of OID are returned.
    "OID",
    # Only field types of Raster are returned.
    "Raster",
    # Only field types of Single are returned.
    "Single",
    # Only field types of SmallInteger are returned.
    "SmallInteger",
    # Only field types of String are returned.
    "String",
]

def ImportToolbox(
    input_file: str, module_name: Optional[str] = None
) -> str | ModuleType:  # -> str | ModuleType:
    """ImportToolbox(input_file, {module_name})

    Imports the specified toolbox into ArcPy, allowing for access to the
    toolbox's associated tools.

      input_file(String):
    The geoprocessing toolbox added to the ArcPy site package.

      module_name{String}:
    If the toolbox does not have an alias, the module_name is required.

    When a tool is accessed through the ArcPy site package, the toolbox alias
    where the tool is contained is a required suffix (
    arcpy.<toolname>_<alias> ).  Since ArcPy depends on toolbox aliases to
    access and execute the correct tool, aliases are extremely important when
    importing custom toolboxes.  A good practice is to always define a custom
    toolbox's alias;  however, if the toolbox alias is not defined, a
    temporary alias can be set as the second parameter."""
    ...

def GetInstallInfo(
    product: str = ...,
) -> dict[str, str]:
    """GetInstallInfo()

    The GetInstallInfo function returns a Python dictionary that contains
    information on the installation type properties."""
    ...

def GetPackageInfo(filename: str):  # -> Any:
    """GetPackageInfo(filename)

    Return the item infomation for a given package."""
    ...

InstallationType = Literal["server", "desktop", "engine", "arcgispro"]

def ListInstallations() -> list[InstallationType]:
    """ListInstallations()

    The ListInstallations function returns a list of installation types (
    server , desktop , engine , arcgispro )."""
    ...

def SetProgressor(
    type: Literal["default", "step"],
    message: Optional[str] = None,
    min_range: Optional[int] = 0,
    max_range: Optional[int] = 100,
    step_value: Optional[int] = None,
) -> None:
    """SetProgressor(type, {message}, {min_range}, {max_range}, {step_value})

    Establishes a progressor object which allows progress information to be
    passed to a progress dialog box. The appearance of the progress dialog
    box can be controlled by choosing either the default progressor or the
    step progressor.

      type(String):
    The progressor type (default or step).

     * default:   The progressor moves back and forth continuously.

     * step:   The progressor shows the percentage complete.

      message{String}:
    The progressor label. The default is no label.

      min_range{Integer}:
    Starting value for progressor. Default is 0.

      max_range{Integer}:
    Ending value for progressor. Default is 100.

      step_value{Integer}:
    The progressor step interval for updating the progress bar."""
    ...

def ResetProgressor() -> None:
    """ResetProgressor()

    Resets the progressor back to its initial state."""
    ...

def SetProgressorLabel(
    label: str,
) -> None:
    """SetProgressorLabel(label)

    Updates the progressor dialog box label.

      label(String):
    The label to be used on the progressor dialog box."""
    ...

def SetProgressorPosition(
    position: Optional[int],
) -> None:
    """SetProgressorPosition({position})

    Updates the status bar in the progressor dialog box.

      position{Integer}:
    Sets the position of the status bar in the progressor dialog box."""
    ...

def ResetEnvironments() -> None:
    """ResetEnvironments()

    Resets all environment settings to their default settings."""
    ...

def ClearEnvironment(
    environment_name: str,
) -> None:
    """ClearEnvironment(environment_name)

    Resets a specific environment setting to its default.

      environment_name(String):
    The name of the environment setting that will be reset to its default
    setting."""
    ...

def GetMessage(
    index: int,
) -> str:
    """GetMessage(index)

    Returns a geoprocessing tool message by its index position.

      index(Integer):
    The message to retrieve."""
    ...

def GetReturnCode(
    index: int,
) -> (
    int
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """GetReturnCode(index)

    Return the message error code by index.

    If the message for the specified index is a warning or informative
    message the function will return a 0; if the message is an error the
    function will return a value other than 0.

      index(Integer):
    The specified position of the message in the returned list of messages,
    warnings, or errors."""
    ...

def GetMessages(
    severity: MessageSeverity,
) -> Iterable[str]:
    """GetMessages({severity})

    Returns the geoprocessing messages from a tool by specified severity
    level..

      severity{Integer}:
    The severity level of messages to return.

     * 0:   messages returned.

     * 1:   warning messages returned.

     * 2:   error messages returned.

    Not specifying a severity will return all types of messages."""
    ...

def AddMessage(
    message: str,
) -> None:
    """AddMessage(message)

    Creates a geoprocessing informative message (Severity=0) that can be
    accessed with any of the GetMessages functions.

      message(String):
    The message to add."""
    ...

MessageType = Literal["INFORMATIVE", "WARNING", "ERROR"]

def AddIDMessage(
    message_type: MessageType,
    message_ID: int,
    add_argument1: Optional[str | int | float] = None,
    add_argument2: Optional[str | int | float] = None,
) -> None:
    """AddIDMessage(message_type, message_ID, {add_argument1}, {add_argument2})

    Allows you to use system messages with a script tool.  A list of messages
    and IDs that can be used are provided under Understanding geoprocessing
    tool errors and warnings .

      message_type(String):
    The message type defines whether the message will be an error, warning,
    or informative. Valid message types are:

     * ERROR:   Adds an error message to the tool messages.

     * INFORMATIVE: Adds an informative message to the tool messages.

     * WARNING:   Adds a warning message to the tool messages.

      message_ID(Integer):
    The message ID allows you to reference existing messages for your
    scripting errors and warnings.

      add_argument1{Object}:
    Depending on which message ID is used, an argument may be necessary to
    complete the message. Common examples include dataset or field names.
    Datatype can be string, integer, or double.

      add_argument2{Object}:
    Depending on which message ID is used, an argument may be necessary to
    complete the message. Common examples include dataset or field names.
    Datatype can be string, integer, or double."""
    ...

def GetIDMessage(message_ID: str, default_message: Optional[str] = None) -> str:
    """GetIDMessage(message_ID)

    Get the string of the error or warning ID message.

      message_ID(Integer):
    The geoprocessing message ID."""
    ...

def AddError(
    message: str,
) -> None:
    """AddError(message)

    Creates a geoprocessing tool error message (Severity=2) that can be
    accessed by any of the GetMessages functions.

      message(String):
    The message to add."""
    ...

def AddWarning(
    message: str,
) -> None:
    """AddWarning(message)

    Creates a geoprocessing warning message (Severity=1) that can be accessed
    by any of the GetMessages functions.

      message(String):
    The message to add."""
    ...

def AddReturnMessage(
    index: str,
) -> None:
    """AddReturnMessage(index)

    Sets the return message of a script tool as an output message by index.

      index(Integer):
    The message index."""
    ...

ProductCode = Literal[
    "arcview", "arceditor", "arcinfo", "engine", "enginegeodb", "arcserver"
]

def SetProduct(
    product: ProductCode,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """SetProduct(product)

    The SetProduct function defines the desktop license. SetProduct returns
    information on the license.

    The product level should be set by importing the appropriate product
    module ( arcinfo , arceditor , arcview , arcserver , arcenginegeodb , or
    arcengine ) prior to importing arcpy. The SetProduct function is a legacy
    function and cannot set the product once arcpy has been imported.

    For scripts using the arcgisscripting module, the equivalent SetProduct
    method is still supported.

      product(String):
    Product code for the product being set.

     * arcview:   ArcGIS for Desktop Basic product code

     * arceditor:   ArcGIS for Desktop Standard product code

     * arcinfo:   ArcGIS for Desktop Advanced product code

     * engine:   Engine Runtime product code

     * enginegeodb:   Engine Geodatabase Update product code

     * arcserver:   Server product code"""
    ...

def CheckProduct(
    product: ProductCode,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """CheckProduct(product)

    Checks to see if the requested license is available.

      product(String):
    Product code for the product being checked.

     * arcview:   ArcGIS for Desktop Basic product code

     * arceditor:   ArcGIS for Desktop Standard product code

     * arcinfo:   ArcGIS for Desktop Advanced product code

     * engine:   Engine Runtime product code

     * enginegeodb:   Engine Geodatabase Update product code

     * arcserver:   Server product code"""
    ...

def ProductInfo() -> ProductCode:
    """ProductInfo()

    Returns the current product license."""
    ...

ExtensionCode = Literal[
    "3D",
    "Datareviewer",
    "DataInteroperability",
    "Airports",
    "Aeronautical",
    "Bathymetry",
    "Nautical",
    "GeoStats",
    "Network",
    "Spatial",
    "Schematics",
    "Tracking",
    "JTX",
    "ArcScan",
    "Business",
    "Defense",
    "Foundation",
    "Highways",
    "StreetMap",
]

def CheckOutExtension(
    extension_code: ExtensionCode,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """CheckOutExtension(extension_code)

    Retrieves the license from the License Manager.

    Once the extension license has been retrieved by the script, tools using
    that extension can be used. Once a script is finished with an extension's
    tools, the CheckInExtension function should be used to return the license
    to the License Manager so other applications can use it. All checked-out
    extension licenses and set product licenses are returned to the License
    Manager when a script completes.

      extension_code(String):
    Keyword for the extension product that is being checked.

     * 3D:   ArcGIS 3D Analyst extension

     * Datareviewer:   ArcGIS 10.2 Data Reviewer for Desktop

     * DataInteroperability: ArcGIS Data Interoperability extension for
     Desktop

     * Airports: ArcGIS for Aviation: Airports

     * Aeronautical:   ArcGIS for Aviation: Charting

     * Bathymetry: ArcGIS for Maritime: Bathymetry

     * Nautical:   ArcGIS for Maritime: Charting

     * GeoStats:   ArcGIS Geostatistical Analyst extension

     * Network:   ArcGIS Network Analyst extension

     * Spatial:   ArcGIS Spatial Analyst extension

     * Schematics:   ArcGIS Schematics extension

     * Tracking:   ArcGIS Tracking Analyst extension

     * JTX: ArcGIS Workflow Manager for Desktop

     * ArcScan:   ArcScan

     * Business:   Business Analyst

     * Defense:   Esri Defense Solution

     * Foundation:   Esri Production Mapping

     * Highways: Esri Roads and Highways

     * StreetMap:   StreetMap   Licensing and extensions"""
    ...

def CheckInExtension(
    extension_code: ExtensionCode,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """CheckInExtension(extension_code)

    Returns the license to the License Manager so other applications can use
    it.

    Once the extension license has been retrieved by the script, tools using
    that extension can be used. Once a script is finished with an extension's
    tools, the CheckInExtension function should be used to return the license
    to the License Manager so other applications can use it. All checked-out
    extension licenses and set product licenses are returned to the License
    Manager when a script completes.

      extension_code(String):
    Keyword for the extension product that is being checked.

     * 3D:   ArcGIS 3D Analyst extension

     * Datareviewer:   ArcGIS 10.2 Data Reviewer for Desktop

     * DataInteroperability: ArcGIS Data Interoperability extension for
     Desktop

     * Airports: ArcGIS for Aviation: Airports

     * Aeronautical:   ArcGIS for Aviation: Charting

     * Bathymetry: ArcGIS for Maritime: Bathymetry

     * Nautical:   ArcGIS for Maritime: Charting

     * GeoStats:   ArcGIS Geostatistical Analyst extension

     * Network:   ArcGIS Network Analyst extension

     * Spatial:   ArcGIS Spatial Analyst extension

     * Schematics:   ArcGIS Schematics extension

     * Tracking:   ArcGIS Tracking Analyst extension

     * JTX: ArcGIS Workflow Manager for Desktop

     * ArcScan:   ArcScan

     * Business:   Business Analyst

     * Defense:   Esri Defense Solution

     * Foundation:   Esri Production Mapping

     * Highways: Esri Roads and Highways

     * StreetMap:   StreetMap   Licensing and extensions"""
    ...

def CheckExtension(
    extension_code: ExtensionCode,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """CheckExtension(extension_code)

    Checks to see if a license is available to be checked out for a specific
    type of extension.

    Learn more about licensing and extensions .

      extension_code(String):
    Keyword for the extension product that is being checked.

     * 3D:   ArcGIS 3D Analyst extension

     * Datareviewer:   ArcGIS Data Reviewer for Desktop

     * DataInteroperability: ArcGIS Data Interoperability extension for
     Desktop

     * Airports: ArcGIS for Aviation: Airports

     * Aeronautical:   ArcGIS for Aviation: Charting

     * Bathymetry: ArcGIS for Maritime: Bathymetry

     * Nautical:   ArcGIS for Maritime: Charting

     * GeoStats:   ArcGIS Geostatistical Analyst extension

     * Network:   ArcGIS Network Analyst extension

     * Spatial:   ArcGIS Spatial Analyst extension

     * Schematics:   ArcGIS Schematics extension

     * Tracking:   ArcGIS Tracking Analyst extension

     * JTX: ArcGIS Workflow Manager for Desktop

     * ArcScan:   ArcScan

     * Business:   Business Analyst

     * Defense:   Esri Defense Solution

     * Foundation:   Esri Production Mapping

     * Highways: Esri Roads and Highways

     * StreetMap:   StreetMap"""
    ...

def ListSpatialReferences(
    wild_card: Optional[str] = None,
    spatial_reference_type: Optional[Literal["GCS", "PCS", "ALL"]] = None,
) -> list[str]:
    """ListSpatialReferences({wild_card}, {spatial_reference_type})

    Returns a Python list of available spatial reference names for use as an
    argument to arcpy.SpatialReference .

      wild_card{String}:
    Limit the spatial references listed by a simple wildcard check. The check
    is not case sensitive.

    For example, arcpy.ListSpatialReferences("*Eckert*") would list Eckert I
    , Eckert II , and so forth.

      spatial_reference_type{String}:
    Limit the spatial references listed by type.

     * GCS:   List only Geographic Coordinate Systems.

     * PCS: List only Projected Coordinate Systems.

     * ALL:   List both Projected and Geographic Coordinate Systems. This is
     the default."""
    ...

def ListTransformations(
    from_sr: SpatialReference | str,
    to_sr: SpatialReference | str,
    extent: Extent = ...,
    vertical: bool = False,
    first_only: bool = False,
) -> list[str]:
    """ListTransformations(from_sr, to_sr, {extent}, {vertical}, {first_only})

    Returns a list of valid transformation methods for converting data from
    one spatial reference to another.  An extent can be used to narrow the
    list of valid transformation methods for a specific geographic area.

      from_sr(SpatialReference):
    The starting geographic coordinate system. Can be specified with a
    SpatialReference object, the name of the spatial reference, or a path to
    a projection file (.prj).

      to_sr(SpatialReference):
    The final geographic coordinate system.  Can be specified with a
    SpatialReference object, the name of the spatial reference, or a path to
    a projection file (.prj).

      extent{Extent}:
    Only transformations that span the entire extent will be returned.  The
    extent needs to be specified in coordinates from the in_sr .  When
    working with data, the extent on a Describe object can be used.

      vertical{Boolean}:
    This function only returns on type of transformation, either all are
    horizontal or all vertical.
     - False : horizontal transformations will be returned. This is the
     default.
     - True : vertical transformations will be returned.

      first_only{Boolean}:
    Performance optimization to limit the returned list to single item.
     - False : all valid transformations will be returned. This is the
     default.
     - True : the first valid transformation will be returned."""
    ...

def GetParameterAsText(index: int) -> str:
    """GetParameterAsText(index)

    Gets the specified parameter as a text string by its index position from
    the list of parameters.

      index(Integer):
    The numeric position of the parameter in the parameter list."""
    ...

def SetParameterAsText(
    index: int, text: str
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """SetParameterAsText(index, text)

    Sets a specified parameter property by index using a string value. This
    is used when passing values from a script to a script tool. If you need
    to pass an object, such as a spatial reference to a script tool, use
    SetParameter .

      index(Integer):
    The specified parameter's index position in the parameter list.

      text(String):
    The string value that will set the specified parameter's property."""
    ...

def GetParameter(
    index: int,
) -> (
    Any
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """GetParameter(index)

    From the parameter list, select the desired parameter by its index value.
    The parameter is returned as an object.

      index(Integer):
    Selects the specified parameter, by its index, from the parameter list."""
    ...

def SetParameter(index: int, value: object) -> Any:
    """SetParameter(index, value)

    Sets a specified parameter property by index using an object. This is
    used when passing objects from a script to a script tool. If you need to
    pass a text value to a script tool, use SetParameterAsText .

      index(Integer):
    The specified parameter's index position in the parameter list.

      value(Object):
    The object that will set the specified parameter's property."""
    ...

def CopyParameter(
    from_param: int, to_param: int
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """CopyParameter(from_param, to_param)

    Copies the specified parameter by index to another parameter in the
    script tool. The specified parameters must be of the same data type.

      from_param(Integer):
    The index position of the parameter to be copied.

      to_param(Integer):
    The index position of the parameter that will be copied to."""
    ...

def SetParameterSymbology(
    index: int, text: str
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """SetParameterSymbology(index, text)

    Sets a parameter's Symbology property.

      index(Integer):
    The specified parameter's index position in the parameter list.

      text(String):
    The symbology to be applied to the parameter. This can be a
    CIM Symbology object or the path to a .lyrx file.
    """
    ...

def ListFiles(
    wild_card: Optional[str] = None,
) -> list[str]:
    """ListFiles({wild_card})

    Returns a list of files in the current workspace based on a query string.
    Specifying search conditions can be used to limit the results.

      wild_card{String}:
    The wild_card limits the results returned. If no wild_card is specified,
    all values are returned."""
    ...

def ListTools(
    wild_card: str | None = None,
) -> list[str]:
    """ListTools({wild_card})

    Lists the geoprocessing tools, limited by name.

      wild_card{String}:
    The wild_card limits the results returned. If no wild_card is specified,
    all values are returned."""
    ...

def ListEnvironments(wild_card: Optional[str] = None) -> list[str]:
    """ListEnvironments({wild_card})

    The ListEnvironments function returns a list of geoprocessing environment
    names.

      wild_card{String}:
    The wild_card limits the results returned. If no wild_card is specified,
    all values are returned.

    ```python
    import arcpy

    # A wild_card of "*workspace" will return a list including the
    #   workspace and scratchWorkspace environment names
    arcpy.ListEnvironments("*workspace")
    ```
    """
    ...

def ListToolboxes(
    wild_card: Optional[str] = None,
) -> list[str]:
    """ListToolboxes({wild_card})

    Lists the geoprocessing toolboxes, limited by name.

      wild_card{String}:
    The wild_card limits the results returned. If no wild_card is specified,
    all values are returned."""
    ...

def AddToolbox(input_file: str, module_name: str | None = None) -> ModuleType:
    """AddToolbox(input_file, {module_name})

    Imports the specified toolbox into ArcPy, allowing for access to the
    toolbox's associated tools.

     Equivalent to the ImportToolbox function.

      input_file(String):
    The geoprocessing toolbox added to the ArcPy site package.

      module_name{String}:
    If the toolbox does not have an alias, the module_name is required.

    When a tool is accessed through the ArcPy site package, the toolbox alias
    where the tool is contained is a required suffix (
    arcpy.<toolname>_<alias> ).  Since ArcPy depends on toolbox aliases to
    access and execute the correct tool, aliases are extremely important when
    importing custom toolboxes.  A good practice is to always define a custom
    toolbox's alias;  however, if the toolbox alias is not defined, a
    temporary alias can be set as the second parameter."""
    ...

def RemoveToolbox(
    toolbox: str,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """RemoveToolbox(toolbox)

    Removes the specified toolbox, either by specifying its path or
    referencing its alias. Removes the specified toolbox from the current
    geoprocessing session. Server toolboxes can also be removed using a
    semicolon delimiter.

      toolbox(String):
    The name of the toolbox, including either path or alias, to be removed
    from the current geoprocessing session. The name/path or alias should be
    placed in a double-quoted string.

    Server toolboxes can be removed using a semicolon delimiter.   The name,
    including path, or alias, of the toolbox to be removed from the current
    geoprocessing session. Place the name/path, or alias, string inside
    double quotes. Server toolboxes can also be removed using a semicolon
    delimiter.

      Syntax for Internet ArcGIS for Server    URL
      servername;{username};{password}    Syntax for Local ArcGIS for Server
      machinename;servername .   Syntax for Internet ArcGIS for Server
      URL;servername;{username};{password}    Syntax for Local ArcGIS for
      Server    machinename;servername"""
    ...

def GetSystemEnvironment(
    environment: str,
) -> str:
    """GetSystemEnvironment(environment)

    Gets the specified system environment variable value, such as "TEMP".

      environment(String):
    The name of the system environment variable."""
    ...

def Command(
    command_line: str,
) -> ...:
    """Command(command_line)

    Executes a geoprocessing tool as a single string.

      command_line(String):
    The double-quoted string representing a command line command that is to
    be executed."""
    ...

def Usage(
    tool_name: str,
) -> str:
    """Usage(tool_name)

    Returns the syntax for the specified tool or function.

      tool_name(String):
    The tool name to display the syntax."""
    ...

def Exists(
    dataset: str,
) -> bool:
    """Exists(dataset)

    Determines the existence of the specified data object. Tests for the
    existence of feature classes, tables, datasets, shapefiles, workspaces,
    layers, and files in the current workspace. The function returns a
    Boolean indicating if the element exists.

      dataset(String):
    The name, path, or both of a feature class, table, dataset, layer,
    shapefile, workspace, or file to be checked for existence."""
    ...

FeatureClassFeatureType = Literal[
    "Annotation",
    "Arc",
    "Dimension",
    "Edge",
    "Junction",
    "Label",
    "Line",
    "Multipatch",
    "Node",
    "Point",
    "Polygon",
    "Polyline",
    "Region",
    "Route",
    "Tic",
    "All",
]
"""Feature type
"""

def ListFeatureClasses(
    wild_card: str | None = None,
    feature_type: FeatureClassFeatureType = "All",
    feature_dataset: str | None = None,
) -> list[str]:
    """ListFeatureClasses({wild_card}, {feature_type}, {feature_dataset})

    Lists the feature classes in the workspace, limited by name, feature
    type, and optional feature dataset.

      wild_card{String}:
    The wild_card limits the results returned. If no wild_card is specified,
    all values are returned.

      feature_type{String}:
    The feature type to limit the results returned by the wild_card argument.
    Valid feature types are:

     * Annotation:   Only annotation feature classes are returned.

     * Arc:   Only arc (or line) feature classes are returned.

     * Dimension:   Only dimension feature classes are returned.

     * Edge: Only edge feature classes are returned.

     * Junction: Only junction feature classes are returned.

     * Label:   Only label feature classes are returned.

     * Line:   Only line (or arc) feature classes are returned.

     * Multipatch: Only multipatch feature classes are returned.

     * Node:   Only node feature classes are returned.

     * Point:   Only point feature classes are returned.

     * Polygon:   Only polygon feature classes are returned.

     * Polyline: Only line (or arc) feature classes are returned.

     * Region:   Only region feature classes are returned.

     * Route:   Only route feature classes are returned.

     * Tic:   Only tic feature classes are returned.

     * All:   All datasets in the workspace. This is the default value.

      feature_dataset{String}:
    Limits the feature classes returned to the feature dataset, if specified.
    If blank, only stand-alone feature classes will be returned in the
    workspace."""
    ...

DataSetFeatureType = Literal[
    "Coverage",
    "Feature",
    "GeometricNetwork",
    "Mosaic",
    "Network",
    "ParcelFabric",
    "Raster",
    "RasterCatalog",
    "Schematic",
    "Terrain",
    "Tin",
    "Topology",
    "All",
]

def ListDatasets(
    wild_card: Optional[str] = None, feature_type: DataSetFeatureType = "All"
) -> list[str]:
    """ListDatasets({wild_card}, {feature_type})

    Lists all of the datasets in a workspace. Search conditions can be
    specified for the dataset name and dataset type to limit the list that is
    returned.

      wild_card{String}:
    The wild_card limits the results returned. If no wild_card is specified,
    all values are returned.

      feature_type{String}:
    The feature type to limit the results returned by the wildcard argument.
    Valid dataset types are:

     * Coverage: Only coverages.

     * Feature: Coverage or geodatabase dataset, depending on the workspace.

     * GeometricNetwork: Only geometric network datasets.

     * Mosaic: Only mosaic datasets.

     * Network:   Only network datasets.

     * ParcelFabric: Only parcel fabric datasets.

     * Raster:   Only raster datasets.

     * RasterCatalog: Only raster catalog datasets.

     * Schematic: Only schematic datasets.

     * Terrain: Only terrain datasets.

     * Tin:   Only TIN datasets.

     * Topology: Only topology datasets.

     * All:   All datasets in the workspace. This is the default value."""
    ...

def ListTables(
    wild_card: Optional[str] = None, table_type: Literal["dBASE", "INFO", "All"] = "All"
) -> list[str]:
    """ListTables({wild_card}, {table_type})

    Lists the tables in the workspace, limited by name and table type.

      wild_card{String}:
    The wild_card limits the results returned. If no wild_card is specified,
    all values are returned.

      table_type{String}:
    The table type to limit the results returned by the wild card argument.
    Valid table types are:

     * dBASE:   Only tables of type dBASE are returned.

     * INFO:   Only stand-alone INFO tables are returned.

     * ALL:   All stand-alone tables, including geodatabase tables, are
     returned. This is the default."""
    ...

def ListRasters(
    wild_card: Optional[str] = None,
    raster_type: Literal[
        "BMP", "GIF", "IMG", "JPG", "JP2", "PNG", "GRID", "All"
    ] = "All",
) -> list[str]:
    """ListRasters({wild_card}, {raster_type})

    Returns a list of the rasters in the workspace, limited by name and
    raster type.

      wild_card{String}:
    The wild_card limits the results returned. If no wild_card is specified,
    all values are returned.

      raster_type{String}:
    The raster type to limit the results returned by the wild card argument.
    Valid raster types are:

     * BMP:   Bitmap graphic raster dataset format.

     * GIF:   Graphic Interchange Format for raster datasets.

     * IMG:   ERDAS IMAGINE raster data format.

     * JP2:   JPEG 2000 raster dataset format.

     * JPG:   Joint Photographics Experts Group raster dataset format.

     * PNG:   Portable Network Graphics raster dataset format.

     * TIF:   Tagged Image File for raster datasets.

     * GRID:   Grid data format.

     * All:   All supported raster types are returned. This is the default."""
    ...

def ListWorkspaces(
    wild_card: Optional[str] = None,
    workspace_type: Literal[
        "Access", "Coverage", "FileGDB", "Folder", "SDE", "All"
    ] = "All",
) -> list[str]:
    """ListWorkspaces({wild_card}, {workspace_type})

    Lists all of the workspaces within the set workspace. Search conditions
    can be specified for the workspace name and workspace type to limit the
    list that is returned.

      wild_card{String}:
    The wild_card limits the results returned. If no wild_card is specified,
    all values are returned.

      workspace_type{String}:
    The workspace type to limit the results returned by the wild card
    argument. There are six possible workspace types:

     * Access:   Only personal geodatabases will be selected.

     * Coverage:   Only coverage workspaces will be selected.

     * FileGDB:   Only file geodatabases will be selected.

     * Folder:   Only shapefile workspaces will be selected.

     * SDE:   Only enterprise databases will be selected.

     * All:   All workspaces will be selected. This is the default."""
    ...

def ListVersions(
    sde_workspace: str,
) -> list[str]:
    """ListVersions(sde_workspace)

    Lists the versions the connected user has permission to use.

      sde_workspace(String):
    An enterprise geodatabase workspace."""
    ...

def ListUsers(sde_workspace: str) -> list[NamedTuple]:
    """ListUsers(sde_workspace)

    Returns a list of named tuples containing information for users who are
    connected to an enterprise geodatabase.

      sde_workspace(String):
    An
      enterprise geodatabase (sde connection file).

    The connection properties specified in the enterprise geodatabase must
    have administrative rights that allow the user to disconnect other
    connections."""
    ...

def DisconnectUser(
    sde_workspace: str, users: int | Sequence[int] | Literal["ALL"] = ...
) -> Any:
    """DisconnectUser(sde_workspace, {users})

    Allows an administrator to disconnect users who are currently connected
    to an Enterprise geodatabase.

      sde_workspace(String):
    The Enterprise geodatabase containing the users to be disconnected.

    The connection properties specified in the Enterprise Geodatabase must
    have administrative rights that allow the user to disconnect other
    connections.

      users{Integer}:
    Specifies which users will be disconnected from the geodatabase.

     * sde_id: The ID value returned from the ListUsers function or the
     Connections tab in the Geodatabase Administration dialog. This can be
     passed to the function as an individual sde_id or a Python list
     containing multiple sde_ids.

     * ALL: Keyword specifying that all connected users should be
     disconnected.

    DisconnectUser will not disconnect the user who is executing the
    function."""
    ...

@_gptooldoc(
    None,
    [[["FeatureLayer", "Table", "TableView", "Dataset", "FeatureDataset"], "", "", ""]],
)
def ListFields(
    dataset: str, wild_card: Optional[str] = None, field_type: FieldType = "All"
) -> list[Field]:
    """ListFields(dataset, {wild_card}, {field_type})

    Lists the fields in a feature class, shapefile, or table in a specified
    dataset. The returned list can be limited with search criteria for name
    and field type and will contain field objects.

      dataset(String):
    The specified feature class or table whose fields will be returned.

      wild_card{String}:
    The wild_card limits the results returned. If no wild_card is specified,
    all values are returned.

      field_type{String}:
    The specified field type to be returned. Valid field types are:

     * All:   All field types are returned. This is the default.

     * BLOB: Only field types of BLOB are returned.

     * Date:   Only field types of Date are returned.

     * Double:   Only field types of Double are returned.

     * Geometry:   Only field types of Geometry are returned.

     * GlobalID: Only field types of GlobalID are returned.

     * GUID:   Only field types of GUID are returned.

     * Integer:   Only field types of Integer are returned.

     * OID:   Only field types of OID are returned.

     * Raster:   Only field types of Raster are returned.

     * Single:   Only field types of Single are returned.

     * SmallInteger:   Only field types of SmallInteger are returned.

     * String:   Only field types of String are returned."""
    ...

@_gptooldoc(
    None,
    [[["FeatureLayer", "Table", "TableView", "Dataset", "FeatureDataset"], "", "", ""]],
)
def ListIndexes(dataset: str, wild_card: Optional[str] = None) -> Index:
    """ListIndexes(dataset, {wild_card})

    Lists the indexes in a feature class, shapefile, or table in a specified
    dataset. The list returned can be limited with search criteria for index
    name and will contain index objects.

      dataset(String):
    The specified feature class or table whose indexes will be returned.

      wild_card{String}:
    The wild_card limits the results returned. If no wild_card is specified,
    all values are returned."""
    ...

@_gptooldoc(
    None,
    [[["FeatureLayer", "Table", "TableView", "Dataset", "FeatureDataset"], "", "", ""]],
)
@deprecated("Use arcpy.da.SearchCursor instead.")
def SearchCursor(
    dataset, where_clause=..., spatial_reference=..., fields=..., sort_fields=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """SearchCursor(dataset, {where_clause}, {spatial_reference}, {fields},
    {sort_fields})

    The SearchCursor function establishes a read-only cursor on a feature
    class or table. The SearchCursor can be used to iterate through row
    objects and extract field values. The search can optionally be limited by
    a where clause or by field and optionally sorted.

      dataset(String):
    The feature class, shapefile, or table containing the rows to be
    searched.

      where_clause{String}:
    An optional expression that limits the rows returned in the cursor. For
    more information on WHERE clauses and SQL statements, see Build an SQL
    query .

      spatial_reference{SpatialReference}:
    When specified, features will be projected on the fly using the
    spatial_reference provided.

      fields{String}:
    The fields to be included in the cursor. By default, all fields are
    included.

      sort_fields{String}:
    Fields used to sort the rows in the cursor. Ascending and descending
    order for each field is denoted by A and D."""
    ...

@_gptooldoc(
    None,
    [[["FeatureLayer", "Table", "TableView", "Dataset", "FeatureDataset"], "", "", ""]],
)
@deprecated("Use arcpy.da.UpdateCursor instead.")
def UpdateCursor(
    dataset, where_clause=..., spatial_reference=..., fields=..., sort_fields=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """UpdateCursor(dataset, {where_clause}, {spatial_reference}, {fields},
    {sort_fields})

    The UpdateCursor function creates a cursor that lets you update or delete
    rows on the specified feature class, shapefile, or table. The cursor
    places a lock on the data that will remain until either the script
    completes or the update cursor object is deleted.

      dataset(String):
    The feature class, shapefile, or table containing the rows to be updated
    or deleted.

      where_clause{String}:
    An optional expression that limits the rows returned in the cursor. For
    more information on WHERE clauses and SQL statements, see SQL reference
    for elements used in query expressions .

      spatial_reference{SpatialReference}:
    Coordinates are specified in the spatial_reference provided and converted
    on the fly to the coordinate system  of the dataset.

      fields{String}:
    The fields to be included in the cursor. By default, all fields are
    included.

      sort_fields{String}:
    Fields used to sort the rows in the cursor. Ascending and descending
    order for each field is denoted by A and D."""
    ...

@_gptooldoc(
    None,
    [[["FeatureLayer", "Table", "TableView", "Dataset", "FeatureDataset"], "", "", ""]],
)
@deprecated("Use arcpy.da.InsertCursor instead")
def InsertCursor(
    dataset: str, spatial_reference: Optional[SpatialReference] = ...
) -> Cursor:
    """InsertCursor(dataset, {spatial_reference})

    Inserts rows into a feature class, shapefile, or table. The InsertCursor
    returns an enumeration object that hands out row objects.

      dataset(String):
    The table, feature class, or shapefile into which rows will be inserted.

      spatial_reference{SpatialReference}:
    Coordinates are specified in the spatial_reference provided and converted
    on the fly to the coordinate system  of the dataset."""
    ...

@_gptooldoc(
    None,
    [
        [
            [
                "FeatureLayer",
                "Table",
                "TableView",
                "Dataset",
                "FeatureDataset",
                "RasterDataset",
                "RasterLayer",
                "TinLayer",
                "LasDataset",
                "LasDatasetLayer",
            ],
            "",
            "",
            "",
        ]
    ],
)
def Describe(
    value: str,
    data_type: Optional[
        Literal[
            "FeatureLayer",
            "Table",
            "TableView",
            "Dataset",
            "FeatureDataset",
            "RasterDataset",
            "RasterLayer",
            "TinLayer",
            "LasDataset",
            "LasDatasetLayer",
        ]
    ] = None,
) -> (
    ...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """Describe(value, {data_type})

    The Describe function returns a Describe object, with multiple
    properties, such as data type, fields, indexes, and many others. Its
    properties are dynamic, meaning that depending on what data type is
    described, different describe properties will be available for use.

    Describe properties are organized into a series of property groups. Any
    particular dataset will acquire the properties of at least one of these
    groups. For instance, if describing a geodatabase feature class, you
    could access properties from the GDB FeatureClass, FeatureClass, Table,
    and Dataset property groups. All data, regardless of the data type, will
    always acquire the generic Describe Object properties.

      value(String):
    The specified data element or geoprocessing object to describe.

      data_type(String):
    The type of data. This is only necessary when naming conflicts exists,
    for example, if a geodatabase contains a feature dataset and a feature
    class with the same name. In this case, the data type is used to clarify
    which dataset you want to describe."""
    ...

GPObjectType = Literal[
    "ArcSDESQLExecute",
    "Array",
    "Extent",
    "FeatureSet",
    "Field",
    "FieldInfo",
    "FieldMap",
    "FieldMappings",
    "Geometry",
    "NetCDFFileProperties",
    "Point",
    "RecordSet",
    "Result",
    "SpatialReference",
    "ValueTable",
]

def CreateObject(
    name: GPObjectType, *options: list[Any]
) -> (
    ArcSDESQLExecute
    | Array
    | Extent
    | FeatureSet
    | Field
    | FieldInfo
    | FieldMap
    | FieldMappings
    | Geometry
    | NetCDFFileProperties
    | Point
    | RecordSet
    | Result
    | SpatialReference
    | ValueTable
):
    """CreateObject(name, {options})

    Creates geoprocessing objects. The extra arguments can be used to specify
    additional requirements for the object creation such as the number of
    columns in the ValueTable object.

      name(String):
    Name of the object to be created ( ArcSDESQLExecute , Array , Extent ,
    FeatureSet , Field , FieldInfo , FieldMap , FieldMappings , Geometry ,
    NetCDFFileProperties , Point , RecordSet , Result , SpatialReference ,
    ValueTable ).

      options{Object}:
    Optional argument(s) depend on the object being created."""
    ...

def ValidateFieldName(
    name: str, workspace: Optional[str] = None
) -> (
    bool
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """ValidateFieldName(name, {workspace})

    Takes a string (field name) and a workspace path and returns a valid
    field name based on name restrictions in the output geodatabase. All
    invalid characters in the input string will be replaced with an
    underscore (_). The field name restrictions depend on the specific
    database used (Structured Query Language [SQL] or Oracle).

      name(String):
    The field name to be validated. If the optional workspace is not
    specified, the field name is validated against the current workspace.

      workspace{String}:
    An optional specified workspace to validate the field name against. The
    workspace can be a file system or a personal, file, or enterprise
    geodatabase.

    If the workspace is not specified, the field name is validated using the
    current workspace environment.  If the workspace environment has not been
    set, the field name is validated based on a folder workspace."""
    ...

def ValidateTableName(
    name, workspace=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """ValidateTableName(name, {workspace})

    Takes a table name and a workspace path and returns a valid table name
    for the workspace. An underscore "_" will replace any invalid character
    found in the table name and will honor the name restrictions for the
    workspace. The table name restrictions depend on the specific RDBMS used.

      name(String):
    The table name to be validated.

      workspace{String}:
    The optional workspace against which to validate the table name.

    If the workspace is not specified, the table name is validated using the
    current workspace environment.  If the workspace environment has not been
    set, the table name is validated based on a folder workspace."""
    ...

def ParseFieldName(
    name, workspace=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """ParseFieldName(name, {workspace})

    Parses a fully qualified field name into its components (database, owner
    name, table name, and field name) depending on the workspace.
    ParseFieldName returns a string that includes the parsed table name and
    contains the database, owner, table, and field names, separated by
    commas. The workspace must be a personal, file, or enterprise
    geodatabase.

      name(String):
    The field name to be parsed.

      workspace{String}:
    Specifies the workspace for fully qualifying the field name. The
    workspace must be a personal, file, or enterprise geodatabase."""
    ...

def ParseTableName(
    name, workspace=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """ParseTableName(name, {workspace})

    Parses a table name into its components (database, owner, table)
    depending on the workspace. ParseTableName returns a string containing
    the parsed table name, with the database name, owner name, and table
    name, separated by commas. This workspace must be a personal, file, or
    enterprise geodatabase.

      name(String):
    Specifies which table will be parsed.

      workspace{String}:
    Specifies the workspace for fully qualifying the table name. The
    workspace must be a personal, file, or enterprise geodatabase."""
    ...

def CreateScratchName(
    prefix=..., suffix=..., data_type=..., workspace=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """CreateScratchName({prefix}, {suffix}, {data_type}, {workspace})

    Creates a unique scratch path name for the specified data type. If no
    workspace is given the current workspace is used.

      prefix{String}:
    The prefix that is added to the scratchname. By default, a prefix of xx
    is used.

      suffix{String}:
    The suffix added to the scratchname. This can be an empty double-quoted
    string.

      data_type{String}:
    The data type which will be used to create the scratchname. Valid
    datatypes are:

     * Coverage:   Only valid Coverage names are returned.

     * Dataset:   Only valid Dataset names are returned.

     * FeatureClass:   Only valid FeatureClass names are returned.

     * FeatureDataset:   Only valid FeatureDataset names are returned.

     * Folder:   Only valid Folder names are returned.

     * Geodataset:   Only valid Geodataset names are returned.

     * GeometricNetwork:   Only valid Geometric Network names are returned.

     * ArcInfoTable:   Only valid ArcInfo Table names are returned.

     * NetworkDataset:   Only valid Network Dataset names are returned.

     * RasterBand:   Only valid Raster Band names are returned.

     * RasterCatalog:   Only valid Raster Catalog names are returned.

     * RasterDataset:   Only valid Raster Dataset names are returned.

     * Shapefile:   Only valid Shapefile names are returned.

     * Terrain:   Only valid Terrain names are returned.

     * Workspace:   Only valid Workspace scratchnames are returned.

      workspace{String}:
    The workspace used to determine the scratch name to be created. If not
    specified, the current workspace is used."""
    ...

def CreateUniqueName(
    base_name, workspace=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """CreateUniqueName(base_name, {workspace})

    Creates a unique name in the specified workspace by appending a number to
    the input name. This number is increased until the name is unique. If no
    workspace is specified, the current workspace is used.

      base_name(String):
    The base name used to create the unique name.

      workspace{String}:
    The workspace used for creation of the unique name."""
    ...

def TestSchemaLock(
    dataset,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """TestSchemaLock(dataset)

    Tests if a schema lock can be acquired for a feature class, table, or
    feature dataset. Tools that alter schema will require a schema lock to be
    placed on the input data. The Add Field tool is an example of such a
    tool. If the tool requires a schema lock and is unable to aquire one at
    the time of execution, an appropriate error message is returned. Scripts
    that use such tools should test if a schema lock can be acquired on the
    input data. The TestSchemaLock function will not actually apply a schema
    lock on the input data, but will return a Boolean.

      dataset(String):
    The input data to be tested if a schema lock can be applied."""
    ...

def IsBeingEdited(dataset):  # -> Any:
    """IsBeingEdited(dataset):

    Determines whether the dataset is currently in an edit session.

      dataset(String):
    The input dataset to be checked for an ongoing edit session."""
    ...

def CreateRandomValueGenerator(
    seed, distribution
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """CreateRandomValueGenerator(seed, distribution)

    Creates a new random number generator.

      seed(Integer):
    Initializes the random number generator.

      distribution(String):
    The random generation algorithm.

     * ACM599:   ACM collected algorithm 599

     * MERSENNE_TWISTER:   Mersenne Twister mt19937

     * STANDARD_C:   Standard C Rand"""
    ...

def IsSynchronous(
    tool_name,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """IsSynchronous(tool_name)

    Determines if a tool is running synchronous or asynchronous. When a tool
    is synchronous , the results are automatically returned, but no other
    action may be taken until the tool has completed. All non-server tools
    are synchronous. Server tools may be asynchronous , meaning that once the
    tool has been submitted to the server, other functionality can be run
    without waiting, and the results must be explicitly requested from the
    server.

      tool_name(String):
    The name of the tool to determine if it is synchronous."""
    ...

def GetParameterCount(
    tool_name,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """GetParameterCount(tool_name)

    Returns a count of the parameter values for the specified tool. If the
    tool is contained in a custom toolbox, use ImportToolbox to access the
    custom tool.

      tool_name(String):
    The name of the tool for which the number of parameters will be returned."""
    ...

def GetParameterValue(
    tool_name, index
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """GetParameterValue(tool_name, index)

    For a specified tool name, returns the default value of the desired
    parameter.

      tool_name(String):
    The tool name for which the parameter default value will be returned.

      index(Integer):
    Index position of the parameter in the specified tool's parameter list."""
    ...

def GetParameterInfo(
    tool_name: str,
) -> list[
    Parameter
]:  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """GetParameterInfo(tool_name)

    Returns a list of parameter objects for a given tool and is commonly used
    in a script tool's ToolValidator class.

      tool_name(String):
    The tool name. Including the toolbox alias will help to resolve any
    conflicts with duplicate tool names. When the GetParameterInfo function
    is used as part of a script tool's ToolValidator class, the tool_name
    argument is optional."""
    ...

def AddFieldDelimiters(
    datasource, field
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """AddFieldDelimiters(datasource, field)

    Adds field delimiters to a field name to allow for use in SQL
    expressions.

    The field delimiters used in an SQL expression
    differ depending on the format of the queried data. For instance,
    file geodatabases and shapefiles use double quotation marks (" "),
    personal geodatabases use square brackets
    ([ ]), and enterprise geodatabases don't use field
    delimiters. The
     function can take away the guess work
    in ensuring that the field delimiters used with your SQL expression
    are the correct ones.

      datasource(String):
    The field delimiters are based on the data source used.

      field(String):
    The field name to which delimiters will be added.  The field does not
    have to currently exist."""
    ...

def ListPrinterNames():  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """ListPrinterNames()

    Returns a list of available printers on the local computer."""
    ...

def GetSeverity(
    index,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """GetSeverity(index)

    Gets the severity code (0, 1, 2) of the specified message by index.

      index(Integer):
    Numeric index position of the message in the stack."""
    ...

def GetMessageCount():  # -> Any:
    """GetMessageCount()

    Returns a numeric count of all the returned messages from the last
    executed command."""
    ...

def GetMaxSeverity():  # -> Any:
    """GetMaxSeverity()

    Gets the maximum severity returned from the last executed tool."""
    ...

def GetSeverityLevel():  # -> Any:
    """GetSeverityLevel()

    Returns the severity level. The severity level is used to control how
    geoprocessing tools throw exceptions."""
    ...

def SetSeverityLevel(severity):  # -> None:
    """SetSeverityLevel(severity_level)

    Used to control how geoprocessing tools throw exceptions.

      severity_level(Integer):
    The severity level

     * 0:   A tool will not throw an exception, even if the tool produces an
     error or warning.

     * 1:   If a tool produces a warning or an error, it will throw an
     exception.

     * 2:   If a tool produces an error, it will throw an exception. This is
     the default."""
    ...

def GetArgumentCount():  # -> Any:
    """GetArgumentCount()

    Returns the number of arguments passed to the script."""
    ...

def GetLogHistory():  # -> Any:
    """GetLogHistory()

    For script tools and stand-alone scripts , you can determine
    whether history logging is active using the GetLogHistory function."""
    ...

def SetLogHistory(log_history):  # -> None:
    """SetLogHistory(log_history)

    For script tools and stand-alone scripts  you can enable or disable
    history logging using the SetLogHistory function.

      log_history(Boolean):
    True , to enable geoprocessing logging history and False , to disable."""
    ...

def GetLogMetadata():  # -> Any:
    """GetLogMetadata()

           For script tools and stand-alone scripts, returns True if gp tools
           will update the dataset metadata's process lineage log found at
           //Esri/DataProperties/lineage/Process
    ."""
    ...

def SetLogMetadata(log_metadata):  # -> None:
    """SetLogMetadata(log_metadata)

    For script tools and stand-alone scripts  you can enable or disable
    if gp tools will update the dataset metadata's process lineage found at
    //Esri/DataProperties/lineage/Process

      log_metadata(Boolean):
    True, to enable updating of the dataset metadata's process lineage log and False to disable.
    """
    ...

def FromWKB(
    byte_array, spatial_reference=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """FromWKB(byte_array)

    Create a new Geometry object from a well-known binary (WKB) string stored
    in a Python bytearray .

      byte_array(Bytearray):
    A WKB string stored in a Python bytearray ."""
    ...

def FromWKT(
    wkt_string, spatial_reference=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """FromWKT(wkt_string, {spatial_reference})

    Create a new Geometry object from a well-known text (WKT) string.

      wkt_string(String):
    A WKT string.

      spatial_reference{SpatialReference}:
    The spatial reference of the geometry. It can be specified with either a
    SpatialReference object or string equivalent."""
    ...

def FromGeohash(
    geohash_string,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """FromGeohash(geohash_string)

    Converts a geohash string to an Extent object in WGS 1984 coordinates
    that represents the corresponding bounding box in the geohash grid.

      geohash_string(String):
    The geohash string used to obtain the extent in WGS 1984 coordinates."""
    ...

def LinearUnitConversionFactor(from_unit, to_unit):  # -> Any:
    """LinearUnitConversionFactor(from_unit, to_unit)

    Gets the conversion factor between two linear units.

      from_unit(String):
    The linear unit to convert from.

      to_unit(String):
    The linear unit to convert to."""
    ...

def ArealUnitConversionFactor(from_unit, to_unit):  # -> Any:
    """ArealUnitConversionFactor(from_unit, to_unit)

    Gets the conversion factor between two areal units.

         from_unit(String):
       The areal unit to convert from.

         to_unit(String):
       The areal unit to convert to."""
    ...

def AcceptConnections(sde_workspace, accept_connections):
    """AcceptConnections(sde_workspace, accept_connections)

    Allows an administrator to enable or disable the ability of
    nonadministrative users to make connections to an enterprise geodatabase.

      sde_workspace(String):
    The Enterprise geodatabase that will have its connection property
    altered.

    The connection properties specified in the Enterprise Geodatabase must be
    the geodatabase administrator.

      accept_connections(Boolean):
    Boolean value indicating if the geodatabase will accept connections
    (True) or will not accept connections (False)."""
    ...

def AlterAliasName(table, alias):
    """AlterAliasName(table, alias)

    Updates the alias name for a table or feature class.

      table(String):
    Input table or feature class.

      alias(String):
    The new alias name."""
    ...

def LogUsageMetering(code, task_name, num_objects=..., units=...):
    """LogUsageMetering(code, task_name, num_objects, units)

    Updates the usage metering for this server tool."""
    ...

def AttachLocator(
    loc_path, fc_path, input_field_names, output_field_names, settings=...
):
    """AttachLocater(loc_path, fc_path, input_field_names, output_field_names)

        Records the locator used to create the geocode results in the feature class at fc_path.

          loc_path(String):
    A string that represents the catalog path to the address locator. Valid
    formats for the address locator are locator files ( .loc ) in a file
    folder or locators in a geodatabase.

          fc_path(String):
        A string representing the catalog path to the feature class created by batch
        geocoding with the given locator.

          input_field_names(String)
        A string containing a comma-separated list of the input field names.

          output_field_names(String)
        A string containing a comma-separated list of the output field names.

      settings(Dictionary)
    A dictionary of string keys to string values indicating the geocode settings used to generate the FeatureClass.
    """
    ...

def CreateGeocodeSDDraft(
    loc_path,
    out_sddraft,
    service_name,
    server_type=...,
    connection_file_path=...,
    copy_data_to_server=...,
    folder_name=...,
    summary=...,
    tags=...,
    max_result_size=...,
    max_batch_size=...,
    suggested_batch_size=...,
    supported_operations=...,
    overwrite_existing_service=...,
):
    """CreateGeocodeSDDraft(loc_path, out_sddraft, service_name, {server_type},
    {connection_file_path}, {copy_data_to_server}, {folder_name}, {summary},
    {tags}, {max_candidates}, {max_batch_size}, {suggested_batch_size},
    {supported_operations}, {overwrite_existing_service})

    The function converts  an address locator into a Service Definition Draft
    ( .sddraft ) file, which can be used to create a service definition for
    publishing a geocode service.

    Service Definition Draft ( .sddraft )  files must be converted into
    Service Definition ( .sd ) files before they can be use to publish for
    ArcGIS for Server . These functions are not included in ArcGIS Pro at
    this time. ArcGIS for Desktop is required to stage and publish.

    A draft service definition does not contain data. A draft service alone
    cannot be used to publish a service.

      loc_path(String):
    A string that represents the catalog path to the address locator. Valid
    formats for the address locator are locator files ( .loc ) in a file
    folder or locators in a geodatabase.

      out_sddraft(String):
    A string that represents the path and file name for the output Service
    Definition Draft ( .sddraft ) file.

      service_name(String):
    A string that represents the name of the service. This is the name
    people will see and use to identify the service. The name can only
    contain alphanumeric characters and underscores. No spaces or
    special characters are allowed. The name cannot be more than 120
    characters in length.

      server_type{String}:
    A string representing the server type.
    If a connection_file_path parameter is not supplied, then a server_type
    must be provided. If a connection_file_path parameter is supplied, then
    the server_type is taken from the connection file. In this case, you can
    choose FROM_CONNECTION_FILE or skip the parameter entirely.

     * ARCGIS_SERVER:  ArcGIS for Server server type.

     * FROM_CONNECTION_FILE: Get the server_type as specified in the
     connection_file_path parameter.

      connection_file_path{String}:
    A string that represents the path and file name to the ArcGIS for Server
    connection file  ( .ags ).

      copy_data_to_server{Boolean}:
    A Boolean that indicates whether the data referenced in the address
    locator will be copied to the server or not.
    The copy_data_to_server parameter is only used if the server_type is
    ARCGIS_SERVER and the connection_file_path isn't specified. If the
    connection_file_path is specified, then the server's registered data
    stores are used. For example, if the data in the address locator is
    registered with the server, then copy_data_to_server will always be False
    . Conversely, if the data in the address locator is not registered with
    the server, then copy_data_to_server will always be True .

      folder_name{String}:
    A string that represents  a folder name to which you want to publish the
    service definition. If the folder does not currently exist, it will be
    created when the service definition is published as a service.  The
    default folder is the server root level.

      summary{String}:
    A string that represents the Item Description Summary.

    Use this parameter to override the user interface summary, or to provide
    a summary if one does not exist.

      tags{String}:
    A string that represents the Item Description Tags.

    Use this parameter to override the user interface tags, or to provide
    tags if they do not exist. To specify multiple tags, separate each tag
    with a comma within the string.

      max_candidates{Integer}:
    The maximum number of candidates returned by the service when geocoding a
    single address.

      max_batch_size{Integer}:
    The maximum number of records to be processed in each batch job when
    performing batch geocoding.

      suggested_batch_size{Integer}:
    The recommended number of records to pass in each batch job when
    performing batch geocoding.

      supported_operations{List}:
    The built-in operations supported by the service. The parameter should be
    specified as a list containing one or more of the following string
    keywords: GEOCODE —The service will allow geocoding operations.
    REVERSE_GEOCODE —The service will allow  reverse geocoding operations.
    SUGGEST —The service will allow suggest operations.

    For example, to specify that the service should only support geocoding
    operations and should not allow any reverse geocoding operations, the
    parameter should be specified as ["GEOCODE"] .

      overwrite_existing_service{Boolean}:
    Set this parameter to True if you want the published service to replace
    an existing service."""
    ...

def CreateGPSDDraft(
    result,
    out_sddraft,
    service_name,
    server_type=...,
    connection_file_path=...,
    copy_data_to_server=...,
    folder_name=...,
    summary=...,
    tags=...,
    executionType=...,
    resultMapServer=...,
    showMessages=...,
    maximumRecords=...,
    minInstances=...,
    maxInstances=...,
    maxUsageTime=...,
    maxWaitTime=...,
    maxIdleTime=...,
    capabilities=...,
    constantValues=...,
    choiceLists=...,
):
    """CreateGPSDDraft(result, out_sddraft, service_name, {server_type},
    {connection_file_path}, {copy_data_to_server}, {folder_name}, {summary},
    {tags}, {executionType}, {resultMapServer}, {showMessages},
    {maximumRecords}, {minInstances}, {maxInstances}, {maxUsageTime},
    {maxWaitTime}, {maxIdleTime}, {capabilities}, {constantValues})

    The function converts Result objects and result files ( .rlt ) into
    Service Definition Draft ( .sddraft ) files.

    Service Definition Draft ( .sddraft )  files must be converted into
    Service Definition ( .sd ) files before they can be use to publish for
    ArcGIS for Server . These functions are not included in ArcGIS Pro at
    this time. ArcGIS for Desktop is required to stage and publish.

    A draft service definition does not contain data. A draft service alone
    cannot be used to publish a service.

      result(Result):
    A reference to one or multiple Result objects or result files ( .rlt ) on
    disk. Multiple results must be supplied in a list format. The following
    example demonstrates multiple results as input to the CreateGPSDDraft
    function.   import arcpy
    r1 = arcpy.Buffer_analysis("inPts", "output.shp", "100 Meters")
    r2 = arcpy.GetCount_management("FireStations")
    arcpy.CreateGPSDDraft([r1, r2], "output.sddraft", "myservice")

      out_sddraft(String):
    A string that represents the path and file name for the output Service
    Definition Draft ( .sddraft ) file.

      service_name(String):
    A string that represents the name of the service. This is the name
    people will see and use to identify the service. The name can only
    contain alphanumeric characters and underscores. No spaces or
    special characters are allowed. The name cannot be more than 120
    characters in length.

      server_type{String}:
    A string representing the server type.
    If a connection_file_path parameter is not supplied, then a server_type
    must be provided. If a connection_file_path parameter is supplied, then
    the server_type is taken from the connection file. In this case, you can
    choose FROM_CONNECTION_FILE or skip the parameter entirely.

     * ARCGIS_SERVER:  ArcGIS for Server server type

     * FROM_CONNECTION_FILE: Get the server_type as specified in the
     connection_file_path parameter

      connection_file_path{String}:
    A string that represents the path and file name to the ArcGIS for Server
    connection file  ( .ags ).

      copy_data_to_server{Boolean}:
    A Boolean that indicates whether the data referenced in the result will
    be copied to the server or not.
    The copy_data_to_server parameter is only used if the server_type is
    ARCGIS_SERVER and the connection_file_path isn't specified. If the
    connection_file_path is specified, then the server's registered data
    stores are used. For example, if the data in the result is registered
    with the server, then copy_data_to_server will always be False .
    Conversely, if the data in the result is not registered with the server,
    then copy_data_to_server will always be True .

      folder_name{String}:
    A string that represents  a folder name to which you want to publish the
    service definition. If the folder does not currently exist, it will be
    created.  The default folder is the server root level.

      summary{String}:
    A string that represents the Item Description Summary.

    Use this parameter to override the user interface summary, or to provide
    a summary if one does not exist. The summary provided here will not be
    persisted in the map document.

      tags{String}:
    A string that represents the Item Description Tags.

    Use this parameter to override the user interface tags, or to provide
    tags if they do not exist. The tags provided here will not be persisted
    in the map document.

      executionType{String}:
    Asynchronous and synchronous define how the client (the application using
    the task) interacts with the server and gets the result from the task.
    When a service is set to synchronous, the client waits for the task to
    finish. Typically, a synchronous task executes  quickly—five seconds or
    less. An asynchronous task typically takes longer to execute, and the
    client must periodically ask the server if the task has finished and, if
    it has finished, get the result.  A web application using an asynchronous
    task must have logic implemented to check the status of a task and handle
    the result once execution is finished. ArcGIS Desktop clients handle both
    execution types natively.

      resultMapServer{Boolean}:
    When publishing a geoprocessing service, you can choose to view the
    result of all tasks with the service as a map (in addition to other
    results of your task). The map is created on the server using a Map
    Service for transport back to the client as an image (a .jpeg , for
    example). The symbology, labeling, transparency, and all other properties
    of the returned map are the same as the settings of your output layer.
    Remember, if you are creating result layers within the Python scripting
    environment (outside ArcMap), default symbologies will be used. To
    maintain control over symbology you will need to pre-create layer files
    with rich symbology and use them to modify the output symbology of your
    task.

    When you choose this option, a map service is automatically created
    on the server with the same name as your geoprocessing service.

      showMessages{String}:
    A string setting the message level for the geoprocessing service. The
    following is a list of valid message levels the service will return to
    the client.

     * None:  No geoprocessing messages are returned to the client, only
     whether
    the execution was successful or failed.

     * Error: Only tool messages that produce an error are returned to the
    client.

     * Warning:  All tool error and warning messages are returned to the
     client.

     * Info:  All tool messages from execution are returned to the client.

      maximumRecords{Integer}:
    The maximum number of results the service can return to a client. Setting
    this value to a large number means your GIS server can handle sending  a
    lot of individual records or features to the client.   If you don't want
    to return any features, set this value to 0 (zero).  Typically, you set
    this value to zero only when you enable View result with a map service .

      minInstances{Integer}:
    An integer value representing the minimum number of instances a service
    will start and make available for use. For heavily used services you may
    want to increase this value.

      maxInstances{Integer}:
    An integer value representing the maximum number of instances a service
    can start and make available for use. For heavily used services you may
    need to increase this value. Ensure the server has adequate hardware to
    support the maximum number of instances you will allow.

      maxUsageTime{Integer}:
    The maximum time, in seconds, that a service can be used. You may need to
    increase the default of 600 seconds (10 minutes) for long-running
    geoprocessing tasks. Alternatively, you may need to reduce this time to
    ensure a client will not abuse your services.

      maxWaitTime{Integer}:
    The maximum time, in seconds, that a client will wait to connect with an
    instance before timing out. When all instances are busy processing
    requests, subsequent requests are queued. If this time-out elapses before
    an instance becomes available, the task will fail. The default is 60
    seconds (1 minute).

      maxIdleTime{Integer}:
    The maximum time, in seconds, that an instance will continue to be active
    before pool shrinking occurs. Any instances above the minimum number of
    instances that have not been used will be shut down once the idle maximum
    time value has elapsed.

     capabilities{String}:
    Capabilities that a service can support. Currently, only "UPLOADS" is
    supported.

     constantValues{List}:
    List of ToolName.ParameterName which should be set as constant.

     choiceLists{List}:
    Specify the supported values for a string parameter.
    """
    ...

def CreateImageSDDraft(
    raster_or_mosaic_layer,
    out_sddraft,
    service_name,
    server_type=...,
    connection_file_path=...,
    copy_data_to_server=...,
    folder_name=...,
    summary=...,
    tags=...,
):
    """CreateImageSDDraft(raster_or_mosaic_layer, out_sddraft, service_name,
    {server_type}, {connection_file_path}, {copy_data_to_server},
    {folder_name}, {summary}, {tags})

    The CreateImageSDDraft function is the first step to automating the
    publishing of a mosaic dataset or raster dataset as an Image Service
    using ArcPy. The output created from the CreateImageSDDraft is a Service
    Definition Draft ( .sddraft )  file, which is a combination of a mosaic
    dataset in the geodatabase or a raster dataset, information about the
    server, and a set of service properties. This service definition draft
    can be staged as service definition then uploaded to a specified ArcGIS
    server as an image service.

    Service Definition Draft ( .sddraft )  files must be converted into
    Service Definition ( .sd ) files before they can be use to publish for
    ArcGIS for Server . These functions are not included in ArcGIS Pro at
    this time. ArcGIS for Desktop is required to stage and publish.

    Information about the server includes the server connection or server
    type being published to, the type of service being published, metadata
    for the service (Item info), and data references (whether or not data is
    being copied to the server).

    A draft service definition does not contain data. A draft service alone
    cannot be used to publish a service.

      raster_or_mosaic_layer(String):
    The raster layer or mosaic layer that you want to publish.

      out_sddraft(String):
    A string that represents the path and file name for the output Service
    Definition Draft (.sddraft) file.

      service_name(String):
    A string that represents the name of the service. This is the name
    people will see and use to identify the service. The name can only
    contain alphanumeric characters and underscores. No spaces or
    special characters are allowed. The name cannot be more than 120
    characters in length.

      server_type{String}:
    A string representing the server type.
    If a connection_file_path parameter is not supplied, then a server_type
    must be provided. If a connection_file_path parameter is supplied, then
    the server_type is taken from the connection file. In this case, you can
    choose FROM_CONNECTION_FILE or skip the parameter entirely.

     * ARCGIS_SERVER:  ArcGIS for Server server type.

     * FROM_CONNECTION_FILE: Get the server_type as specified in the
     connection_file_path parameter.

      connection_file_path{String}:
    A string that represents the path and file name to the ArcGIS for Server
    connection file  ( .ags ).

      copy_data_to_server{Boolean}:
    A Boolean that indicates whether the source data referenced by the mosaic
    dataset, the mosaic dataset itself, or the raster dataset published as an
    image service will be copied to the server or not.

    The copy_data_to_server parameter is only used if the server_type is
    ARCGIS_SERVER and the connection_file_path isn't specified. If the
    connection_file_path is specified, then the server's registered data
    stores are used. For example, if the workspace that contains the source
    data referenced by the mosaic dataset—the mosaic dataset itself or raster
    dataset registered with the server—then copy_data_to_server will always
    be False . Conversely, if the workspace that contains the source data
    referenced by the mosaic dataset—the mosaic dataset or raster dataset is
    not registered with the server—then copy_data_to_server will always be
    True .

     * False: The data will not be copied to the server. This is the default.

     * True: The data will be copied to the server.

      folder_name{String}:
    A string that represents  a folder name to which you want to publish the
    service definition. If the folder does not currently exist, it will be
    created.  The default folder is the server root level.

      summary{String}:
    A string that
    represents the Item Description Summary.

    Use this
    parameter to override the user interface summary or to provide a
    summary if one does not exist.

      tags{String}:
    A string that
    represents the Item Description Tags.

    Use this
    parameter to override the user interface tags or to provide tags
    if they do not exist."""
    ...

def ListDataStoreItems(connection_file, datastore_type):
    """ListDataStoreItems(connection_file, datastore_type)

    Returns a list of the folders or databases registered with an ArcGIS
    Server site.

      connection_file(String):
    An ArcGIS Server connection file (.ags) for the server whose registered
    databases or folders you want to list.
    If you've made a connection in the Catalog window of ArcMap, you can use
    the connection file found in your user profile directory.

      datastore_type(String):
    The type of data that you want to list.

     * DATABASE: Enterprise databases registered with the server will be
     listed.

     * FOLDER: File-based data sources registered with the server will be
     listed."""
    ...

def ValidateDataStoreItem(connection_file, datastore_type, connection_name):
    """ValidateDataStoreItem(connection_file, datastore_type, connection_name)

    Validates whether a folder or database has been successfully registered
    with an ArcGIS Server site.

      connection_file(String):
    An ArcGIS Server connection file (.ags) for the server whose registered
    database or folder is being validated.
    If you've made a connection in ArcCatalog, you can use the connection
    file found in your user profile directory.

      datastore_type(String):
    The type of data being validated.

     * DATABASE: The data resides in an enterprise database.

     * FOLDER: The data is file-based.

      connection_name(String):
    The name by which the folder or database being validated is registered
    with the ArcGIS Server site."""
    ...

def RemoveDataStoreItem(connection_file, datastore_type, connection_name):
    """RemoveDataStoreItem(connection_file, datastore_type, connection_name)

    Unregisters a folder or database from an ArcGIS Server site.

      connection_file(String):
    An ArcGIS Server connection file (.ags) for the server whose database or
    folder is being unregistered.
    If you've made a connection in ArcCatalog, you can use the connection
    file found in your user profile directory.

      datastore_type(String):
    The type of data being unregistered.

     * DATABASE: The data resides in an enterprise database.

     * FOLDER: The data is file-based.

      connection_name(String):
    The name of the folder or database being unregistered, as it is currently
    registered with the ArcGIS Server site."""
    ...

def AddDataStoreItem(
    connection_file,
    datastore_type,
    connection_name,
    server_path,
    client_path=...,
    hostname=...,
):
    """AddDataStoreItem(connection_file, datastore_type, connection_name,
    server_path, {client_path}, {hostname})

    Registers a folder or database with an ArcGIS Server site.

      connection_file(String):
    An ArcGIS Server connection file (.ags) representing the server with
    which you want to register the data.
    If you've made a connection in ArcCatalog you can use the connection file
    found in your user profile directory.

      datastore_type(String):
    The type of data being registered.

     * DATABASE: The data resides in an enterprise database.

     * FOLDER: The data is file-based.

      connection_name(String):
    A name for this folder or database that publishers or administrators will
    see when they view the server properties.

      server_path(String):
    The path or connection to the data as seen by the server.

    If you are registering a DATABASE , this is either the path to a database
    connection file (.sde) or a string containing the database connection
    parameters.

    If you are registering a FOLDER , this is the path to the folder.

      client_path{String}:
    The path or connection to the data as seen by the publisher's machine, if
    different from the information used by the server. In some cases the
    publisher and the server may be referencing physically distinct databases
    or folders. When you provide the publisher path and the server path,
    ArcGIS Server automatically corrects the paths at publish time when your
    map documents and other resources are transferred to the server.

    If you are registering a DATABASE , provide either the path to a database
    connection file (.sde) or a string containing the database connection
    parameters.

    If you are registering a FOLDER , provide the path to the folder.

    If you are registering ArcGIS Server's Managed Database, do not provide a
    path; instead, provide the string managed for this parameter. ArcGIS
    Server's Managed Database is an enterprise geodatabase you designate
    where data can be copied at publish time if a user attempts to publish a
    feature service from an unregistered data location.

      hostname{String}:
    The name of the publisher or client machine that will use this registered
    folder or database. If left blank, the name of the machine running the
    script will be used."""
    ...

def GetSigninToken():
    """GetSigninToken()

    Returns token information
    when signed in to ArcGIS.com or a local portal."""
    ...

def GetActivePortalURL():
    """GetActivePortalURL()

    The GetActivePortalURL function returns the URL of the active portal."""
    ...

def ListPortalURLs():
    """ListPortalURLs()

    The ListPortalURLs function returns a list of available portal URLs."""
    ...

def GetPortalDescription(portal_URL=...):  # -> Any:
    """GetPortalDescription({portal_URL})

    The GetPortalDescription function returns a dictionary containing
    information on the portal.

      portal_URL{String}:
    The portal URL.
    By default it uses the URL returned by GetActivePortalURL
    """
    ...

def GetPortalInfo(portal_URL=...):
    """GetPortalInfo({portal_URL})

    The GetPortalInfo function returns a dictionary that contains information
    on available portals.

      portal_URL{String}:
    The portal URL.
    By default it uses the URL returned by GetActivePortalURL."""
    ...

def DecryptPYT(toolbox=..., password=...):
    """DecryptPYT(toolbox, password)

    Decrypt an encrypted Python toolbox file.

      toolbox{String}:
    The encrypted Python toolbox that will be unencrypted.

      password{String}:
    The password used to unlock the encrypted Python toolbox."""
    ...

def EncryptPYT(toolbox=..., password=...):
    """EncryptPYT(toolbox, password)

    Encrypts a Python toolbox file.

      toolbox{String}:
    The Python toolbox that will be encrypted in place.

      password{String}:
    The password used to lock the encrypted Python toolbox."""
    ...

@_gptooldoc(None, [[["RasterLayer", "RasterDataset", "FormulatedRaster"], "", "", ""]])
def RasterToNumPyArray(*args, **kwargs):
    """RasterToNumPyArray(in_raster, {lower_left_corner}, {ncols}, {nrows},
    {nodata_to_value})

    Converts a raster to a NumPy array.

      in_raster(Raster):
    The input raster to convert to a NumPy array.

      lower_left_corner{Point}:
    The lower left corner within the in_raster from which to  extract the
    processing block to  convert to an array.
    The x-  and y-values are in map units. If no value is specified, the
    origin of the input raster  will be used.

      ncols{Integer}:
    The number of columns from the lower_left_corner in the in_raster to
    convert to the NumPy array.

    If no  value is specified, the  number of columns of the input raster
    will be used.

      nrows{Integer}:
    The number of rows from the lower_left_corner in the in_raster to convert
    to the NumPy array.

    If no value is specified, the number of rows of the input raster will
    used.

      nodata_to_value{Variant}:
    The value to assign the in_raster NoData values in the resulting NumPy
    array.

    If no value is specified, the NoData value of in_raster will be used."""
    ...

def NumPyArrayToRaster(*args, **kwargs):
    """NumPyArrayToRaster(in_array, {lower_left_corner}, {x_cell_size},
    {y_cell_size}, {value_to_nodata}, {mdinfo})

    Converts a NumPy array to a raster.

      in_array(NumPyArray):
    The NumPy array to convert to a raster. A two- or three-dimensional NumPy
    array is required.

      lower_left_corner{Point}:
    A Point object  defining the lower left corner of the output raster in
    map units.

    The default will set the lower left corner to coordinate (0.0, 0.0).

      x_cell_size{Double}:
    The cell size in the x direction specified in map units. The input can be
    a specified cell size (type: double) value,  or a raster.

    When a dataset is specified, the x cell size of that dataset is used for
    the x cell size of  the output raster.

    If only the x_cell_size is identified and not the y_cell_size , a square
    cell will result with the specified size.

    If neither x_cell_size nor y_cell_size is specified, a default of 1.0
    will be used for both the x and y cell size.

      y_cell_size{Double}:
    The cell size in the y direction specified in map units. The input can be
    a specified cell size (type: double) value, or a raster.

    When a dataset is specified, the x cell size of that dataset is used for
    the y cell size of  the output raster.

    If only the y_cell_size is identified and not the x_cell_size , a square
    cell will result with the specified size.

    If neither x_cell_size nor y_cell_size is specified, a default of 1.0
    will be used for both the x and y cell size.

      value_to_nodata{Double}:
    The value in the NumPy array to assign to NoData in the output raster. If
    no value is specified for value_to_nodata , there will not be any NoData
    values in the resulting raster.

      mdinfo:
    The json or string that defines the multidimensional information"""
    ...

def GetImageEXIFProperties(*args, **kwargs):
    """GetImageEXIFProperties(in_geotagged_image)

    Extract GPS location coordinates from geotagged image.

      in_geotagged_image(String):
    The path to a image file that contains GPS location information, typically in the
    EXIF header."""
    ...

def GetUTMFromLocation(*args, **kwargs):
    """GetUTMFromLocation(lon, lat)

    Create WGS84 UTM Zone spatial reference from GPS cooridnate in decimal degree.

      lon(Double):
    longitude in decimal degree.

      lat(Double):
    latitude in decimal degree."""
    ...

def SetRasterKeyMetadata(*args, **kwargs):
    """SetRasterKeyMetadata(in_raster, name, value)

    Create and set a key property for the input raster dataset or mosaic dataset

      in_raster(String):
    The path to a raster dataset or mosaic dataset.

      name(String):
    Key property name.

      value(String):
    Key property value."""
    ...

def GetRasterKeyMetadata(*args, **kwargs):
    """GetRasterKeyMetadata(in_raster, name)

    Get a key metadata value from a raster dataset or mosaic dataset

      in_raster(String):
    The path to a raster dataset or mosaic dataset.

      name(String):
    Key property name."""
    ...

def SignInToPortal(*args, **kwargs):
    """SignInToPortal(portal_url, {username}, {password}, {cert_file}, {key_file})."""
    ...

def ImportCredentials(*args, **kwargs):
    """ImportCredentials(secure_server_connections)."""
    ...

def ClearCredentials(*args, **kwargs):
    """ClearCredentials(connections)."""
    ...
