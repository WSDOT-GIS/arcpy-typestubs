"""
This type stub file was generated by pyright.
"""

from arcpy.geoprocessing._base import gptooldoc

r"""The Parcel toolbox contains tools to create, administer, and load data
into parcel fabrics."""
__all__ = [
    "AddParcelType",
    "AnalyzeParcelsByLeastSquaresAdjustment",
    "AppendParcels",
    "ApplyParcelLeastSquaresAdjustment",
    "BuildParcelFabric",
    "CopyParcels",
    "CreateParcelFabric",
    "CreateParcelRecords",
    "DisableParcelTopology",
    "EnableParcelTopology",
    "ExportSequencedParcelFeatures",
    "GenerateParcelFabricLinks",
    "ImportParcelFabricPoints",
    "MergeCollinearParcelBoundaries",
    "RemoveParcelType",
    "SetParcelLineLabelPosition",
    "UpgradeArcMapParcelFabric",
    "ValidateParcelFabric",
]
__alias__ = ...

@gptooldoc("AnalyzeParcelsByLeastSquaresAdjustment_parcel", None)
def AnalyzeParcelsByLeastSquaresAdjustment(
    in_parcel_fabric=..., analysis_type=..., convergence_tolerance=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """AnalyzeParcelsByLeastSquaresAdjustment_parcel(in_parcel_fabric, analysis_type, {convergence_tolerance})

       Analyzes the parcel fabric measurement network by running a least-
       squares adjustment on the input parcels. A least-squares adjustment is
       a mathematical procedure that uses statistical analysis to estimate
       the most likely coordinates for connected points in a measurement
       network. A least-squares adjustment can be run on the parcel fabric to
       evaluate and improve spatial accuracy of parcel corner point
       locations.

    INPUTS:
     in_parcel_fabric (Parcel Layer):
         The input parcel fabric to be analyzed by least-squares adjustment.
     analysis_type (String):
         Specifies the type of least-squares analysis that will be used in the
         adjustment.

         * CONSISTENCY_CHECK-A free-network least-squares adjustment will be
         run to check dimensions on parcel lines for inconsistencies and
         mistakes. Fixed or weighted control points will not be used by the
         adjustment.

         * WEIGHTED_LEAST_SQUARES-A weighted least-squares adjustment will be
         run to compute updated coordinates for parcel points. The parcels
         being adjusted should connect to at least two fixed or weighted
         control points.
     convergence_tolerance {Linear Unit}:
         The tolerance representing the maximum coordinate shift expected after
         iterating the least-squares adjustment. A least-squares adjustment is
         run repeatedly (in iterations) until the solution converges. The
         solution is considered converged when maximum coordinate shift
         encountered becomes less than the specified convergence tolerance. The
         default value is 0.05 meters."""
    ...

@gptooldoc("AppendParcels_parcel", None)
def AppendParcels(
    in_parcel_fabric=..., target_parcel_fabric=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """AppendParcels_parcel(in_parcel_fabric, target_parcel_fabric)

       Appends parcels from an input parcel fabric to a target parcel fabric.
       If the input parcel fabric is a parcel fabric layer with selected
       polygons, the corresponding parcel features will be appended.

    INPUTS:
     in_parcel_fabric (Parcel Layer):
         The input parcels that will be appended to the target parcel fabric.
         The input parcel fabric can be from a file, enterprise, or mobile
         geodatabase, or a feature service.
     target_parcel_fabric (Parcel Layer):
         The target parcel fabric to which the parcels will be appended. The
         target parcel fabric can be from a file, enterprise, or mobile
         geodatabase."""
    ...

@gptooldoc("ApplyParcelLeastSquaresAdjustment_parcel", None)
def ApplyParcelLeastSquaresAdjustment(
    in_parcel_fabric=..., movement_tolerance=..., update_attributes=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """ApplyParcelLeastSquaresAdjustment_parcel(in_parcel_fabric, {movement_tolerance}, {update_attributes})

       Applies the results of a least squares adjustment to parcel fabric
       feature classes. Least squares adjustment results stored in the
       AdjustmentLines and AdjustmentPoints feature classes are applied to
       the corresponding parcel line, connection line, and parcel fabric
       point feature classes.

    INPUTS:
     in_parcel_fabric (Parcel Layer):
         The parcel fabric to be updated.
     movement_tolerance {Linear Unit}:
         The tolerance representing the minimum allowable coordinate shift when
         updating parcel fabric points. If the distance between the adjustment
         point and the parcel fabric point is greater than the specified
         tolerance, the parcel fabric point is updated to the location of the
         adjustment point. The default tolerance is 0.05 meters.
     update_attributes {Boolean}:
         Specifies whether attribute fields in the parcel fabric Points feature
         class will be updated with statistical metadata. The XY Uncertainty,
         Error Ellipse Semi Major, Error Ellipse Semi Minor, and Error Ellipse
         Direction fields will be updated with the values stored in the same
         fields in the AdjustmentPoints feature class.

         * UPDATE_ATTRIBUTES-Attribute fields in the parcel fabric Points
         feature class will be updated with statistical metadata.

         * NO_UPDATE_ATTRIBUTES-Attribute fields will not be updated. This is
         the default."""
    ...

@gptooldoc("BuildParcelFabric_parcel", None)
def BuildParcelFabric(
    in_parcel_fabric=..., extent=..., record_name=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """BuildParcelFabric_parcel(in_parcel_fabric, {extent}, {record_name})

       Builds parcels in a parcel fabric. Parcels can be built from polygons
       or lines. If parcels are built from polygons, the tool creates parcel
       lines and parcel points. If parcels are built from lines, the tool
       creates the missing polygons and points. When building parcels from
       lines, parcel seeds are required.

    INPUTS:
     in_parcel_fabric (Parcel Layer):
         The parcel fabric for which to parcels will be built. The parcel
         fabric can be from a file, enterprise, or mobile geodatabase, or from
         a a feature service.
     extent {Extent}:
         The extent of the dataset to be processed. Only features that fall
         within the specified extent will be processed.

         * MAXOF-The maximum extent of all inputs will be used.

         * MINOF-The minimum area common to all inputs will be used.

         * DISPLAY-The extent is equal to the visible display.

         * Layer name-The extent of the specified layer will be used.

         * Extent object-The extent of the specified object will be used.

         * Space delimited string of coordinates-The extent of the specified
         string will be used. Coordinates are expressed in the order of x-min,
         y-min, x-max, y-max.
     record_name {String}:
         The name of the existing parcel record. Only parcels associated with
         this record will be built."""
    ...

@gptooldoc("CopyParcels_parcel", None)
def CopyParcels(
    in_parcel_fabric=..., target_database=..., out_dataset_name=..., out_fabric_name=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """CopyParcels_parcel(in_parcel_fabric, target_database, {out_dataset_name}, {out_fabric_name})

       Copies parcels from an input parcel fabric to a new parcel fabric in a
       new feature dataset.

    INPUTS:
     in_parcel_fabric (Parcel Layer):
         The input parcels that will be copied to a new parcel fabric. The
         input parcel fabric can be from a file, enterprise, or mobile
         geodatabase, or from a feature service.
     target_database (Workspace):
         The geodatabase in which the new parcel fabric will be created. The
         geodatabase can be a file, enterprise, or mobile geodatabase.
     out_dataset_name {String}:
         The name of the feature dataset that will be created for the new
         parcel fabric.
     out_fabric_name {String}:
         The name of the new parcel fabric."""
    ...

@gptooldoc("ExportSequencedParcelFeatures_parcel", None)
def ExportSequencedParcelFeatures(
    in_parcel_polygon_feature=...,
    target_feature_dataset=...,
    start_sequence_corner=...,
    points_sequence_format=...,
    lines_sequence_format=...,
    sequence_curves_separately=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """ExportSequencedParcelFeatures_parcel(in_parcel_polygon_feature, target_feature_dataset, {start_sequence_corner}, {points_sequence_format}, {lines_sequence_format}, {sequence_curves_separately})

       Exports the parcel features of a selected parcel to individual feature
       classes. The individual feature classes can be added to a map to
       create parcel layouts or title map layouts. Fields are added to the
       feature classes so that parcel features can be labeled and tabulated
       in a clockwise sequence.

    INPUTS:
     in_parcel_polygon_feature (Feature Layer):
         The parcel that will be exported to individual feature classes. Only
         one parcel polygon can be selected.
     target_feature_dataset (Feature Dataset):
         The feature dataset where the exported parcel feature classes will
         reside.
     start_sequence_corner {String}:
         Specifies the parcel corner from which the line and point sequence
         numbering will start. The sequence number is populated in the Sequence
         field on the exported lines and points feature class.

         * NE-The line or point sequence will start at the northeast parcel
         corner point. This is the default.

         * SE-The line or point sequence will start at the southeast parcel
         corner point.

         * SW-The line or point sequence will start at the southwest parcel
         corner point.

         * NW-The line or point sequence will start at the northwest parcel
         corner point.
     points_sequence_format {String}:
         The sequence numbering format that will be used for points in
         the Sequence field. Use a # character to denote the incrementing
         sequence number. Multiple # characters will add zeros before the
         sequence number. Letters can be placed on either side of the #
         character. The following are examples:

         * # is formatted as a sequence starting with 1.

         * ## is formatted as a sequence starting with 01.

         * P# is formatted as a sequence starting with P1.

         * ABC-##1 is formatted as a sequence starting with ABC-001.

         * #P is formatted as a sequence starting with 1P.
     lines_sequence_format {String}:
         The sequence numbering format that will be used for lines in
         the Sequence field. Use a # character to denote the incrementing
         sequence number. Multiple # characters will add zeros before the
         sequence number. Letters can be placed on either side of the #
         character. The following are examples:

         * # is formatted as a sequence starting with 1.

         * ## is formatted as a sequence starting with 01.

         * L# is formatted as a sequence starting with L1.

         * ABC-##1 is formatted as a sequence starting with ABC-001.

         * #L is formatted as a sequence starting with 1L.
     sequence_curves_separately {Boolean}:
         Specifies whether curves will be sequenced separately when exporting
         parcel lines.

         * SEQUENCE_SEPARATELY-The sequence numbering in the Sequence field
         will restart at 1 for the first curve encountered in the clockwise
         sequence and will increment for each additional curve found.

         * SEQUENCE_TOGETHER-The sequence numbering in the Sequence field will
         not be incremented separately for curved lines. This is the default."""
    ...

@gptooldoc("GenerateParcelFabricLinks_parcel", None)
def GenerateParcelFabricLinks(
    target_parcel_fabric=...,
    out_links_feature_class=...,
    out_anchor_points_feature_class=...,
    from_date=...,
    to_date=...,
    min_link_length=...,
    extent=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """GenerateParcelFabricLinks_parcel(target_parcel_fabric, out_links_feature_class, out_anchor_points_feature_class, from_date, {to_date}, {min_link_length}, {extent})

       Generates displacement links for parcel fabric points that have
       changed locations in a specified time period.

    INPUTS:
     target_parcel_fabric (Parcel Layer):
         The parcel fabric that will be used to generate links. The parcel
         fabric must be published as a feature service and the default version
         is used to generate links.
     from_date (Date):
         The date from which to search the parcel fabric for points that have
         changed locations. Links and anchor points will be only be generated
         for points on or after this date.
     to_date {Date}:
         The end date of the time period in which to search the parcel fabric
         for points that have changed locations. Links and anchor points will
         only be generated for points on or before this date. If no To date is
         specified, links and anchor points will be generated for all points on
         or after the specified From Date. If the To Date is specified at a
         future date, links will be generated in the time period between the
         From Date and the current date and time.
     min_link_length {Linear Unit}:
         The minimum length of the generated links. If the link length between
         the current points and their original locations is smaller than the
         specified value, anchor points are created for the original locations
         of the points.
     extent {Extent}:
         The extent of the dataset to be processed. Only features that fall
         within the specified extent will be processed.

         * MAXOF-The maximum extent of all inputs will be used.

         * MINOF-The minimum area common to all inputs will be used.

         * DISPLAY-The extent is equal to the visible display.

         * Layer name-The extent of the specified layer will be used.

         * Extent object-The extent of the specified object will be used.

         * Space delimited string of coordinates-The extent of the specified
         string will be used. Coordinates are expressed in the order of x-min,
         y-min, x-max, y-max.

    OUTPUTS:
     out_links_feature_class (Feature Class):
         The output line feature class that will store the generated links.
     out_anchor_points_feature_class (Feature Class):
         The output point feature class that will store the anchor points."""
    ...

@gptooldoc("ImportParcelFabricPoints_parcel", None)
def ImportParcelFabricPoints(
    source_points=...,
    target_parcel_fabric=...,
    match_point_method=...,
    search_distance=...,
    update_type=...,
    record_name=...,
    match_field=...,
    conflicts_table=...,
    update_create_option=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """ImportParcelFabricPoints_parcel(source_points, target_parcel_fabric, match_point_method, search_distance, update_type, {record_name}, {match_field}, {conflicts_table}, {update_create_option})

       Imports point data from a source point feature class into the parcel
       fabric points feature class. Parcel fabric points that match or lie
       within a proximity tolerance of the source points will be updated with
       the imported point data. If the source points layer has a selection,
       only the selected point information will be imported.

    INPUTS:
     source_points (Feature Layer):
         The source point feature class that will be used to create or update
         points in the target parcel fabric.
     target_parcel_fabric (Parcel Layer):
         The target parcel fabric in which points will be updated or created.
         The target parcel fabric can be from a file geodatabase, an enterprise
         geodatabase connected to the default version, a mobile geodatabase, or
         a feature service.
     match_point_method (String):
         Specifies the method that will be used to find existing parcel fabric
         points that match the source points.

         * PROXIMITY-Parcel fabric points that lie within the proximity
         tolerance of the source points will be matched to the source points
         and updated. This is the default.

         * NAME_AND_PROXIMITY-Parcel fabric points that lie within the
         proximity tolerance and have the same name as the source points will
         be matched to the source points and updated.

         * GLOBALID_AND_PROXIMITY-Parcel fabric points that lie within the
         proximity tolerance and have the same Global ID as the source points
         will be matched to the source points and updated. Global IDs are
         stored in the Global ID field of the parcel fabric points feature
         class and in a specified Global ID field of the source feature class.
     search_distance (Linear Unit):
         The distance that will be used to search for parcel fabric points that
         lie within the proximity of the source points.
     update_type (String):
         Specifies the type of update that will be applied to parcel fabric
         points that match source points.

         * ALL-The geometry (x,y,z) and matching attribute fields of parcel
         fabric points will be updated. If the geometry of parcel fabric points
         is updated, coincident parcel features will be updated as well. This
         is the default.

         * GEOMETRY_XYZ-Only the geometry (x,y,z) of the parcel fabric points
         will be updated. Coincident parcel features will be updated as well.

         * RETIRE_AND_REPLACE-Source points will be imported as new parcel
         fabric points. Any matching parcel fabric points will be retired as
         historic. The Retired By Record field of each matching parcel fabric
         point will be populated with the Global ID of the record specified in
         the Record Name parameter.
     record_name {String}:
         The name of the record that will be associated with the new imported
         points.If the record exists in the target parcel fabric, the new
         points will
         be associated with the record. If the record does not exist, a record
         will be created. If new points replace existing points, and
         update_type is RETIRE_AND_REPLACE, the record will be used to retire
         the points as historic.
     match_field {Field}:
         The field that will be used to match source points to parcel fabric
         points when NAME_AND_PROXIMITY or GLOBALID_AND_PROXIMITY is used for
         the match_point_method parameter. When searching by name, the field in
         the source point feature class should be of type Text. When searching
         by Global ID, the field in the source point feature class should be of
         type GUID.
     update_create_option {String}:
         Specifies whether points will be updated, created, or both.Existing
         points will not be updated if their IsFixed field is set to
         Yes.

         * UPDATE_AND_CREATE-Points will be created if no matching points are
         found using the search criteria. If matching points are found using
         the search criteria, they will be updated. This is the default.

         * CREATE_ONLY-Points will be created only if no matching points are
         found using the search criteria. If matching points are found using
         the search criteria, they will remain unchanged and no points will be
         created.

         * UPDATE_ONLY-Points will be updated if matching points are found
         using the search criteria. If no matching points are found, points
         will not be created.

    OUTPUTS:
     conflicts_table {Table}:
         The path and name of the output table that will store conflicts. If
         more than one parcel fabric point is found within the search tolerance
         of a source point, the Object IDs of the source points and parcel
         fabric points will be reported in the conflicts table."""
    ...

@gptooldoc("MergeCollinearParcelBoundaries_parcel", None)
def MergeCollinearParcelBoundaries(
    in_parcel_boundaries=..., offset_tolerance=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """MergeCollinearParcelBoundaries_parcel(in_parcel_boundaries, offset_tolerance)

       Merges connected collinear parcel lines into a single parcel line.
       Shared parcel fabric points between connected collinear lines are
       deleted and vertices are created in their place.

    INPUTS:
     in_parcel_boundaries (Feature Layer):
         The parcel lines to be merged. Lines can be parcel lines or connection
         lines.
     offset_tolerance (Linear Unit):
         The maximum distance shared parcel points can be offset from their
         connected lines for the lines to be considered collinear. The offset
         is the distance between the shared parcel points and the straight
         lines between the endpoints of the connected parcel lines."""
    ...

@gptooldoc("SetParcelLineLabelPosition_parcel", None)
def SetParcelLineLabelPosition(
    in_parcel_features=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """SetParcelLineLabelPosition_parcel(in_parcel_features;in_parcel_features...)

       Sets the  label position of the line's COGO dimension to the left of
       the parcel line, to the right of the parcel line, or centered over the
       parcel line.

    INPUTS:
     in_parcel_features (Feature Layer):
         The input parcel line layers with label positions that will be
         updated."""
    ...

@gptooldoc("ValidateParcelFabric_parcel", None)
def ValidateParcelFabric(
    in_parcel_fabric=..., extent=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """ValidateParcelFabric_parcel(in_parcel_fabric, {extent})

       Validates a parcel fabric using a predefined set of geodatabase
       topology rules and any other topology rules you have added for your
       organization.

    INPUTS:
     in_parcel_fabric (Parcel Layer):
         The parcel fabric to be validated. The parcel fabric can be from a
         file or mobile geodatabase or from a feature service.
     extent {Extent}:
         The extent of the dataset to be processed. Only features that fall
         within the specified extent will be processed.

         * MAXOF-The maximum extent of all inputs will be used.

         * MINOF-The minimum area common to all inputs will be used.

         * DISPLAY-The extent is equal to the visible display.

         * Layer name-The extent of the specified layer will be used.

         * Extent object-The extent of the specified object will be used.

         * Space delimited string of coordinates-The extent of the specified
         string will be used. Coordinates are expressed in the order of x-min,
         y-min, x-max, y-max."""
    ...

@gptooldoc("AddParcelType_parcel", None)
def AddParcelType(
    in_parcel_fabric=..., name=..., administrative_polygon=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """AddParcelType_parcel(in_parcel_fabric, name, {administrative_polygon})

       Adds a parcel type to a parcel fabric. A parcel type is defined by a
       separate polygon and line feature class. Parcel type feature classes
       are controlled by the parcel fabric dataset.

    INPUTS:
     in_parcel_fabric (Parcel Layer):
         The parcel fabric to which the parcel type will be added. The parcel
         fabric can be from a file, enterprise, or mobile geodatabase.
     name (String):
         The name of the parcel type. The name will be assigned to the output
         polygon and line feature classes.
     administrative_polygon {Boolean}:
         Specifies whether the parcel type will be used to store parcels with
         administrative boundaries or regular boundaries. Administrative
         boundaries are used for very large parcels such as country parcels or
         state parcels. The parcel type polygon feature class will not
         participate in the parcel fabric topology.

         * ADMINISTRATIVE_POLYGON-The parcel type will be used to store
         administrative boundaries. The parcel type polygon feature class will
         not participate in the parcel fabric topology.

         * TOPOLOGY_POLYGON-The parcel type will not be used to store
         administrative boundaries. The parcel type polygon feature class will
         participate in the parcel fabric topology. This is the default."""
    ...

@gptooldoc("CreateParcelFabric_parcel", None)
def CreateParcelFabric(
    target_dataset=..., name=..., config_keyword=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """CreateParcelFabric_parcel(target_dataset, name, {config_keyword})

       Creates a parcel fabric and its associated datasets. The parcel fabric
       is created in a feature dataset that resides in a file, enterprise, or
       mobile geodatabase.

    INPUTS:
     target_dataset (Feature Dataset):
         The feature dataset in which the parcel fabric and related schema will
         be created. The feature dataset can reside in a file, enterprise, or
         mobile geodatabase.
     name (String):
         The name of the parcel fabric that will be created. Associated
         datasets will be prefixed with the parcel fabric name.
     config_keyword {String}:
         The configuration keyword applies to enterprise geodatabase data only.
         It determines the storage parameters of the database table."""
    ...

@gptooldoc("CreateParcelRecords_parcel", None)
def CreateParcelRecords(
    in_parcel_features=...,
    record_field=...,
    record_expression=...,
    record_name_method=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """CreateParcelRecords_parcel(in_parcel_features, {record_field}, {record_expression}, {record_name_method})

       Creates parcel records for the input parcel fabric features using a
       record name field or an expression.

    INPUTS:
     in_parcel_features (Feature Layer):
         The input parcel features that will be used to create parcel records.
         The input parcel features can be from a parcel fabric in a file,
         enterprise, or mobile geodatabase.
     record_field {Field}:
         The attribute field that contains the record names. The attribute
         field must be a text field and must contain parcel record names that
         correspond to their associated parcel features.
     record_expression {Calculator Expression}:
         An Arcade expression that uses fields, string operators, and
         mathematical operators to represent the record names. For example, the
         expression Left($feature.Name,4) extracts the first four characters
         from the parcel name field in the parcel fabric polygon feature class
         to create the record names.
     record_name_method {String}:
         Specifies the method that will be used to create parcel records.

         * FIELD-Parcel records will be created using record names from a text
         field on the input parcel features. This is the default.

         * EXPRESSION-Parcel records will be created using an Arcade
         expression."""
    ...

@gptooldoc("DisableParcelTopology_parcel", None)
def DisableParcelTopology(
    in_parcel_fabric=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """DisableParcelTopology_parcel(in_parcel_fabric)

       Disables geodatabase topology on a parcel fabric. System-defined
       topology rules and parcel fabric feature classes will be removed from
       the topology.

    INPUTS:
     in_parcel_fabric (Parcel Layer):
         The parcel fabric for which the topology will be disabled. The input
         parcel fabric can be from a file, enterprise, or mobile geodatabase."""
    ...

@gptooldoc("EnableParcelTopology_parcel", None)
def EnableParcelTopology(
    in_parcel_fabric=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """EnableParcelTopology_parcel(in_parcel_fabric)

       Enables geodatabase topology on a parcel fabric.

    INPUTS:
     in_parcel_fabric (Parcel Layer):
         The parcel fabric for which the geodatabase topology will be enabled.
         The input parcel fabric can be from a file, enterprise, or mobile
         geodatabase."""
    ...

@gptooldoc("RemoveParcelType_parcel", None)
def RemoveParcelType(
    in_parcel_fabric=..., name=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """RemoveParcelType_parcel(in_parcel_fabric, name)

       Removes a parcel type from a parcel fabric.

    INPUTS:
     in_parcel_fabric (Parcel Layer):
         The parcel fabric from which the parcel type will be removed. The
         parcel fabric can be from a file, enterprise, or mobile geodatabase.
     name (String):
         The name of the parcel type."""
    ...

@gptooldoc("UpgradeArcMapParcelFabric_parcel", None)
def UpgradeArcMapParcelFabric(
    in_parcel_fabric=..., target_dataset=..., name=..., delete_identical=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """UpgradeArcMapParcelFabric_parcel(in_parcel_fabric, target_dataset, name, {delete_identical})

       Upgrades an ArcMap parcel fabric to an ArcGIS Pro parcel fabric.

    INPUTS:
     in_parcel_fabric (Parcel Fabric Layer for ArcMap):
         The ArcMap parcel fabric that will be upgraded to an ArcGIS Pro parcel
         fabric.
     target_dataset (Feature Dataset):
         The feature dataset that will contain the upgraded ArcGIS Pro parcel
         fabric.
     name (String):
         The name of the upgraded ArcGIS Pro parcel fabric.
     delete_identical {Boolean}:
         Specifies whether identical overlapping lines will be deleted.
         When DELETE_IDENTICAL_ LINES is used, overlapping lines will be
         deleted if the line shapes are identical (lines are coincident) and
         they have the following matching attributes:

         * Directions in the Direction field. This includes directions that are
         reversed by 180 degrees.

         * Distances in the Distance field. Distances are rounded to four
         decimal places.

         * Records in the Created By Record field.

         * Records in the Retired By Record field.

         * DELETE_IDENTICAL_LINES-Identical overlapping lines will be deleted.

         * KEEP_IDENTICAL_LINES-Identical overlapping lines will not be
         deleted. This is the default."""
    ...
