"""
This type stub file was generated by pyright.
"""

from arcpy.geoprocessing._base import gptooldoc

r"""The Utility Network toolbox contains tools to create, configure, and
work with utility networks."""
__all__ = [
    "AddAngleDirectedLayout",
    "AddCollapseContainerByAttributeRule",
    "AddCollapseContainerRule",
    "AddCompressionLayout",
    "AddConnectivityAssociationsRule",
    "AddDiagramFeatureCapabilityByAttributeRule",
    "AddDiagramTemplate",
    "AddDomainNetwork",
    "AddExpandContainerByAttributeRule",
    "AddExpandContainerRule",
    "AddForceDirectedLayout",
    "AddGridLayout",
    "AddLinearDispatchLayout",
    "AddMainRingLayout",
    "AddMainlineTreeLayout",
    "AddNetworkAttribute",
    "AddNetworkCategory",
    "AddPartialOverlappingEdgesLayout",
    "AddRadialTreeLayout",
    "AddReduceEdgeByAttributeRule",
    "AddReduceJunctionByAttributeRule",
    "AddReduceJunctionRule",
    "AddRelativeMainlineLayout",
    "AddRemoveFeatureByAttributeRule",
    "AddRemoveFeatureRule",
    "AddReshapeDiagramEdgesLayout",
    "AddRule",
    "AddSetRootJunctionByAttributeRule",
    "AddSetStartingPointByAttributeRule",
    "AddSmartTreeLayout",
    "AddSpatialDispatchLayout",
    "AddSpatialQueryRule",
    "AddStartIterationRule",
    "AddStopIterationRule",
    "AddStructuralAttachmentsRule",
    "AddTerminalConfiguration",
    "AddTier",
    "AddTierGroup",
    "AddTraceConfiguration",
    "AddTraceLocations",
    "AddTraceRule",
    "AlterDiagramProperties",
    "AlterDiagramTemplate",
    "AppendToDiagram",
    "ApplyAngleDirectedLayout",
    "ApplyCompressionLayout",
    "ApplyForceDirectedLayout",
    "ApplyGeoPositionsLayout",
    "ApplyGridLayout",
    "ApplyLinearDispatchLayout",
    "ApplyMainRingLayout",
    "ApplyMainlineTreeLayout",
    "ApplyPartialOverlappingEdgesLayout",
    "ApplyRadialTreeLayout",
    "ApplyRelativeMainlineLayout",
    "ApplyRotateTreeLayout",
    "ApplySmartTreeLayout",
    "ApplySpatialDispatchLayout",
    "ApplyTemplateLayouts",
    "ChangeDiagramsOwner",
    "CreateDiagram",
    "CreateDiagramLayerDefinition",
    "CreateUtilityNetwork",
    "DeleteDiagram",
    "DeleteDiagramTemplate",
    "DeleteNetworkCategory",
    "DeleteRule",
    "DeleteTerminalConfiguration",
    "DeleteTraceConfiguration",
    "DisableNetworkTopology",
    "EnableNetworkTopology",
    "ExportAssociations",
    "ExportDiagramContent",
    "ExportDiagramLayerDefinition",
    "ExportDiagramTemplateDefinitions",
    "ExportRules",
    "ExportSubnetwork",
    "ExportSubnetworkControllers",
    "ExportTraceConfigurations",
    "ExtendDiagram",
    "GetDiagramTemplateNames",
    "ImportAssociations",
    "ImportDiagramTemplateDefinitions",
    "ImportRules",
    "ImportSubnetworkControllers",
    "ImportTraceConfigurations",
    "MakeDiagramLayer",
    "OverwriteDiagram",
    "PurgeTemporaryDiagrams",
    "RepairNetworkTopology",
    "ReshapeDiagramEdgesLayout",
    "SetAssociationRole",
    "SetEdgeConnectivity",
    "SetNetworkAttribute",
    "SetNetworkCategory",
    "SetSubnetworkDefinition",
    "SetTerminalConfiguration",
    "StoreDiagram",
    "Trace",
    "UpdateDiagram",
    "UpdateIsConnected",
    "UpdateSubnetwork",
    "UpdateUtilityNetworkSchema",
    "ValidateNetworkTopology",
    "VerifyNetworkTopology",
]
__alias__ = ...

@gptooldoc("AddAngleDirectedLayout_un", None)
def AddAngleDirectedLayout(
    in_utility_network=...,
    template_name=...,
    is_active=...,
    are_containers_preserved=...,
    iterations_number=...,
    number_of_directions=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """AddAngleDirectedLayout_un(in_utility_network, template_name, is_active, {are_containers_preserved}, {iterations_number}, {number_of_directions})

       Add the angle directed layout to a diagram template

    INPUTS:
     in_utility_network (Utility Network / Trace Network):
         Input Network
     template_name (String):
         Input Diagram Template
     is_active (Boolean):
         Active
     are_containers_preserved {Boolean}:
         Preserve container layout
     iterations_number {Long}:
         Number of Iterations
     number_of_directions {String}:
         Number of Directions"""
    ...

@gptooldoc("AddCollapseContainerByAttributeRule_un", None)
def AddCollapseContainerByAttributeRule(
    in_utility_network=...,
    template_name=...,
    is_active=...,
    container_source=...,
    where_clause=...,
    description=...,
    reconnected_edges_option=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """AddCollapseContainerByAttributeRule_un(in_utility_network, template_name, is_active, container_source, {where_clause}, {description}, {reconnected_edges_option})

       Add a collapse container by attribute rule to a diagram template

    INPUTS:
     in_utility_network (Utility Network / Trace Network):
         Input Network
     template_name (String):
         Input Diagram Template
     is_active (Boolean):
         Active
     container_source (Table / Feature Class):
         Container Source
     where_clause {SQL Expression}:
         Expression
     description {String}:
         Description
     reconnected_edges_option {Boolean}:
         Aggregate reconnected edges"""
    ...

@gptooldoc("AddCollapseContainerRule_un", None)
def AddCollapseContainerRule(
    in_utility_network=...,
    template_name=...,
    is_active=...,
    container_type=...,
    inverse_source_selection=...,
    container_sources=...,
    description=...,
    reconnected_edges_option=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """AddCollapseContainerRule_un(in_utility_network, template_name, is_active, container_type, inverse_source_selection, {container_sources;container_sources...}, {description}, {reconnected_edges_option})

       Add a collapse container rule to a diagram template

    INPUTS:
     in_utility_network (Utility Network / Trace Network):
         Input Network
     template_name (String):
         Input Diagram Template
     is_active (Boolean):
         Active
     container_type (String):
         Container Type
     inverse_source_selection (String):
         Rule Process
     container_sources {Table / Feature Class}:
         Container Sources
     description {String}:
         Description
     reconnected_edges_option {Boolean}:
         Aggregate reconnected edges"""
    ...

@gptooldoc("AddCompressionLayout_un", None)
def AddCompressionLayout(
    in_utility_network=...,
    template_name=...,
    is_active=...,
    are_containers_preserved=...,
    grouping_distance_absolute=...,
    vertices_removal_rule=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """AddCompressionLayout_un(in_utility_network, template_name, is_active, {are_containers_preserved}, {grouping_distance_absolute}, {vertices_removal_rule})

       Add a compression layout to a diagram template

    INPUTS:
     in_utility_network (Utility Network / Trace Network):
         Input Network
     template_name (String):
         Input Diagram Template
     is_active (Boolean):
         Active
     are_containers_preserved {Boolean}:
         Preserve container layout
     grouping_distance_absolute {Linear Unit}:
         Maximum Distance for Grouping
     vertices_removal_rule {String}:
         Vertex Removal Rule"""
    ...

@gptooldoc("AddConnectivityAssociationsRule_un", None)
def AddConnectivityAssociationsRule(
    in_utility_network=..., template_name=..., is_active=..., description=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """AddConnectivityAssociationsRule_un(in_utility_network, template_name, is_active, {description})

       Add a connectivity associations rule to a diagram template

    INPUTS:
     in_utility_network (Utility Network / Trace Network):
         Input Network
     template_name (String):
         Input Diagram Template
     is_active (Boolean):
         Active
     description {String}:
         Description"""
    ...

@gptooldoc("AddDiagramFeatureCapabilityByAttributeRule_un", None)
def AddDiagramFeatureCapabilityByAttributeRule(
    in_utility_network=...,
    template_name=...,
    is_active=...,
    network_source=...,
    where_clause=...,
    capability=...,
    description=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """AddDiagramFeatureCapabilityByAttributeRule_un(in_utility_network, template_name, is_active, network_source, where_clause, capability, {description})

       Add a diagram feature capability by attribute rule to a diagram
       template

    INPUTS:
     in_utility_network (Utility Network / Trace Network):
         Input Network
     template_name (String):
         Input Diagram Template
     is_active (Boolean):
         Active
     network_source (Table / Feature Class):
         Network Source
     where_clause (SQL Expression):
         Expression
     capability (String):
         Capability
     description {String}:
         Description"""
    ...

@gptooldoc("AddDiagramTemplate_un", None)
def AddDiagramTemplate(
    in_utility_network=..., template_name=..., ndbd_file=..., ndld_file=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """AddDiagramTemplate_un(in_utility_network, template_name, {ndbd_file}, {ndld_file})

       Add a diagram template

    INPUTS:
     in_utility_network (Utility Network / Trace Network):
         Input Network
     template_name (String):
         Input Diagram Template
     ndbd_file {File}:
         Rule and Layout Definitions File
     ndld_file {File}:
         Diagram Layer Definition File"""
    ...

@gptooldoc("AddExpandContainerByAttributeRule_un", None)
def AddExpandContainerByAttributeRule(
    in_utility_network=...,
    template_name=...,
    is_active=...,
    containers_visibility=...,
    container_source=...,
    where_clause=...,
    description=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """AddExpandContainerByAttributeRule_un(in_utility_network, template_name, is_active, containers_visibility, container_source, {where_clause}, {description})

       Add an expand container by attribute rule to a diagram template

    INPUTS:
     in_utility_network (Utility Network / Trace Network):
         Input Network
     template_name (String):
         Input Diagram Template
     is_active (Boolean):
         Active
     containers_visibility (Boolean):
         Keep containers visible
     container_source (Table / Feature Class):
         Container Source
     where_clause {SQL Expression}:
         Expression
     description {String}:
         Description"""
    ...

@gptooldoc("AddExpandContainerRule_un", None)
def AddExpandContainerRule(
    in_utility_network=...,
    template_name=...,
    is_active=...,
    containers_visibility=...,
    container_type=...,
    inverse_source_selection=...,
    container_sources=...,
    description=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """AddExpandContainerRule_un(in_utility_network, template_name, is_active, containers_visibility, container_type, inverse_source_selection, {container_sources;container_sources...}, {description})

       Add an expand container rule to a diagram template

    INPUTS:
     in_utility_network (Utility Network / Trace Network):
         Input Network
     template_name (String):
         Input Diagram Template
     is_active (Boolean):
         Active
     containers_visibility (Boolean):
         Keep containers visible
     container_type (String):
         Container Type
     inverse_source_selection (String):
         Rule Process
     container_sources {Table / Feature Class}:
         Container Sources
     description {String}:
         Description"""
    ...

@gptooldoc("AddForceDirectedLayout_un", None)
def AddForceDirectedLayout(
    in_utility_network=...,
    template_name=...,
    is_active=...,
    are_containers_preserved=...,
    iterations_number=...,
    repel_factor=...,
    degree_freedom=...,
    breakpoint_position=...,
    edge_display_type=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """AddForceDirectedLayout_un(in_utility_network, template_name, is_active, {are_containers_preserved}, {iterations_number}, {repel_factor}, {degree_freedom}, {breakpoint_position}, {edge_display_type})

       Add a force directed layout to a diagram template

    INPUTS:
     in_utility_network (Utility Network / Trace Network):
         Input Network
     template_name (String):
         Input Diagram Template
     is_active (Boolean):
         Active
     are_containers_preserved {Boolean}:
         Preserve container layout
     iterations_number {Long}:
         Number of Iterations
     repel_factor {Double}:
         Repel Factor
     degree_freedom {String}:
         Degree of Freedom
     breakpoint_position {Double}:
         Break Point Relative Position (%)
     edge_display_type {String}:
         Edge Display Type"""
    ...

@gptooldoc("AddGridLayout_un", None)
def AddGridLayout(
    in_utility_network=...,
    template_name=...,
    is_active=...,
    are_containers_preserved=...,
    cell_width_absolute=...,
    cell_height_absolute=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """AddGridLayout_un(in_utility_network, template_name, is_active, {are_containers_preserved}, {cell_width_absolute}, {cell_height_absolute})

       Add a grid layout to a diagram template

    INPUTS:
     in_utility_network (Utility Network / Trace Network):
         Input Network
     template_name (String):
         Input Diagram Template
     is_active (Boolean):
         Active
     are_containers_preserved {Boolean}:
         Preserve container layout
     cell_width_absolute {Linear Unit}:
         Cell Width
     cell_height_absolute {Linear Unit}:
         Cell Height"""
    ...

@gptooldoc("AddLinearDispatchLayout_un", None)
def AddLinearDispatchLayout(
    in_utility_network=...,
    template_name=...,
    is_active=...,
    junction_placement_type=...,
    is_unit_absolute=...,
    maximum_shift_absolute=...,
    maximum_shift_proportional=...,
    minimum_shift_absolute=...,
    minimum_shift_proportional=...,
    iterations_number=...,
    is_path_preserved=...,
    are_leaves_moved=...,
    are_leaves_expanded=...,
    expand_shift_absolute=...,
    expand_shift_proportional=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """AddLinearDispatchLayout_un(in_utility_network, template_name, is_active, {junction_placement_type}, {is_unit_absolute}, {maximum_shift_absolute}, {maximum_shift_proportional}, {minimum_shift_absolute}, {minimum_shift_proportional}, {iterations_number}, {is_path_preserved}, {are_leaves_moved}, {are_leaves_expanded}, {expand_shift_absolute}, {expand_shift_proportional})

       Add a linear dispatch layout to a diagram template

    INPUTS:
     in_utility_network (Utility Network / Trace Network):
         Input Network
     template_name (String):
         Input Diagram Template
     is_active (Boolean):
         Active
     junction_placement_type {String}:
         Junctions Placement
     is_unit_absolute {Boolean}:
         Spacing values interpreted as absolute units in the diagram coordinate system
     maximum_shift_absolute {Linear Unit}:
         Maximum Shift
     maximum_shift_proportional {Double}:
         Maximum Shift
     minimum_shift_absolute {Linear Unit}:
         Minimum Shift
     minimum_shift_proportional {Double}:
         Minimum Shift
     iterations_number {Long}:
         Number of Iterations
     is_path_preserved {Boolean}:
         Preserve path
     are_leaves_moved {Boolean}:
         Move leaves
     are_leaves_expanded {Boolean}:
         Expand leaves
     expand_shift_absolute {Linear Unit}:
         Maximum Expand Shift
     expand_shift_proportional {Double}:
         Maximum Expand Shift"""
    ...

@gptooldoc("AddMainRingLayout_un", None)
def AddMainRingLayout(
    in_utility_network=...,
    template_name=...,
    is_active=...,
    are_containers_preserved=...,
    ring_type=...,
    is_unit_absolute=...,
    ring_width_absolute=...,
    ring_width_proportional=...,
    ring_height_absolute=...,
    ring_height_proportional=...,
    tree_type=...,
    perpendicular_absolute=...,
    perpendicular_proportional=...,
    along_absolute=...,
    along_proportional=...,
    breakpoint_position=...,
    edge_display_type=...,
    offset_absolute=...,
    offset_proportional=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """AddMainRingLayout_un(in_utility_network, template_name, is_active, {are_containers_preserved}, {ring_type}, {is_unit_absolute}, {ring_width_absolute}, {ring_width_proportional}, {ring_height_absolute}, {ring_height_proportional}, {tree_type}, {perpendicular_absolute}, {perpendicular_proportional}, {along_absolute}, {along_proportional}, {breakpoint_position}, {edge_display_type}, {offset_absolute}, {offset_proportional})

       Add a main ring layout to a diagram template

    INPUTS:
     in_utility_network (Utility Network / Trace Network):
         Input Network
     template_name (String):
         Input Diagram Template
     is_active (Boolean):
         Active
     are_containers_preserved {Boolean}:
         Preserve container layout
     ring_type {String}:
         Ring Type
     is_unit_absolute {Boolean}:
         Spacing values interpreted as absolute units in the diagram coordinate system
     ring_width_absolute {Linear Unit}:
         Ring Width
     ring_width_proportional {Double}:
         Ring Width
     ring_height_absolute {Linear Unit}:
         Ring Height
     ring_height_proportional {Double}:
         Ring Height
     tree_type {String}:
         Hierarchical Tree Type
     perpendicular_absolute {Linear Unit}:
         Between Junctions Perpendicular to the Direction
     perpendicular_proportional {Double}:
         Between Junctions Perpendicular to the Direction
     along_absolute {Linear Unit}:
         Between Junctions Along the Direction
     along_proportional {Double}:
         Between Junctions Along the Direction
     breakpoint_position {Double}:
         Break Point Relative Position (%)
     edge_display_type {String}:
         Edge Display Type
     offset_absolute {Linear Unit}:
         Offset
     offset_proportional {Double}:
         Offset"""
    ...

@gptooldoc("AddMainlineTreeLayout_un", None)
def AddMainlineTreeLayout(
    in_utility_network=...,
    template_name=...,
    is_active=...,
    are_containers_preserved=...,
    tree_direction=...,
    branches_placement=...,
    is_unit_absolute=...,
    perpendicular_absolute=...,
    perpendicular_proportional=...,
    along_absolute=...,
    along_proportional=...,
    disjoined_graph_absolute=...,
    disjoined_graph_proportional=...,
    are_edges_orthogonal=...,
    breakpoint_position=...,
    edge_display_type=...,
    offset_absolute=...,
    offset_proportional=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """AddMainlineTreeLayout_un(in_utility_network, template_name, is_active, {are_containers_preserved}, {tree_direction}, {branches_placement}, {is_unit_absolute}, {perpendicular_absolute}, {perpendicular_proportional}, {along_absolute}, {along_proportional}, {disjoined_graph_absolute}, {disjoined_graph_proportional}, {are_edges_orthogonal}, {breakpoint_position}, {edge_display_type}, {offset_absolute}, {offset_proportional})

       Add a mainline tree layout to a diagram template

    INPUTS:
     in_utility_network (Utility Network / Trace Network):
         Input Network
     template_name (String):
         Input Diagram Template
     is_active (Boolean):
         Active
     are_containers_preserved {Boolean}:
         Preserve container layout
     tree_direction {String}:
         Tree Direction
     branches_placement {String}:
         Branches Placement
     is_unit_absolute {Boolean}:
         Spacing values interpreted as absolute units in the diagram coordinate system
     perpendicular_absolute {Linear Unit}:
         Between Junctions Perpendicular to the Direction
     perpendicular_proportional {Double}:
         Between Junctions Perpendicular to the Direction
     along_absolute {Linear Unit}:
         Between Junctions Along the Direction
     along_proportional {Double}:
         Between Junctions Along the Direction
     disjoined_graph_absolute {Linear Unit}:
         Between Disjoined Graphs
     disjoined_graph_proportional {Double}:
         Between Disjoined Graphs
     are_edges_orthogonal {Boolean}:
         Orthogonally display edges
     breakpoint_position {Double}:
         Break Point Relative Position (%)
     edge_display_type {String}:
         Edge Display Type
     offset_absolute {Linear Unit}:
         Offset
     offset_proportional {Double}:
         Offset"""
    ...

@gptooldoc("AddPartialOverlappingEdgesLayout_un", None)
def AddPartialOverlappingEdgesLayout(
    in_utility_network=...,
    template_name=...,
    is_active=...,
    buffer_width_absolute=...,
    offset_absolute=...,
    optimize_edges=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """AddPartialOverlappingEdgesLayout_un(in_utility_network, template_name, is_active, buffer_width_absolute, offset_absolute, {optimize_edges})

       Add a partial overlapping edges layout to a diagram template

    INPUTS:
     in_utility_network (Utility Network / Trace Network):
         Input Network
     template_name (String):
         Input Diagram Template
     is_active (Boolean):
         Active
     buffer_width_absolute (Linear Unit):
         Buffer Width
     offset_absolute (Linear Unit):
         Offset
     optimize_edges {Boolean}:
         Optimize edges"""
    ...

@gptooldoc("AddRadialTreeLayout_un", None)
def AddRadialTreeLayout(
    in_utility_network=...,
    template_name=...,
    is_active=...,
    are_containers_preserved=...,
    is_unit_absolute=...,
    initial_radius_absolute=...,
    initial_radius_proportional=...,
    disjoined_graph_absolute=...,
    disjoined_graph_proportional=...,
    radius_factor=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """AddRadialTreeLayout_un(in_utility_network, template_name, is_active, {are_containers_preserved}, {is_unit_absolute}, {initial_radius_absolute}, {initial_radius_proportional}, {disjoined_graph_absolute}, {disjoined_graph_proportional}, {radius_factor})

       Add a radial tree layout to a diagram template

    INPUTS:
     in_utility_network (Utility Network / Trace Network):
         Input Network
     template_name (String):
         Input Diagram Template
     is_active (Boolean):
         Active
     are_containers_preserved {Boolean}:
         Preserve container layout
     is_unit_absolute {Boolean}:
         Spacing values interpreted as absolute units in the diagram coordinate system
     initial_radius_absolute {Linear Unit}:
         Initial Radius
     initial_radius_proportional {Double}:
         Initial Radius
     disjoined_graph_absolute {Linear Unit}:
         Between Disjoined Graphs
     disjoined_graph_proportional {Double}:
         Between Disjoined Graphs
     radius_factor {Double}:
         Radius Factor"""
    ...

@gptooldoc("AddReduceEdgeByAttributeRule_un", None)
def AddReduceEdgeByAttributeRule(
    in_utility_network=...,
    template_name=...,
    is_active=...,
    network_source=...,
    where_clause=...,
    description=...,
    reconnected_edges_option=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """AddReduceEdgeByAttributeRule_un(in_utility_network, template_name, is_active, network_source, {where_clause}, {description}, {reconnected_edges_option})

       Add a reduce edge by attribute rule to a diagram template

    INPUTS:
     in_utility_network (Utility Network / Trace Network):
         Input Network
     template_name (String):
         Input Diagram Template
     is_active (Boolean):
         Active
     network_source (Table / Feature Class):
         Edge Source to Reduce
     where_clause {SQL Expression}:
         Expression
     description {String}:
         Description
     reconnected_edges_option {Boolean}:
         Aggregate reconnected edges"""
    ...

@gptooldoc("AddReduceJunctionByAttributeRule_un", None)
def AddReduceJunctionByAttributeRule(
    in_utility_network=...,
    template_name=...,
    is_active=...,
    junction_source=...,
    where_clause=...,
    connectivity_options=...,
    unconnected_junctions=...,
    one_connected_junction=...,
    two_connected_junctions=...,
    edges_attributes=...,
    description=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """AddReduceJunctionByAttributeRule_un(in_utility_network, template_name, is_active, junction_source, {where_clause}, {connectivity_options}, {unconnected_junctions}, {one_connected_junction}, {two_connected_junctions}, {edges_attributes;edges_attributes...}, {description})

       Add a reduce junction by attribute rule to a diagram template

    INPUTS:
     in_utility_network (Utility Network / Trace Network):
         Input Network
     template_name (String):
         Input Diagram Template
     is_active (Boolean):
         Active
     junction_source (Table / Feature Class):
         Junction Source to Reduce
     where_clause {SQL Expression}:
         Expression
     connectivity_options {String}:
         Reduce Junctions With
     unconnected_junctions {Boolean}:
         Reduce if unconnected
     one_connected_junction {Boolean}:
         Reduce if connected to a single junction
     two_connected_junctions {Boolean}:
         Reduce if connected to 2 different junctions
     edges_attributes {String}:
         Edge Attribute Names
     description {String}:
         Description"""
    ...

@gptooldoc("AddReduceJunctionRule_un", None)
def AddReduceJunctionRule(
    in_utility_network=...,
    template_name=...,
    is_active=...,
    inverse_source_selection=...,
    junction_source=...,
    connectivity_options=...,
    unconnected_junctions=...,
    one_connected_junction=...,
    two_connected_junctions=...,
    edges_attributes=...,
    description=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """AddReduceJunctionRule_un(in_utility_network, template_name, is_active, inverse_source_selection, {junction_source;junction_source...}, {connectivity_options}, {unconnected_junctions}, {one_connected_junction}, {two_connected_junctions}, {edges_attributes;edges_attributes...}, {description})

       Add a reduce junction rule to a diagram template

    INPUTS:
     in_utility_network (Utility Network / Trace Network):
         Input Network
     template_name (String):
         Input Diagram Template
     is_active (Boolean):
         Active
     inverse_source_selection (String):
         Rule Process
     junction_source {Table / Feature Class}:
         Junction Sources
     connectivity_options {String}:
         Reduce Junctions With
     unconnected_junctions {Boolean}:
         Reduce if unconnected
     one_connected_junction {Boolean}:
         Reduce if connected to a single junction
     two_connected_junctions {Boolean}:
         Reduce if connected to 2 different junctions
     edges_attributes {String}:
         Edge Attribute Names
     description {String}:
         Description"""
    ...

@gptooldoc("AddRelativeMainlineLayout_un", None)
def AddRelativeMainlineLayout(
    in_utility_network=...,
    template_name=...,
    is_active=...,
    line_attribute=...,
    mainline_direction=...,
    offset_between_branches=...,
    breakpoint_angle=...,
    type_attribute=...,
    mainline_values=...,
    branch_values=...,
    excluded_values=...,
    is_compressing=...,
    compression_ratio=...,
    minimal_distance=...,
    alignment_attribute=...,
    initial_distances=...,
    length_attribute=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """AddRelativeMainlineLayout_un(in_utility_network, template_name, is_active, line_attribute, {mainline_direction}, {offset_between_branches}, {breakpoint_angle}, {type_attribute}, {mainline_values;mainline_values...}, {branch_values;branch_values...}, {excluded_values;excluded_values...}, {is_compressing}, {compression_ratio}, {minimal_distance}, {alignment_attribute}, {initial_distances}, {length_attribute})

       Add the relative mainline layout to a diagram template

    INPUTS:
     in_utility_network (Utility Network / Trace Network):
         Input Network
     template_name (String):
         Input Diagram Template
     is_active (Boolean):
         Active
     line_attribute (String):
         Line Attribute
     mainline_direction {String}:
         Direction
     offset_between_branches {Linear Unit}:
         Offset Between Branches
     breakpoint_angle {Double}:
         Break Point angle (in degree)
     type_attribute {String}:
         Type Attribute
     mainline_values {Value Table}:
         Mainline Values
     branch_values {Value Table}:
         Branch Values
     excluded_values {Value Table}:
         Excluded Values
     is_compressing {Boolean}:
         Compression along the direction
     compression_ratio {Double}:
         Ratio (%)
     minimal_distance {Linear Unit}:
         Minimal Distance
     alignment_attribute {String}:
         Alignment Attribute
     initial_distances {String}:
         Initial Distances
     length_attribute {String}:
         Length Attribute"""
    ...

@gptooldoc("AddRemoveFeatureByAttributeRule_un", None)
def AddRemoveFeatureByAttributeRule(
    in_utility_network=...,
    template_name=...,
    is_active=...,
    network_source=...,
    where_clause=...,
    description=...,
    unconnected_junctions=...,
    one_connected_junction=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """AddRemoveFeatureByAttributeRule_un(in_utility_network, template_name, is_active, network_source, {where_clause}, {description}, {unconnected_junctions}, {one_connected_junction})

       Add a remove feature by attribute rule to a diagram template

    INPUTS:
     in_utility_network (Utility Network / Trace Network):
         Input Network
     template_name (String):
         Input Diagram Template
     is_active (Boolean):
         Active
     network_source (Table / Feature Class):
         Network Source to Remove
     where_clause {SQL Expression}:
         Expression
     description {String}:
         Description
     unconnected_junctions {Boolean}:
         Junctions must be unconnected
     one_connected_junction {Boolean}:
         Junctions must be connected to a single junction"""
    ...

@gptooldoc("AddRemoveFeatureRule_un", None)
def AddRemoveFeatureRule(
    in_utility_network=...,
    template_name=...,
    is_active=...,
    source_type=...,
    inverse_source_selection=...,
    network_source=...,
    description=...,
    unconnected_junctions=...,
    one_connected_junction=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """AddRemoveFeatureRule_un(in_utility_network, template_name, is_active, source_type, inverse_source_selection, network_source;network_source..., {description}, {unconnected_junctions}, {one_connected_junction})

       Add a remove feature rule to a diagram template

    INPUTS:
     in_utility_network (Utility Network / Trace Network):
         Input Network
     template_name (String):
         Input Diagram Template
     is_active (Boolean):
         Active
     source_type (String):
         Source Type
     inverse_source_selection (String):
         Rule Process
     network_source (Table / Feature Class):
         Network Sources
     description {String}:
         Description
     unconnected_junctions {Boolean}:
         Junctions must be unconnected
     one_connected_junction {Boolean}:
         Junctions must be connected to a single junction"""
    ...

@gptooldoc("AddReshapeDiagramEdgesLayout_un", None)
def AddReshapeDiagramEdgesLayout(
    in_utility_network=...,
    template_name=...,
    is_active=...,
    are_containers_preserved=...,
    reshape_type=...,
    is_path_preserved=...,
    offset_between_segment_absolute=...,
    breakpoint_absolute=...,
    shift_between_edge_absolute=...,
    angle_threshold=...,
    circular_arc_radius=...,
    circular_arc_position=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """AddReshapeDiagramEdgesLayout_un(in_utility_network, template_name, is_active, {are_containers_preserved}, {reshape_type}, {is_path_preserved}, {offset_between_segment_absolute}, {breakpoint_absolute}, {shift_between_edge_absolute}, {angle_threshold}, {circular_arc_radius}, {circular_arc_position})

       Add a reshape diagram edges layout to a diagram template

    INPUTS:
     in_utility_network (Utility Network / Trace Network):
         Input Network
     template_name (String):
         Input Diagram Template
     is_active (Boolean):
         Active
     are_containers_preserved {Boolean}:
         Preserve container layout
     reshape_type {String}:
         Reshape Operation
     is_path_preserved {Boolean}:
         Preserve path
     offset_between_segment_absolute {Linear Unit}:
         Offset Between Edges
     breakpoint_absolute {Linear Unit}:
         Break Point Position
     shift_between_edge_absolute {Linear Unit}:
         Offset Between Edges
     angle_threshold {Double}:
         Angle Threshold
     circular_arc_radius {Linear Unit}:
         Circular Arc Radius
     circular_arc_position {String}:
         Circular Arc Position"""
    ...

@gptooldoc("AddSetRootJunctionByAttributeRule_un", None)
def AddSetRootJunctionByAttributeRule(
    in_utility_network=...,
    template_name=...,
    is_active=...,
    junction_source=...,
    where_clause=...,
    description=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """AddSetRootJunctionByAttributeRule_un(in_utility_network, template_name, is_active, junction_source, {where_clause}, {description})

       Add a set root junction by attribute rule to a diagram template

    INPUTS:
     in_utility_network (Utility Network / Trace Network):
         Input Network
     template_name (String):
         Input Diagram Template
     is_active (Boolean):
         Active
     junction_source (Table / Feature Class):
         Junction Source to Select
     where_clause {SQL Expression}:
         Expression
     description {String}:
         Description"""
    ...

@gptooldoc("AddSetStartingPointByAttributeRule_un", None)
def AddSetStartingPointByAttributeRule(
    in_utility_network=...,
    template_name=...,
    is_active=...,
    network_source=...,
    where_clause=...,
    junction_terminals=...,
    description=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """AddSetStartingPointByAttributeRule_un(in_utility_network, template_name, is_active, network_source, {where_clause}, {junction_terminals;junction_terminals...}, {description})

       Add a set starting point by attribute rule to a diagram template

    INPUTS:
     in_utility_network (Utility Network / Trace Network):
         Input Network
     template_name (String):
         Input Diagram Template
     is_active (Boolean):
         Active
     network_source (Table / Feature Class):
         Network Source
     where_clause {SQL Expression}:
         Expression
     junction_terminals {Long}:
         Junction Terminal(s)
     description {String}:
         Description"""
    ...

@gptooldoc("AddSmartTreeLayout_un", None)
def AddSmartTreeLayout(
    in_utility_network=...,
    template_name=...,
    is_active=...,
    are_containers_preserved=...,
    tree_direction=...,
    is_unit_absolute=...,
    subtree_absolute=...,
    subtree_proportional=...,
    perpendicular_absolute=...,
    perpendicular_proportional=...,
    along_absolute=...,
    along_proportional=...,
    disjoined_graph_absolute=...,
    disjoined_graph_proportional=...,
    are_edges_orthogonal=...,
    breakpoint_position=...,
    edge_display_type=...,
    offset_absolute=...,
    offset_proportional=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """AddSmartTreeLayout_un(in_utility_network, template_name, is_active, {are_containers_preserved}, {tree_direction}, {is_unit_absolute}, {subtree_absolute}, {subtree_proportional}, {perpendicular_absolute}, {perpendicular_proportional}, {along_absolute}, {along_proportional}, {disjoined_graph_absolute}, {disjoined_graph_proportional}, {are_edges_orthogonal}, {breakpoint_position}, {edge_display_type}, {offset_absolute}, {offset_proportional})

       Add a smart tree layout to a diagram template

    INPUTS:
     in_utility_network (Utility Network / Trace Network):
         Input Network
     template_name (String):
         Input Diagram Template
     is_active (Boolean):
         Active
     are_containers_preserved {Boolean}:
         Preserve container layout
     tree_direction {String}:
         Tree Direction
     is_unit_absolute {Boolean}:
         Spacing values interpreted as absolute units in the diagram coordinate system
     subtree_absolute {Linear Unit}:
         Between Subtrees
     subtree_proportional {Double}:
         Between Subtrees
     perpendicular_absolute {Linear Unit}:
         Between Junctions Perpendicular to the Direction
     perpendicular_proportional {Double}:
         Between Junctions Perpendicular to the Direction
     along_absolute {Linear Unit}:
         Between Junctions Along the Direction
     along_proportional {Double}:
         Between Junctions Along the Direction
     disjoined_graph_absolute {Linear Unit}:
         Between Disjoined Graphs
     disjoined_graph_proportional {Double}:
         Between Disjoined Graphs
     are_edges_orthogonal {Boolean}:
         Orthogonally display edges
     breakpoint_position {Double}:
         Break Point Relative Position (%)
     edge_display_type {String}:
         Edge Display Type
     offset_absolute {Linear Unit}:
         Offset
     offset_proportional {Double}:
         Offset"""
    ...

@gptooldoc("AddSpatialDispatchLayout_un", None)
def AddSpatialDispatchLayout(
    in_utility_network=...,
    template_name=...,
    is_active=...,
    are_containers_preserved=...,
    iterations_number=...,
    maximum_shift_factor=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """AddSpatialDispatchLayout_un(in_utility_network, template_name, is_active, {are_containers_preserved}, {iterations_number}, {maximum_shift_factor})

       Add a spatial dispatch layout to a diagram template

    INPUTS:
     in_utility_network (Utility Network / Trace Network):
         Input Network
     template_name (String):
         Input Diagram Template
     is_active (Boolean):
         Active
     are_containers_preserved {Boolean}:
         Preserve container layout
     iterations_number {Long}:
         Number of Iterations
     maximum_shift_factor {Double}:
         Maximum Shift Factor"""
    ...

@gptooldoc("AddStartIterationRule_un", None)
def AddStartIterationRule(
    in_utility_network=..., template_name=..., is_active=..., description=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """AddStartIterationRule_un(in_utility_network, template_name, is_active, {description})

       Add a start iteration rule to a diagram template

    INPUTS:
     in_utility_network (Utility Network / Trace Network):
         Input Network
     template_name (String):
         Input Diagram Template
     is_active (Boolean):
         Active
     description {String}:
         Description"""
    ...

@gptooldoc("AddStopIterationRule_un", None)
def AddStopIterationRule(
    in_utility_network=..., template_name=..., is_active=..., description=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """AddStopIterationRule_un(in_utility_network, template_name, is_active, {description})

       Add a stop iteration rule to a diagram template

    INPUTS:
     in_utility_network (Utility Network / Trace Network):
         Input Network
     template_name (String):
         Input Diagram Template
     is_active (Boolean):
         Active
     description {String}:
         Description"""
    ...

@gptooldoc("AddStructuralAttachmentsRule_un", None)
def AddStructuralAttachmentsRule(
    in_utility_network=..., template_name=..., is_active=..., description=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """AddStructuralAttachmentsRule_un(in_utility_network, template_name, is_active, {description})

       Add a structural attachments rule to a diagram template

    INPUTS:
     in_utility_network (Utility Network):
         Input Network
     template_name (String):
         Input Diagram Template
     is_active (Boolean):
         Active
     description {String}:
         Description"""
    ...

@gptooldoc("AddTraceLocations_un", None)
def AddTraceLocations(
    in_utility_network=...,
    out_feature_class=...,
    load_selected_features=...,
    clear_trace_locations=...,
    trace_locations=...,
    filter_barrier=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """AddTraceLocations_un(in_utility_network, out_feature_class, {load_selected_features}, {clear_trace_locations}, {trace_locations;trace_locations...}, {filter_barrier})

       Creates a feature class to be used as the starting points and barriers
       input for the Trace tool.

    INPUTS:
     in_utility_network (Utility Network / Utility Network Layer):
         The input utility network where the trace locations will be added.
     load_selected_features {Boolean}:
         Specifies whether selected features in the active map will be loaded
         as trace locations.

         * LOAD_SELECTED_FEATURES-Trace locations will be loaded based on the
         selection in the map.

         * DO_NOT_LOAD_SELECTED_FEATURES-Trace locations will not be loaded
         based on the selection in the map. This is the default. However, trace
         locations can be loaded using the trace_locations parameter.
     clear_trace_locations {Boolean}:
         Specifies whether existing trace locations will be cleared from the
         output feature class.

         * CLEAR_LOCATIONS-Existing trace locations will be cleared.

         * KEEP_LOCATIONS-Existing trace locations will not be cleared; they
         will be kept. This is the default.
     trace_locations {Value Table}:
         The trace locations that will be added to the output feature class. If
         you are not using the load_selected_features parameter in an active
         map, you can use this parameter to specify the utility network
         features to add as trace locations by providing the required values in
         the value table. The trace locations properties are as follows:

         * Layer Name-The layer or feature class participating in the utility
         network that contains a starting point or barrier location to be
         added. If there is an active map, only layers from the map are
         allowed; if not, this will be the feature class name.

         * Global ID-The Global ID of the feature for the location to add.

         * Terminal ID-The terminal ID of the feature for the location to add.

         * Percent Along-The percent along value of the feature. For line
         features, the default value is 0.5.
     filter_barrier {Boolean}:
         Specifies whether the barriers for the trace locations will behave as
         filter barriers.

         * FILTER_BARRIER-The barriers will behave as filter barriers. This is
         useful for subnetwork-based traces in which the barrier allows the
         subnetwork to be evaluated first and is then applied on a second
         traversal of the network features.

         * TRAVERSABILITY_BARRIER-The barriers will behave as traversability
         barriers, which define the extent of subnetworks, and will be
         evaluated on the first pass. This is the default.
         This parameter requires ArcGIS Enterprise10.8.1 or later.

    OUTPUTS:
     out_feature_class (Feature Class):
         The output feature class containing the trace locations. If you
         specify a new feature class name, a new output feature class will be
         created.To use an existing feature class that was previously created
         by this
         tool and append or overwrite the existing locations, specify the name
         of the existing feature class."""
    ...

@gptooldoc("AddTraceRule_un", None)
def AddTraceRule(
    in_utility_network=...,
    template_name=...,
    is_active=...,
    trace_type=...,
    domain_network=...,
    tier=...,
    target_tier=...,
    include_structures=...,
    include_barriers=...,
    condition_barriers=...,
    function_barriers=...,
    traversability_scope=...,
    filter_barriers=...,
    filter_function_barriers=...,
    filter_scope=...,
    filter_bitset_network_attribute_name=...,
    filter_nearest=...,
    nearest_count=...,
    nearest_cost_network_attribute=...,
    nearest_categories=...,
    nearest_assets=...,
    propagators=...,
    description=...,
    allow_indeterminate_flow=...,
    path_direction=...,
    path_network_weight_name=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """AddTraceRule_un(in_utility_network, template_name, is_active, trace_type, {domain_network}, {tier}, {target_tier}, {include_structures}, {include_barriers}, {condition_barriers;condition_barriers...}, {function_barriers;function_barriers...}, {traversability_scope}, {filter_barriers;filter_barriers...}, {filter_function_barriers;filter_function_barriers...}, {filter_scope}, {filter_bitset_network_attribute_name}, {filter_nearest}, {nearest_count}, {nearest_cost_network_attribute}, {nearest_categories;nearest_categories...}, {nearest_assets;nearest_assets...}, {propagators;propagators...}, {description}, {allow_indeterminate_flow}, {path_direction}, {path_network_weight_name})

       Add a trace rule to a diagram template

    INPUTS:
     in_utility_network (Utility Network / Trace Network):
         Input Network
     template_name (String):
         Input Diagram Template
     is_active (Boolean):
         Active
     trace_type (String):
         Trace Type
     domain_network {String}:
         Domain Network
     tier {String}:
         Tier
     target_tier {String}:
         Target Tier
     include_structures {Boolean}:
         Include Structures
     include_barriers {Boolean}:
         Include Barrier Features
     condition_barriers {Value Table}:
         Condition Barriers
     function_barriers {Value Table}:
         Function Barriers
     traversability_scope {String}:
         Apply Traversability To
     filter_barriers {Value Table}:
         Filter Barriers
     filter_function_barriers {Value Table}:
         Filter Function Barriers
     filter_scope {String}:
         Apply Filter To
     filter_bitset_network_attribute_name {String}:
         Filter by bitset network attribute
     filter_nearest {Boolean}:
         Filter by nearest
     nearest_count {Long}:
         Count
     nearest_cost_network_attribute {String}:
         Cost Network Attribute
     nearest_categories {String}:
         Nearest Categories
     nearest_assets {String}:
         Nearest Asset Groups/Types
     propagators {Value Table}:
         Propagators
     description {String}:
         Description
     allow_indeterminate_flow {Boolean}:
         Allow Indeterminate Flow
     path_direction {String}:
         Path Direction
     path_network_weight_name {String}:
         Shortest Path Network Attribute Name"""
    ...

@gptooldoc("AlterDiagramProperties_un", None)
def AlterDiagramProperties(
    in_network_diagram_layer=..., out_name=..., access_right_type=..., tags=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """AlterDiagramProperties_un(in_network_diagram_layer, {out_name}, {access_right_type}, {tags})

       Set the name, the location and the access rights of a network diagram

    INPUTS:
     in_network_diagram_layer (Diagram Layer):
         Input Network Diagram Layer
     out_name {String}:
         Network Diagram Name
     access_right_type {String}:
         Network Diagram Access Rights
     tags {String}:
         Tags (optional)"""
    ...

@gptooldoc("AlterDiagramTemplate_un", None)
def AlterDiagramTemplate(
    in_utility_network=...,
    template_name=...,
    out_name=...,
    is_default_template=...,
    are_rules_and_layouts_removed=...,
    are_vertices_kept=...,
    container_margin=...,
    is_diagram_storage_enabled=...,
    is_diagram_extension_enabled=...,
    description=...,
    are_layer_definitions_removed=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """AlterDiagramTemplate_un(in_utility_network, template_name, {out_name}, {is_default_template}, {are_rules_and_layouts_removed}, {are_vertices_kept}, {container_margin}, {is_diagram_storage_enabled}, {is_diagram_extension_enabled}, {description}, {are_layer_definitions_removed})

       Alter the properties of the Diagram Template

    INPUTS:
     in_utility_network (Utility Network / Trace Network):
         Input Network
     template_name (String):
         Input Diagram Template
     out_name {String}:
         Diagram Template Name
     is_default_template {Boolean}:
         Default template
     are_rules_and_layouts_removed {Boolean}:
         Remove the diagram template rule and layout definitions
     are_vertices_kept {Boolean}:
         Keep initial vertices on edges
     container_margin {Linear Unit}:
         Container Margin
     is_diagram_storage_enabled {Boolean}:
         Enable to store diagrams
     is_diagram_extension_enabled {Boolean}:
         Enable to extend diagrams
     description {String}:
         Description
     are_layer_definitions_removed {Boolean}:
         Reset the diagram template layer definition to default"""
    ...

@gptooldoc("AppendToDiagram_un", None)
def AppendToDiagram(
    in_network_diagram_layer=..., map=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """AppendToDiagram_un(in_network_diagram_layer, map)

       Append Elements to a Network Diagram

    INPUTS:
     in_network_diagram_layer (Diagram Layer):
         Input Network Diagram Layer
     map (Map):
         Input Map"""
    ...

@gptooldoc("ApplyAngleDirectedLayout_un", None)
def ApplyAngleDirectedLayout(
    in_network_diagram_layer=...,
    are_containers_preserved=...,
    iterations_number=...,
    number_of_directions=...,
    run_async=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """ApplyAngleDirectedLayout_un(in_network_diagram_layer, {are_containers_preserved}, {iterations_number}, {number_of_directions}, {run_async})

       Apply the angle directed layout to a diagram

    INPUTS:
     in_network_diagram_layer (Diagram Layer):
         Input Network Diagram Layer
     are_containers_preserved {Boolean}:
         Preserve container layout
     iterations_number {Long}:
         Number of Iterations
     number_of_directions {String}:
         Number of Directions
     run_async {Boolean}:
         Run in asynchronous mode on the server"""
    ...

@gptooldoc("ApplyCompressionLayout_un", None)
def ApplyCompressionLayout(
    in_network_diagram_layer=...,
    are_containers_preserved=...,
    grouping_distance_absolute=...,
    vertices_removal_rule=...,
    run_async=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """ApplyCompressionLayout_un(in_network_diagram_layer, {are_containers_preserved}, {grouping_distance_absolute}, {vertices_removal_rule}, {run_async})

       Apply the compression layout to a diagram

    INPUTS:
     in_network_diagram_layer (Diagram Layer):
         Input Network Diagram Layer
     are_containers_preserved {Boolean}:
         Preserve container layout
     grouping_distance_absolute {Linear Unit}:
         Maximum Distance for Grouping
     vertices_removal_rule {String}:
         Vertex Removal Rule
     run_async {Boolean}:
         Run in asynchronous mode on the server"""
    ...

@gptooldoc("ApplyForceDirectedLayout_un", None)
def ApplyForceDirectedLayout(
    in_network_diagram_layer=...,
    are_containers_preserved=...,
    iterations_number=...,
    repel_factor=...,
    degree_freedom=...,
    breakpoint_position=...,
    edge_display_type=...,
    run_async=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """ApplyForceDirectedLayout_un(in_network_diagram_layer, {are_containers_preserved}, {iterations_number}, {repel_factor}, {degree_freedom}, {breakpoint_position}, {edge_display_type}, {run_async})

       Apply the force directed layout to a diagram

    INPUTS:
     in_network_diagram_layer (Diagram Layer):
         Input Network Diagram Layer
     are_containers_preserved {Boolean}:
         Preserve container layout
     iterations_number {Long}:
         Number of Iterations
     repel_factor {Double}:
         Repel Factor
     degree_freedom {String}:
         Degree of Freedom
     breakpoint_position {Double}:
         Break Point Relative Position (%)
     edge_display_type {String}:
         Edge Display Type
     run_async {Boolean}:
         Run in asynchronous mode on the server"""
    ...

@gptooldoc("ApplyGeoPositionsLayout_un", None)
def ApplyGeoPositionsLayout(
    in_network_diagram_layer=..., restore_edges_geo_positions=..., run_async=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """ApplyGeoPositionsLayout_un(in_network_diagram_layer, {restore_edges_geo_positions}, {run_async})

       Apply the geo positions layout to a diagram

    INPUTS:
     in_network_diagram_layer (Diagram Layer):
         Input Network Diagram Layer
     restore_edges_geo_positions {Boolean}:
         Restore edges geographic positions
     run_async {Boolean}:
         Run in asynchronous mode on the server"""
    ...

@gptooldoc("ApplyGridLayout_un", None)
def ApplyGridLayout(
    in_network_diagram_layer=...,
    are_containers_preserved=...,
    cell_width_absolute=...,
    cell_height_absolute=...,
    run_async=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """ApplyGridLayout_un(in_network_diagram_layer, {are_containers_preserved}, {cell_width_absolute}, {cell_height_absolute}, {run_async})

       Apply the grid layout to a diagram

    INPUTS:
     in_network_diagram_layer (Diagram Layer):
         Input Network Diagram Layer
     are_containers_preserved {Boolean}:
         Preserve container layout
     cell_width_absolute {Linear Unit}:
         Cell Width
     cell_height_absolute {Linear Unit}:
         Cell Height
     run_async {Boolean}:
         Run in asynchronous mode on the server"""
    ...

@gptooldoc("ApplyLinearDispatchLayout_un", None)
def ApplyLinearDispatchLayout(
    in_network_diagram_layer=...,
    junction_placement_type=...,
    is_unit_absolute=...,
    maximum_shift_absolute=...,
    maximum_shift_proportional=...,
    minimum_shift_absolute=...,
    minimum_shift_proportional=...,
    iterations_number=...,
    is_path_preserved=...,
    are_leaves_moved=...,
    are_leaves_expanded=...,
    expand_shift_absolute=...,
    expand_shift_proportional=...,
    run_async=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """ApplyLinearDispatchLayout_un(in_network_diagram_layer, {junction_placement_type}, {is_unit_absolute}, {maximum_shift_absolute}, {maximum_shift_proportional}, {minimum_shift_absolute}, {minimum_shift_proportional}, {iterations_number}, {is_path_preserved}, {are_leaves_moved}, {are_leaves_expanded}, {expand_shift_absolute}, {expand_shift_proportional}, {run_async})

       Apply the linear dispatch layout to a diagram

    INPUTS:
     in_network_diagram_layer (Diagram Layer):
         Input Network Diagram Layer
     junction_placement_type {String}:
         Junctions Placement
     is_unit_absolute {Boolean}:
         Spacing values interpreted as absolute units in the diagram coordinate system
     maximum_shift_absolute {Linear Unit}:
         Maximum Shift
     maximum_shift_proportional {Double}:
         Maximum Shift
     minimum_shift_absolute {Linear Unit}:
         Minimum Shift
     minimum_shift_proportional {Double}:
         Minimum Shift
     iterations_number {Long}:
         Number of Iterations
     is_path_preserved {Boolean}:
         Preserve path
     are_leaves_moved {Boolean}:
         Move leaves
     are_leaves_expanded {Boolean}:
         Expand leaves
     expand_shift_absolute {Linear Unit}:
         Maximum Expand Shift
     expand_shift_proportional {Double}:
         Maximum Expand Shift
     run_async {Boolean}:
         Run in asynchronous mode on the server"""
    ...

@gptooldoc("ApplyMainRingLayout_un", None)
def ApplyMainRingLayout(
    in_network_diagram_layer=...,
    are_containers_preserved=...,
    ring_type=...,
    is_unit_absolute=...,
    ring_width_absolute=...,
    ring_width_proportional=...,
    ring_height_absolute=...,
    ring_height_proportional=...,
    tree_type=...,
    perpendicular_absolute=...,
    perpendicular_proportional=...,
    along_absolute=...,
    along_proportional=...,
    breakpoint_position=...,
    edge_display_type=...,
    run_async=...,
    offset_absolute=...,
    offset_proportional=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """ApplyMainRingLayout_un(in_network_diagram_layer, {are_containers_preserved}, {ring_type}, {is_unit_absolute}, {ring_width_absolute}, {ring_width_proportional}, {ring_height_absolute}, {ring_height_proportional}, {tree_type}, {perpendicular_absolute}, {perpendicular_proportional}, {along_absolute}, {along_proportional}, {breakpoint_position}, {edge_display_type}, {run_async}, {offset_absolute}, {offset_proportional})

       Apply the main ring layout to a diagram

    INPUTS:
     in_network_diagram_layer (Diagram Layer):
         Input Network Diagram Layer
     are_containers_preserved {Boolean}:
         Preserve container layout
     ring_type {String}:
         Ring Type
     is_unit_absolute {Boolean}:
         Spacing values interpreted as absolute units in the diagram coordinate system
     ring_width_absolute {Linear Unit}:
         Ring Width
     ring_width_proportional {Double}:
         Ring Width
     ring_height_absolute {Linear Unit}:
         Ring Height
     ring_height_proportional {Double}:
         Ring Height
     tree_type {String}:
         Hierarchical Tree Type
     perpendicular_absolute {Linear Unit}:
         Between Junctions Perpendicular to the Direction
     perpendicular_proportional {Double}:
         Between Junctions Perpendicular to the Direction
     along_absolute {Linear Unit}:
         Between Junctions Along the Direction
     along_proportional {Double}:
         Between Junctions Along the Direction
     breakpoint_position {Double}:
         Break Point Relative Position (%)
     edge_display_type {String}:
         Edge Display Type
     run_async {Boolean}:
         Run in asynchronous mode on the server
     offset_absolute {Linear Unit}:
         Offset
     offset_proportional {Double}:
         Offset"""
    ...

@gptooldoc("ApplyMainlineTreeLayout_un", None)
def ApplyMainlineTreeLayout(
    in_network_diagram_layer=...,
    are_containers_preserved=...,
    tree_direction=...,
    branches_placement=...,
    is_unit_absolute=...,
    perpendicular_absolute=...,
    perpendicular_proportional=...,
    along_absolute=...,
    along_proportional=...,
    disjoined_graph_absolute=...,
    disjoined_graph_proportional=...,
    are_edges_orthogonal=...,
    breakpoint_position=...,
    edge_display_type=...,
    run_async=...,
    offset_absolute=...,
    offset_proportional=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """ApplyMainlineTreeLayout_un(in_network_diagram_layer, {are_containers_preserved}, {tree_direction}, {branches_placement}, {is_unit_absolute}, {perpendicular_absolute}, {perpendicular_proportional}, {along_absolute}, {along_proportional}, {disjoined_graph_absolute}, {disjoined_graph_proportional}, {are_edges_orthogonal}, {breakpoint_position}, {edge_display_type}, {run_async}, {offset_absolute}, {offset_proportional})

       Apply the mainline tree layout to a diagram

    INPUTS:
     in_network_diagram_layer (Diagram Layer):
         Input Network Diagram Layer
     are_containers_preserved {Boolean}:
         Preserve container layout
     tree_direction {String}:
         Tree Direction
     branches_placement {String}:
         Branches Placement
     is_unit_absolute {Boolean}:
         Spacing values interpreted as absolute units in the diagram coordinate system
     perpendicular_absolute {Linear Unit}:
         Between Junctions Perpendicular to the Direction
     perpendicular_proportional {Double}:
         Between Junctions Perpendicular to the Direction
     along_absolute {Linear Unit}:
         Between Junctions Along the Direction
     along_proportional {Double}:
         Between Junctions Along the Direction
     disjoined_graph_absolute {Linear Unit}:
         Between Disjoined Graphs
     disjoined_graph_proportional {Double}:
         Between Disjoined Graphs
     are_edges_orthogonal {Boolean}:
         Orthogonally display edges
     breakpoint_position {Double}:
         Break Point Relative Position (%)
     edge_display_type {String}:
         Edge Display Type
     run_async {Boolean}:
         Run in asynchronous mode on the server
     offset_absolute {Linear Unit}:
         Offset
     offset_proportional {Double}:
         Offset"""
    ...

@gptooldoc("ApplyPartialOverlappingEdgesLayout_un", None)
def ApplyPartialOverlappingEdgesLayout(
    in_network_diagram_layer=...,
    buffer_width_absolute=...,
    offset_absolute=...,
    optimize_edges=...,
    run_async=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """ApplyPartialOverlappingEdgesLayout_un(in_network_diagram_layer, buffer_width_absolute, offset_absolute, {optimize_edges}, {run_async})

       Apply the partial overlapping edges to a diagram

    INPUTS:
     in_network_diagram_layer (Diagram Layer):
         Input Network Diagram Layer
     buffer_width_absolute (Linear Unit):
         Buffer Width
     offset_absolute (Linear Unit):
         Offset
     optimize_edges {Boolean}:
         Optimize edges
     run_async {Boolean}:
         Run in asynchronous mode on the server"""
    ...

@gptooldoc("ApplyRadialTreeLayout_un", None)
def ApplyRadialTreeLayout(
    in_network_diagram_layer=...,
    are_containers_preserved=...,
    is_unit_absolute=...,
    initial_radius_absolute=...,
    initial_radius_proportional=...,
    disjoined_graph_absolute=...,
    disjoined_graph_proportional=...,
    radius_factor=...,
    run_async=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """ApplyRadialTreeLayout_un(in_network_diagram_layer, {are_containers_preserved}, {is_unit_absolute}, {initial_radius_absolute}, {initial_radius_proportional}, {disjoined_graph_absolute}, {disjoined_graph_proportional}, {radius_factor}, {run_async})

       Apply the radial tree layout to a diagram

    INPUTS:
     in_network_diagram_layer (Diagram Layer):
         Input Network Diagram Layer
     are_containers_preserved {Boolean}:
         Preserve container layout
     is_unit_absolute {Boolean}:
         Spacing values interpreted as absolute units in the diagram coordinate system
     initial_radius_absolute {Linear Unit}:
         Initial Radius
     initial_radius_proportional {Double}:
         Initial Radius
     disjoined_graph_absolute {Linear Unit}:
         Between Disjoined Graphs
     disjoined_graph_proportional {Double}:
         Between Disjoined Graphs
     radius_factor {Double}:
         Radius Factor
     run_async {Boolean}:
         Run in asynchronous mode on the server"""
    ...

@gptooldoc("ApplyRotateTreeLayout_un", None)
def ApplyRotateTreeLayout(
    in_network_diagram_layer=...,
    are_containers_preserved=...,
    rotation_angle=...,
    run_async=...,
    rotate_junction=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """ApplyRotateTreeLayout_un(in_network_diagram_layer, {are_containers_preserved}, {rotation_angle}, {run_async}, {rotate_junction})

       Apply the rotate tree layout to a diagram

    INPUTS:
     in_network_diagram_layer (Diagram Layer):
         Input Network Diagram Layer
     are_containers_preserved {Boolean}:
         Preserve container layout
     rotation_angle {Double}:
         Angle
     run_async {Boolean}:
         Run in asynchronous mode on the server
     rotate_junction {Boolean}:
         Rotate junction symbols with the same angle"""
    ...

@gptooldoc("ApplySmartTreeLayout_un", None)
def ApplySmartTreeLayout(
    in_network_diagram_layer=...,
    are_containers_preserved=...,
    tree_direction=...,
    is_unit_absolute=...,
    subtree_absolute=...,
    subtree_proportional=...,
    perpendicular_absolute=...,
    perpendicular_proportional=...,
    along_absolute=...,
    along_proportional=...,
    disjoined_graph_absolute=...,
    disjoined_graph_proportional=...,
    are_edges_orthogonal=...,
    breakpoint_position=...,
    edge_display_type=...,
    run_async=...,
    offset_absolute=...,
    offset_proportional=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """ApplySmartTreeLayout_un(in_network_diagram_layer, {are_containers_preserved}, {tree_direction}, {is_unit_absolute}, {subtree_absolute}, {subtree_proportional}, {perpendicular_absolute}, {perpendicular_proportional}, {along_absolute}, {along_proportional}, {disjoined_graph_absolute}, {disjoined_graph_proportional}, {are_edges_orthogonal}, {breakpoint_position}, {edge_display_type}, {run_async}, {offset_absolute}, {offset_proportional})

       Apply the smart tree layout to a diagram

    INPUTS:
     in_network_diagram_layer (Diagram Layer):
         Input Network Diagram Layer
     are_containers_preserved {Boolean}:
         Preserve container layout
     tree_direction {String}:
         Tree Direction
     is_unit_absolute {Boolean}:
         Spacing values interpreted as absolute units in the diagram coordinate system
     subtree_absolute {Linear Unit}:
         Between Subtrees
     subtree_proportional {Double}:
         Between Subtrees
     perpendicular_absolute {Linear Unit}:
         Between Junctions Perpendicular to the Direction
     perpendicular_proportional {Double}:
         Between Junctions Perpendicular to the Direction
     along_absolute {Linear Unit}:
         Between Junctions Along the Direction
     along_proportional {Double}:
         Between Junctions Along the Direction
     disjoined_graph_absolute {Linear Unit}:
         Between Disjoined Graphs
     disjoined_graph_proportional {Double}:
         Between Disjoined Graphs
     are_edges_orthogonal {Boolean}:
         Orthogonally display edges
     breakpoint_position {Double}:
         Break Point Relative Position (%)
     edge_display_type {String}:
         Edge Display Type
     run_async {Boolean}:
         Run in asynchronous mode on the server
     offset_absolute {Linear Unit}:
         Offset
     offset_proportional {Double}:
         Offset"""
    ...

@gptooldoc("ApplySpatialDispatchLayout_un", None)
def ApplySpatialDispatchLayout(
    in_network_diagram_layer=...,
    are_containers_preserved=...,
    iterations_number=...,
    maximum_shift_factor=...,
    run_async=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """ApplySpatialDispatchLayout_un(in_network_diagram_layer, {are_containers_preserved}, {iterations_number}, {maximum_shift_factor}, {run_async})

       Apply the spatial dispatch layout to a diagram

    INPUTS:
     in_network_diagram_layer (Diagram Layer):
         Input Network Diagram Layer
     are_containers_preserved {Boolean}:
         Preserve container layout
     iterations_number {Long}:
         Number of Iterations
     maximum_shift_factor {Double}:
         Maximum Shift Factor
     run_async {Boolean}:
         Run in asynchronous mode on the server"""
    ...

@gptooldoc("ApplyTemplateLayouts_un", None)
def ApplyTemplateLayouts(
    in_network_diagram_layer=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """ApplyTemplateLayouts_un(in_network_diagram_layer)

       Apply the preconfigured template layouts

    INPUTS:
     in_network_diagram_layer (Diagram Layer):
         Input Network Diagram Layer"""
    ...

@gptooldoc("ChangeDiagramsOwner_un", None)
def ChangeDiagramsOwner(
    in_diagrams=..., target_owner=..., source_owner=..., diagram_names=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """ChangeDiagramsOwner_un(in_diagrams, target_owner, {source_owner}, {diagram_names;diagram_names...})

       Change the diagrams owner

    INPUTS:
     in_diagrams (Utility Network / Trace Network / Utility Network Layer / Trace Network Layer / Diagram Layer):
         Input Network or Network Diagram Layer
     target_owner (String):
         Target Owner
     source_owner {String}:
         Source Owner
     diagram_names {String}:
         Diagram Names"""
    ...

@gptooldoc("CreateDiagram_un", None)
def CreateDiagram(
    in_utility_network=..., template_name=..., features=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """CreateDiagram_un(in_utility_network, template_name, {features;features...})

       Create a Network Diagram

    INPUTS:
     in_utility_network (Utility Network / Trace Network / Utility Network Layer / Trace Network Layer):
         Input Network
     template_name (String):
         Input Diagram Template
     features {Feature Layer}:
         Input Features"""
    ...

@gptooldoc("CreateDiagramLayerDefinition_un", None)
def CreateDiagramLayerDefinition(
    in_utility_network=...,
    template_name=...,
    system_junctions=...,
    connectivity_associations=...,
    structural_attachments=...,
    reduction_edges=...,
    point_subLayers=...,
    polygon_subLayers=...,
    junction_object_point_subLayers=...,
    edge_object_polyline_subLayers=...,
    overwrite_all_layers=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """CreateDiagramLayerDefinition_un(in_utility_network, template_name, {system_junctions}, {connectivity_associations}, {structural_attachments}, {reduction_edges}, {point_subLayers;point_subLayers...}, {polygon_subLayers;polygon_subLayers...}, {junction_object_point_subLayers;junction_object_point_subLayers...}, {edge_object_polyline_subLayers;edge_object_polyline_subLayers...}, {overwrite_all_layers})

       Create or overwwrite a diagram template layer definitions

    INPUTS:
     in_utility_network (Utility Network Layer / Trace Network Layer):
         Input Network
     template_name (String):
         Input Diagram Template
     system_junctions {Boolean}:
         System Junctions
     connectivity_associations {Boolean}:
         Connectivity Associations
     structural_attachments {Boolean}:
         Structural Attachments
     reduction_edges {Boolean}:
         Reduction Edge
     point_subLayers {Value Table}:
         Points for edges reduced as junctions and collapsed polygons
     polygon_subLayers {Value Table}:
         Polygons for containers
     junction_object_point_subLayers {Value Table}:
         Points for junction objects
     edge_object_polyline_subLayers {Value Table}:
         Polylines for edge objects
     overwrite_all_layers {Boolean}:
         Overwrite all layers"""
    ...

@gptooldoc("DeleteDiagram_un", None)
def DeleteDiagram(
    in_diagrams=..., template_names=..., diagram_names=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """DeleteDiagram_un(in_diagrams, {template_names;template_names...}, {diagram_names;diagram_names...})

       Select and delete network diagrams from a diagram dataset

    INPUTS:
     in_diagrams (Utility Network / Trace Network / Utility Network Layer / Trace Network Layer / Diagram Layer):
         Input Network or Network Diagram Layer
     template_names {String}:
         Template Names
     diagram_names {String}:
         Diagram Names"""
    ...

@gptooldoc("DeleteDiagramTemplate_un", None)
def DeleteDiagramTemplate(
    in_utility_network=..., template_name=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """DeleteDiagramTemplate_un(in_utility_network, template_name)

       Delete a diagram template

    INPUTS:
     in_utility_network (Utility Network / Trace Network):
         Input Network
     template_name (String):
         Input Diagram Template"""
    ...

@gptooldoc("ExportDiagramContent_un", None)
def ExportDiagramContent(
    in_utility_network=...,
    network_diagram_name=...,
    out_file=...,
    include_diagram_properties=...,
    include_geometries=...,
    include_attributes=...,
    include_aggregations=...,
    use_domains=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """ExportDiagramContent_un(in_utility_network, network_diagram_name, out_file, {include_diagram_properties}, {include_geometries}, {include_attributes}, {include_aggregations}, {use_domains})

       Export a diagram content to a file

    INPUTS:
     in_utility_network (Utility Network / Trace Network / Utility Network Layer / Trace Network Layer / Diagram Layer):
         Input Network or Network Diagram Layer
     network_diagram_name (String):
         Network Diagram Name
     include_diagram_properties {Boolean}:
         Include diagram properties
     include_geometries {Boolean}:
         Include geometries
     include_attributes {Boolean}:
         Include attributes
     include_aggregations {Boolean}:
         Include aggregations
     use_domains {Boolean}:
         Use domain and subtype descriptions

    OUTPUTS:
     out_file (File):
         Output File"""
    ...

@gptooldoc("ExportDiagramLayerDefinition_un", None)
def ExportDiagramLayerDefinition(
    in_network_diagram_layer=..., out_ndld_file=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """ExportDiagramLayerDefinition_un(in_network_diagram_layer, out_ndld_file)

       Export a diagram template layer definition to a file

    INPUTS:
     in_network_diagram_layer (Diagram Layer):
         Input Network Diagram Layer

    OUTPUTS:
     out_ndld_file (File):
         Output Diagram Layer Definition File"""
    ...

@gptooldoc("ExportDiagramTemplateDefinitions_un", None)
def ExportDiagramTemplateDefinitions(
    in_utility_network=..., template_name=..., out_ndbd_file=..., out_ndld_file=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """ExportDiagramTemplateDefinitions_un(in_utility_network, template_name, {out_ndbd_file}, {out_ndld_file})

       Export diagram template definitions to a file

    INPUTS:
     in_utility_network (Utility Network / Trace Network):
         Input Network
     template_name (String):
         Input Diagram Template

    OUTPUTS:
     out_ndbd_file {File}:
         Output Rule and Layout Definitions File
     out_ndld_file {File}:
         Output Diagram Layer Definition File"""
    ...

@gptooldoc("ExportSubnetwork_un", None)
def ExportSubnetwork(
    in_utility_network=...,
    domain_network=...,
    tier=...,
    subnetwork_name=...,
    export_acknowledged=...,
    out_json_file=...,
    condition_barriers=...,
    function_barriers=...,
    include_barriers=...,
    traversability_scope=...,
    propagators=...,
    include_geometry=...,
    result_types=...,
    result_network_attributes=...,
    result_fields=...,
    include_domain_descriptions=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """ExportSubnetwork_un(in_utility_network, domain_network, tier, subnetwork_name, export_acknowledged, out_json_file, {condition_barriers;condition_barriers...}, {function_barriers;function_barriers...}, {include_barriers}, {traversability_scope}, {propagators;propagators...}, {include_geometry}, {result_types;result_types...}, {result_network_attributes;result_network_attributes...}, {result_fields;result_fields...}, {include_domain_descriptions})

       Exports subnetworks from a utility network into a .json file. This
       tool also allows you to delete a row in the Subnetworks table as long
       as the Is deleted attribute is set to true. This indicates that the
       subnetwork controller has been removed from the subnetwork.

    INPUTS:
     in_utility_network (Utility Network / Utility Network Layer):
         The utility network that contains the subnetwork to export.
     domain_network (String):
         The domain network that contains the subnetwork.
     tier (String):
         The tier that contains the subnetwork.
     subnetwork_name (String):
         The name of the subnetwork that will be exported from the tier. Select
         a specific source to export the corresponding subnetwork information.
     export_acknowledged (Boolean):
         Specifies whether the LASTACKEXPORTSUBNETWORK attribute for the
         corresponding controller in the Subnetworks table and feature in the
         SubnetLine feature class will be updated.

         * ACKNOWLEDGE-The LASTACKEXPORTSUBNETWORK attribute for the
         corresponding controller in the Subnetworks table will be updated. If
         the source has been marked for deletion (Is deleted = True), it will
         be deleted from the Subnetworks table. This option requires that the
         input utility network reference the default version.

         * NO_ACKNOWLEDGE-The LASTACKEXPORTSUBNETWORK attribute for the
         corresponding controller in the Subnetworks table will not be updated.
         This is the default.
     condition_barriers {Value Table}:
         Sets a traversability barrier condition on features based on a
         comparison to a network attribute or check for a category string. A
         condition barrier uses a network attribute, an operator and a type,
         and an attribute value. For example, stop a trace when a feature has
         the Device Status attribute equal to the specific value of Open. When
         a feature meets this condition, the trace stops. If you're using more
         than one attribute, you can use the Combine using parameter to define
         an And or an Or condition. Condition barrier components are as
         follows:

         * Name-Filter by any network attribute defined in the system.

         * Operator-Choose from a number of different operators.

         * Type-Choose a specific value or network attribute from the value
         that is specified in the name parameter.

         * Value-Set a specific value of the input attribute type that will
         cause termination based on the operator value.

         * Combine Using-Set this value if you have multiple attributes to add.
         You can combine them using an And or an Or condition.
         The condition barrier operator values are as follows:

         * IS_EQUAL_TO-The attribute is equal to the value.

         * DOES_NOT_EQUAL-The attribute is not equal to the value.

         * IS_GREATER_THAN-The attribute is greater than the value.

         * IS_GREATER_THAN_OR_EQUAL_TO-The attribute is greater than or equal
         to the value.

         * IS_LESS_THAN-The attribute is less than the value.

         * IS_LESS_THAN_OR_EQUAL_TO-The attribute is less than or equal to the
         value.

         * INCLUDES_THE_VALUES-A bitwise AND operation in which all bits in the
         value are present in the attribute (bitwise AND == value).

         * DOES_NOT_INCLUDE_THE_VALUES-A bitwise AND operation in which not all
         of the bits in the value are present in the attribute (bitwise AND !=
         value).

         * INCLUDES_ANY-A bitwise AND operation in which at least one bit in
         the value is present in the attribute (bitwise AND == True).

         * DOES_NOT_INCLUDE_ANY-A bitwise AND operation in which none of the
         bits in the value are present in the attribute (bitwise AND == False).
         The condition barrier type options are as follows:

         * SPECIFIC_VALUE-Filter by a specific value.

         * NETWORK_ATTRIBUTE-Filter by a network attribute.
         The Combine Using values are as follows:

         * AND-Combine the condition barriers.

         * OR-Use if either condition barrier is met.
     function_barriers {Value Table}:
         Sets a traversability barrier on features based on a function.
         Function barriers can be used to do such things as restrict how far
         the trace travels from the starting point, or set a maximum value to
         stop a trace. For example, the length of each line traveled is added
         to the total distance traveled so far. When the total length traveled
         reaches the value specified, the trace stops. Function barrier
         components are as follows:

         * Function-Choose from a number of different calculation functions.

         * Attribute-Filter by any network attribute defined in the system.

         * Operator-Choose from a number of different operators.

         * Value-Set a specific value of the input attribute type that, if
         discovered, will cause the termination.

         * Use Local Values-Calculate values in each direction as opposed to an
         overall global value. For example, use for a function barrier that is
         calculating the sum of Shape length where the trace terminates if the
         value is greater than or equal to 4. In the global case, after you
         have traversed two edges with a value of 2, you have already reached a
         shape length sum of 4, so the trace stops. If local values are used,
         the local values along each path change, so the trace goes farther.

         * TRUE-Use local values.

         * FALSE-Use global values. This is the default.
         Possible values for the function barrier function options are as
         follows:

         * AVERAGE-The average of the input values.

         * COUNT-The number of features.

         * MAX-The maximum of the input values.

         * MIN-The minimum of the input values.

         * ADD-Add the values.

         * SUBTRACT-Subtract the values. Subnetwork controllers and loops trace
         types do not support the subtract function.
         For example, the starting point feature has a value of 20. The next
         feature has a value of 30. If you use the minimum function, the result
         is 20, maximum is 30, add is 50, average is 25, count is 2, and
         subtract is -10.The function barrier operator value options are as
         follows:

         * IS_EQUAL_TO-The attribute is equal to the value.

         * DOES_NOT_EQUAL-The attribute is not equal to the value.

         * IS_GREATER_THAN-The attribute is greater than the value.

         * IS_GREATER_THAN_OR_EQUAL_TO-The attribute is greater than or equal
         to the value.

         * IS_LESS_THAN-The attribute is less than the value.

         * IS_LESS_THAN_OR_EQUAL_TO-The attribute is less than or equal to the
         value.

         * INCLUDES_THE_VALUES-A bitwise AND operation in which all bits in the
         value are present in the attribute (bitwise AND == value).

         * DOES_NOT_INCLUDE_THE_VALUES-A bitwise AND operation in which not all
         of the bits in the value are present in the attribute (bitwise AND !=
         value).

         * INCLUDES_ANY-A bitwise AND operation in which at least one bit in
         the value is present in the attribute (bitwise AND == True).

         * DOES_NOT_INCLUDE_ANY-A bitwise AND operation in which none of the
         bits in the value are present in the attribute (bitwise AND == False).
     include_barriers {Boolean}:
         Specifies whether the traversability barrier features will be included
         in the trace results. Traversability barriers are optional even if
         they have been preset in the subnetwork definition.

         * INCLUDE_BARRIERS-Traversability barriers will be included in the
         trace results. This is the default.

         * EXCLUDE_BARRIERS-Traversability barriers will not be included in the
         trace results.
     traversability_scope {String}:
         Specifies the type of traversability that will be applied.
         Traversability scope determines whether traversability is applied to
         junctions, edges, or both. For example, if a condition barrier is
         defined to stop the trace if DEVICESTATUS is set to Open and the
         traversability scope is set to edges only, the trace will not stop
         even if the trace encounters an open device, because DEVICESTATUS is
         only applicable to junctions. In other words, this parameter indicates
         to the trace whether to ignore junctions, edges, or both.

         * BOTH_JUNCTIONS_AND_EDGES-Traversability will be applied to both
         junctions and edges.

         * JUNCTIONS_ONLY-Traversability will be applied to junctions only.

         * EDGES_ONLY-Traversability will be applied to edges only.
     propagators {Value Table}:
         Specifies the network attributes to propagate as well as how that
         propagation will occur during a trace. Propagated class attributes
         denote the key values on subnetwork controllers that are disseminated
         to the rest of the features in the subnetwork. For example, in an
         electric distribution model, you can propagate the phase value.
         Propagators components are as follows:

         * Attribute-Filter by any network attribute defined in the system.

         * Substitution Attribute-Use a substituted value instead of bitset
         network attribute values. Substitutions are encoded based on the
         number of bits in the network attribute being propagated. A
         substitution is a mapping of each bit in phase to another bit. For
         example, for Phase AC, one substitution could map bit A to B, and bit
         C to null. In this example, the substitution for 1010 (Phase AC) is
         0000-0010-0000-0000 (512). The substitution captures the mapping so
         you know that Phase A was mapped to B and Phase C was mapped to null,
         and not the other way around (that is, Phase A was not mapped to null
         and Phase C was not mapped to B).

         * Function-Choose from a number of calculation functions.

         * Operator-Choose from a number of operators.

         * Value-Provide a specific value for the input attribute type that
         would cause termination based on the operator value.
         Possible values for the propagators function are as follows:

         * PROPAGATED_BITWISE_AND-Compare the values from one feature to the
         next.

         * PROPAGATED_MIN-Get the minimum value.

         * PROPAGATED_MAX-Get the maximum value.
         The propagator operator values are as follows:

         * IS_EQUAL_TO-The attribute is equal to the value.

         * DOES_NOT_EQUAL-The attribute is not equal to the value.

         * IS_GREATER_THAN-The attribute is greater than the value.

         * IS_GREATER_THAN_OR_EQUAL_TO-The attribute is greater than or equal
         to the value.

         * IS_LESS_THAN-The attribute is less than the value.

         * IS_LESS_THAN_OR_EQUAL_TO-The attribute is less than or equal to the
         value.

         * INCLUDES_THE_VALUES-A bitwise AND operation in which all bits in the
         value are present in the attribute (bitwise AND == value).

         * DOES NOT INCLUDE_THE_VALUES-A bitwise AND operation in which not all
         of the bits in the value are present in the attribute (bitwise AND !=
         value).

         * INCLUDES_ANY-A bitwise AND operation in which at least one bit in
         the value is present in the attribute (bitwise AND == True).

         * DOES_NOT_INLCUDE_ANY-A bitwise AND operation in which none of the
         bits in the value are present in the attribute (bitwise AND == False).
     include_geometry {Boolean}:
         Specifies whether geometry will be included in the results.

         * INCLUDE_GEOMETRY-Geometry will be included in the results.

         * EXCLUDE_GEOMETRY-Geometry will not be included in the results. This
         is the default.
         For enterprise geodatabases, this parameter requires ArcGIS Enterprise
         10.7 or later.
     result_types {String}:
         Specifies the types of results that will be returned.

         * CONNECTIVITY-Features that are connected through geometric
         coincidence or connectivity associations will be returned. This is the
         default.

         * FEATURES-Feature-level information will be returned.

         * CONTAINMENT_AND_ATTACHMENT_ASSOCIATIONS-Features that are associated
         through containment and structural attachment associations will be
         returned.
         For enterprise geodatabases, this parameter requires ArcGIS Enterprise
         10.7 or later.The containment and attachment associations option
         requires ArcGIS
         Enterprise 10.8.1 or later.
     result_network_attributes {String}:
         The network attributes that will be included in the results.For
         enterprise geodatabases, this parameter requires ArcGIS Enterprise
         10.7 or later.
     result_fields {Value Table}:
         Fields from a feature class that will be returned as results. The
         values of the field will be returned in the results for the features
         in the subnetwork.For enterprise geodatabases, this parameter requires
         ArcGIS Enterprise
         10.7 or later.
     include_domain_descriptions {Boolean}:
         Specifies whether domain descriptions will be included in the output
         .json to communicate domain mapping for controllers, featureElements,
         connectivity, and associations.

         * INCLUDE_DOMAIN_DESCRIPTIONS-Domain descriptions will be included in
         the results.

         * EXCLUDE_DOMAIN_DESCRIPTIONS-Domain descriptions will not be included
         in the results. This is the default.
         For enterprise geodatabases, this parameter requires ArcGIS Enterprise
         10.9.1 or later.

    OUTPUTS:
     out_json_file (File):
         The name and location of the .json file that will be generated."""
    ...

@gptooldoc("ExtendDiagram_un", None)
def ExtendDiagram(
    in_network_diagram_layer=..., ignore_traversability=..., extension_type=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """ExtendDiagram_un(in_network_diagram_layer, {ignore_traversability}, {extension_type})

       Extend a Network Diagram

    INPUTS:
     in_network_diagram_layer (Diagram Layer):
         Input Network Diagram Layer
     ignore_traversability {Boolean}:
         Ignore traversability
     extension_type {String}:
         Extension Type"""
    ...

@gptooldoc("GetDiagramTemplateNames_un", None)
def GetDiagramTemplateNames(
    in_utility_network=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """GetDiagramTemplateNames_un(in_utility_network)

       Get all the diagram template names defined in a utility network

    INPUTS:
     in_utility_network (Utility Network / Trace Network):
         Input Network"""
    ...

@gptooldoc("ImportDiagramTemplateDefinitions_un", None)
def ImportDiagramTemplateDefinitions(
    in_utility_network=..., template_name=..., ndbd_file=..., ndld_file=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """ImportDiagramTemplateDefinitions_un(in_utility_network, template_name, {ndbd_file}, {ndld_file})

       Import diagram template definitions from file(s)

    INPUTS:
     in_utility_network (Utility Network / Trace Network):
         Input Network
     template_name (String):
         Input Diagram Template
     ndbd_file {File}:
         Rule and Layout Definitions File
     ndld_file {File}:
         Diagram Layer Definition File"""
    ...

@gptooldoc("MakeDiagramLayer_un", None)
def MakeDiagramLayer(
    in_utility_network=..., network_diagram_name=..., out_layer=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """MakeDiagramLayer_un(in_utility_network, network_diagram_name, out_layer)

       Make a diagram layer

    INPUTS:
     in_utility_network (Utility Network / Trace Network / Utility Network Layer / Trace Network Layer):
         Input Network
     network_diagram_name (String):
         Network Diagram Name

    OUTPUTS:
     out_layer (Diagram Layer):
         Output Layer"""
    ...

@gptooldoc("OverwriteDiagram_un", None)
def OverwriteDiagram(
    in_network_diagram_layer=..., map=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """OverwriteDiagram_un(in_network_diagram_layer, map)

       Overwrite a Network Diagram

    INPUTS:
     in_network_diagram_layer (Diagram Layer):
         Input Network Diagram Layer
     map (Map):
         Input Map"""
    ...

@gptooldoc("PurgeTemporaryDiagrams_un", None)
def PurgeTemporaryDiagrams(
    in_utility_network=..., created_before=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """PurgeTemporaryDiagrams_un(in_utility_network, {created_before})

       Purge the temporary diagrams

    INPUTS:
     in_utility_network (Utility Network / Trace Network):
         Input Network
     created_before {Date}:
         Created Before"""
    ...

@gptooldoc("RepairNetworkTopology_un", None)
def RepairNetworkTopology(
    in_utility_network=..., out_log_file=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """RepairNetworkTopology_un(in_utility_network, {out_log_file})

       Verifies and repairs inconsistencies identified in the network
       topology system tables.

    INPUTS:
     in_utility_network (Utility Network / Utility Network Layer):
         The utility network that will be repaired.

    OUTPUTS:
     out_log_file {File}:
         The folder location and name of the file containing the discovered
         issues."""
    ...

@gptooldoc("ReshapeDiagramEdgesLayout_un", None)
def ReshapeDiagramEdgesLayout(
    in_network_diagram_layer=...,
    are_containers_preserved=...,
    reshape_type=...,
    is_path_preserved=...,
    offset_between_segment_absolute=...,
    breakpoint_absolute=...,
    shift_between_edge_absolute=...,
    angle_threshold=...,
    circular_arc_radius=...,
    circular_arc_position=...,
    run_async=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """ReshapeDiagramEdgesLayout_un(in_network_diagram_layer, {are_containers_preserved}, {reshape_type}, {is_path_preserved}, {offset_between_segment_absolute}, {breakpoint_absolute}, {shift_between_edge_absolute}, {angle_threshold}, {circular_arc_radius}, {circular_arc_position}, {run_async})

       Apply the reshape diagram edges layout to a diagram

    INPUTS:
     in_network_diagram_layer (Diagram Layer):
         Input Network Diagram Layer
     are_containers_preserved {Boolean}:
         Preserve container layout
     reshape_type {String}:
         Reshape Operation
     is_path_preserved {Boolean}:
         Preserve path
     offset_between_segment_absolute {Linear Unit}:
         Offset Between Edges
     breakpoint_absolute {Linear Unit}:
         Break Point Position
     shift_between_edge_absolute {Linear Unit}:
         Offset Between Edges
     angle_threshold {Double}:
         Angle Threshold
     circular_arc_radius {Linear Unit}:
         Circular Arc Radius
     circular_arc_position {String}:
         Circular Arc Position
     run_async {Boolean}:
         Run in asynchronous mode on the server"""
    ...

@gptooldoc("StoreDiagram_un", None)
def StoreDiagram(
    in_network_diagram_layer=..., out_name=..., access_right_type=..., tags=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """StoreDiagram_un(in_network_diagram_layer, out_name, {access_right_type}, {tags})

       Store a temporary diagram and alter its location and its access rights

    INPUTS:
     in_network_diagram_layer (Diagram Layer):
         Input Network Diagram Layer
     access_right_type {String}:
         Network Diagram Access Rights
     tags {String}:
         Tags (optional)

    OUTPUTS:
     out_name (Diagram Layer):
         Network Diagram Name"""
    ...

@gptooldoc("Trace_un", None)
def Trace(
    in_utility_network=...,
    trace_type=...,
    starting_points=...,
    barriers=...,
    domain_network=...,
    tier=...,
    target_tier=...,
    subnetwork_name=...,
    shortest_path_network_attribute_name=...,
    include_containers=...,
    include_content=...,
    include_structures=...,
    include_barriers=...,
    validate_consistency=...,
    condition_barriers=...,
    function_barriers=...,
    traversability_scope=...,
    filter_barriers=...,
    filter_function_barriers=...,
    filter_scope=...,
    filter_bitset_network_attribute_name=...,
    filter_nearest=...,
    nearest_count=...,
    nearest_cost_network_attribute=...,
    nearest_categories=...,
    nearest_assets=...,
    functions=...,
    propagators=...,
    output_assettypes=...,
    output_conditions=...,
    include_isolated_features=...,
    ignore_barriers_at_starting_points=...,
    include_up_to_first_spatial_container=...,
    result_types=...,
    selection_type=...,
    clear_all_previous_trace_results=...,
    trace_name=...,
    aggregated_points=...,
    aggregated_lines=...,
    aggregated_polygons=...,
    allow_indeterminate_flow=...,
    validate_locatability=...,
    use_trace_config=...,
    trace_config_name=...,
    out_json_file=...,
    run_async=...,
    include_geometry=...,
    include_domain_descriptions=...,
    result_network_attributes=...,
    result_fields=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """Trace_un(in_utility_network, {trace_type}, {starting_points}, {barriers}, {domain_network}, {tier}, {target_tier}, {subnetwork_name}, {shortest_path_network_attribute_name}, {include_containers}, {include_content}, {include_structures}, {include_barriers}, {validate_consistency}, {condition_barriers;condition_barriers...}, {function_barriers;function_barriers...}, {traversability_scope}, {filter_barriers;filter_barriers...}, {filter_function_barriers;filter_function_barriers...}, {filter_scope}, {filter_bitset_network_attribute_name}, {filter_nearest}, {nearest_count}, {nearest_cost_network_attribute}, {nearest_categories;nearest_categories...}, {nearest_assets;nearest_assets...}, {functions;functions...}, {propagators;propagators...}, {output_assettypes;output_assettypes...}, {output_conditions;output_conditions...}, {include_isolated_features}, {ignore_barriers_at_starting_points}, {include_up_to_first_spatial_container}, {result_types;result_types...}, {selection_type}, {clear_all_previous_trace_results}, {trace_name}, {aggregated_points}, {aggregated_lines}, {aggregated_polygons}, {allow_indeterminate_flow}, {validate_locatability}, {use_trace_config}, {trace_config_name}, {out_json_file}, {run_async}, {include_geometry}, {include_domain_descriptions}, {result_network_attributes;result_network_attributes...}, {result_fields;result_fields...})

       Returns network features in a utility network based on connectivity or
       traversability from the specified starting points.

    INPUTS:
     in_utility_network (Utility Network / Utility Network Layer):
         The utility network on which the trace will be run. When working with
         an enterprise geodatabase, an input utility network must be from a
         feature service; a utility network from a database connection is not
         supported.
     trace_type {String}:
         Specifies the type of trace that will be used.

         * CONNECTED-A connected trace that begins at one or more starting
         points and spans outward along connected features will be used. This
         is the default.

         * SUBNETWORK-A subnetwork trace that begins at one or more starting
         points and spans outward to encompass the extent of the subnetwork
         will be used.

         * SUBNETWORK_CONTROLLERS-A subnetwork controllers trace that locates
         sources and sinks on subnetwork controllers associated with a
         subnetwork will be used.

         * UPSTREAM-An upstream trace that discovers features upstream from a
         location in the network will be used.

         * DOWNSTREAM-A downstream trace that discovers features downstream
         from a location in the network will be used.

         * LOOPS-A loops trace that spans outward from the starting point based
         on connectivity will be used. Loops are areas of the network where
         flow direction is ambiguous.

         * SHORTEST_PATH-A shortest path trace that identifies the shortest
         path between two starting points will be used.

         * ISOLATION-An isolation trace that discovers features that isolate an
         area of a network will be used.
     starting_points {Table View / Feature Layer}:
         A table or feature class containing one or more records that represent
         the starting points of the trace. This feature class or table must
         include the FEATUREGLOBALID field to store information from the
         associated network feature. To view the specific format, create
         starting points using the Starting Points tool in the Trace Locations
         pane and view the schema of the UN_Temp_Starting_Points feature class
         stored in the default geodatabase.
     barriers {Table View / Feature Layer}:
         A table or feature class containing one or more features that
         represent the barriers of the trace that prevent the trace from
         traversing beyond that point. This feature class or table must include
         the FEATUREGLOBALID field to store information from the associated
         network feature. To view the specific format, create barriers using
         the Barriers tool in the Trace Locations pane and view the schema of
         the UN_Temp_Barriers feature class stored in the default geodatabase.
     domain_network {String}:
         The name of the domain network where the trace will be run. This
         parameter is required when running the subnetwork, subnetwork
         controllers, upstream, and downstream trace types.
     tier {String}:
         The name of the tier to start the trace. This parameter is required
         when running the subnetwork, subnetwork controllers, upstream, and
         downstream trace types.
     target_tier {String}:
         The name of the target tier to which the input tier flows. If this
         parameter is missing for upstream and downstream traces, those traces
         will stop when they reach the boundary of the starting subnetwork.
         This parameter can be used to allow these traces to continue either
         farther up or farther down the hierarchy.
     subnetwork_name {String}:
         The name of the subnetwork where the trace will be run. This parameter
         can be used when running a subnetwork trace type. If a subnetwork name
         is specified, the starting_points parameter is not required.
     shortest_path_network_attribute_name {String}:
         The network attribute that will be used to calculate the shortest
         path. When running a shortest path trace type, the shortest path is
         calculated using a numeric network attribute such as shape length.
         Both cost- and distance-based paths can be achieved. This parameter is
         required when running a shortest path trace.
     include_containers {Boolean}:
         Specifies whether the container features will be included in the trace
         results.

         * INCLUDE_CONTAINERS-Container features will be included in the trace
         results.

         * EXCLUDE_CONTAINERS-Container features will not be included in the
         trace results. This is the default.
     include_content {Boolean}:
         Specifies whether the trace will return content in containers in the
         results.

         * INCLUDE_CONTENT-Content in container features will be included in
         the trace results.

         * EXCLUDE_CONTENT-Content in container features will not be included
         in the trace results. This is the default.
     include_structures {Boolean}:
         Specifies whether structure features and objects will be included in
         the trace results.

         * INCLUDE_STRUCTURES-Structure features and objects will be included
         in the trace results.

         * EXCLUDE_STRUCTURES-Structure features and objects will not be
         included in the trace results. This is the default.
     include_barriers {Boolean}:
         Specifies whether the traversability barrier features will be included
         in the trace results. Traversability barriers are optional even if
         they have been preset in the subnetwork definition. This parameter
         does not apply to device features with terminals.

         * INCLUDE_BARRIERS-Traversability barrier features will be included in
         the trace results. This is the default.

         * EXCLUDE_BARRIERS-Traversability barrier features will not be
         included in the trace results.
     validate_consistency {Boolean}:
         Specifies whether an error will be returned if dirty areas are
         encountered in any of the traversed features. This is the only way to
         guarantee a trace is passing through features with consistent status
         in the network. To remove dirty areas, validate the network topology.

         * VALIDATE_CONSISTENCY-The trace will return an error if dirty areas
         are encountered in any of the traversed features. This is the default.

         * DO_NOT_VALIDATE_CONSISTENCY-The trace will return results regardless
         of whether dirty areas are encountered in any of the traversed
         features.
     condition_barriers {Value Table}:
         Sets a traversability barrier condition on features based on a
         comparison to a network attribute or check for a category string. A
         condition barrier uses a network attribute, an operator and a type,
         and an attribute value. For example, stop a trace when a feature has
         the Device Status attribute equal to the specific value of Open. When
         a feature meets this condition, the trace stops. If you're using more
         than one attribute, you can use the Combine using parameter to define
         an And or an Or condition. Condition barrier components are as
         follows:

         * Name-Filter by any network attribute defined in the system.

         * Operator-Choose from a number of operators.

         * Type-Choose a specific value or network attribute from the value
         that is specified in the name parameter.

         * Value-Provide a specific value for the input attribute type that
         would cause termination based on the operator value.

         * Combine Using-Set this value if you have multiple attributes to add.
         You can combine them using an And or an Or condition.
         The condition barriers operator value options are as follows:

         * IS_EQUAL_TO-The attribute is equal to the value.

         * DOES_NOT_EQUAL-The attribute is not equal to the value.

         * IS_GREATER_THAN-The attribute is greater than the value.

         * IS_GREATER_THAN_OR_EQUAL_TO-The attribute is greater than or equal
         to the value.

         * IS_LESS_THAN-The attribute is less than the value.

         * IS_LESS_THAN_OR_EQUAL_TO-The attribute is less than or equal to the
         value.

         * INCLUDES_THE_VALUES-A bitwise AND operation in which all bits in the
         value are present in the attribute (bitwise AND == value).

         * DOES_NOT_INCLUDE_THE_VALUES-A bitwise AND operation in which not all
         of the bits in the value are present in the attribute (bitwise AND !=
         value).

         * INCLUDES_ANY-A bitwise AND operation in which at least one bit in
         the value is present in the attribute (bitwise AND == True).

         * DOES_NOT_INCLUDE_ANY-A bitwise AND operation in which none of the
         bits in the value are present in the attribute (bitwise AND == False).
         The condition barriers Type value options are as follows:

         * SPECIFIC_VALUE-Filter by a specific value.

         * NETWORK_ATTRIBUTE-Filter by a network attribute.
         The condition barriers Combine Using value options are as follows:

         * AND-Combine the condition barriers.

         * OR-Use if either condition barrier is met.
     function_barriers {Value Table}:
         Sets a traversability barrier on features based on a function.
         Function barriers can be used to do such things as restrict how far
         the trace travels from the starting point, or set a maximum value to
         stop a trace. For example, the length of each line traveled is added
         to the total distance traveled so far. When the total length traveled
         reaches the value specified, the trace stops. Function barrier
         components are as follows:

         * Function-Choose from a number of calculation functions.

         * Attribute-Filter by any network attribute defined in the system.

         * Operator-Choose from a number of operators.

         * Value-Provide a specific value for the input attribute type that, if
         discovered, will cause the termination.

         * Use Local Values-Calculate values in each direction as opposed to an
         overall global value. Consider an example where a function barrier is
         configured that stops the trace once the sum of Shape length is
         greater than or equal to 4. Using the global value, after you have
         traversed any two edges with a value of 2, you will have reached a
         Shape length sum of 4, stopping the trace. If local values are used,
         when the traversal encounters a fork, the calculated values for each
         path along the branch are maintained separately. In this case, if the
         starting point is placed at the fork, the local values along each path
         are calculated separately and the trace will continue until a sum of 4
         is reached along each path.
         The function barrier function value options are as follows:

         * AVERAGE-The average of the input values.

         * COUNT-The number of features.

         * MAX-The maximum of the input values.

         * MIN-The minimum of the input values.

         * ADD-The sum of the values.

         * SUBTRACT-The difference between the values. Subnetwork controllers
         and loops trace types do not support the subtract function.
         The function barrier operator value options are as follows:

         * IS_EQUAL_TO-The function result is equal to the value.

         * DOES_NOT_EQUAL-The function result is not equal to the value.

         * IS_GREATER_THAN-The function result is greater than the value.

         * IS_GREATER_THAN_OR_EQUAL_TO-The function result is greater than or
         equal to the value.

         * IS_LESS_THAN-The function result is less than the value.

         * IS_LESS_THAN_OR_EQUAL_TO-The function result is less than or equal
         to the value.

         * INCLUDES_THE_VALUES-A bitwise AND operation in which all bits in the
         value are present in the attribute (bitwise AND == value).

         * DOES_NOT_INCLUDE_THE_VALUES-A bitwise AND operation in which not all
         of the bits in the value are present in the attribute (bitwise AND !=
         value).

         * INCLUDES_ANY-A bitwise AND operation in which at least one bit in
         the value is present in the attribute (bitwise AND == True).

         * DOES_NOT_INCLUDE_ANY-A bitwise AND operation in which none of the
         bits in the value are present in the attribute (bitwise AND == False).
         The function barrier Use Local Values options are as follows:

         * TRUE-Local values will be used. This is the default.

         * FALSE-Global values will be used.
     traversability_scope {String}:
         Specifies the type of traversability that will be applied.
         Traversability scope determines whether traversability is applied to
         junctions, edges, or both. For example, if a condition barrier is
         defined to stop the trace if Device Status is equal to Open and
         traversability scope is set to edges only, the trace will not
         stop-even if it encounters an open device-because Device Status is
         only applicable to junctions. In other words, this parameter indicates
         to the trace whether to ignore junctions, edges, or both.

         * BOTH_JUNCTIONS_AND_EDGES-Traversability will be applied to both
         junctions and edges. This is the default.

         * JUNCTIONS_ONLY-Traversability will be applied to junctions only.

         * EDGES_ONLY-Traversability will be applied to edges only.
     filter_barriers {Value Table}:
         Sets when a trace will stop for a specific category or network
         attribute. For example, stop a trace at features that have a life
         cycle status attribute that is equal to a certain value. This
         parameter is used to set a terminator based on a value of a network
         attribute that is defined in the system. If you're using more than one
         attribute, you can use the Combine Using option to define an And or an
         Or condition. Filter barrier components are as follows:

         * Name-Filter by category or any network attribute defined in the
         system.

         * Operator-Choose from a number of operators.

         * Type-Choose a specific value or network attribute from the value
         that is specified in the name parameter.

         * Value-Provide a specific value of the input attribute type that
         would cause termination based on the operator value.

         * Combine Using-Set this value if you have multiple attributes to add.
         You can combine them using an And or an Or condition.
         The filter barriers operator value options are as follows:

         * IS_EQUAL_TO-The attribute is equal to the value.

         * DOES_NOT_EQUAL-The attribute is not equal to the value.

         * IS_GREATER_THAN-The attribute is greater than the value.

         * IS_GREATER_THAN_OR_EQUAL_TO-The attribute is greater than or equal
         to the value.

         * IS_LESS_THAN-The attribute is less than the value.

         * IS_LESS_THAN_OR_EQUAL_TO-The attribute is less than or equal to the
         value.

         * INCLUDES_THE_VALUES-A bitwise AND operation in which all bits in the
         value are present in the attribute (bitwise AND == value).

         * DOES_NOT_INCLUDE_THE_VALUES-A bitwise AND operation in which not all
         of the bits in the value are present in the attribute (bitwise AND !=
         value).

         * INCLUDES_ANY-A bitwise AND operation in which at least one bit in
         the value is present in the attribute (bitwise AND == True).

         * DOES_NOT_INLCUDE_ANY-A bitwise AND operation in which none of the
         bits in the value are present in the attribute (bitwise AND == False).
         The filter barriers Type value options are as follows:

         * SPECIFIC_VALUE-Filter by a specific value.

         * NETWORK_ATTRIBUTE-Filter by a network attribute.
         The filter barriers Combine Using value options are as follows:

         * AND-Combine the condition barriers.

         * OR-Use if either condition barrier is met.
     filter_function_barriers {Value Table}:
         Filters the results of the trace for a specific category.
         Filter function barriers components are as follows:

         * Function-Choose from a number of calculation functions.

         * Attribute-Filter by any network attribute defined in the system.

         * Operator-Choose from a number of operators.

         * Value-Provide a specific value for the input attribute type that, if
         discovered, will cause the termination.

         * Use Local Values-Calculate values in each direction as opposed to an
         overall global value. For example, a function barrier that is
         calculating the sum of Shape length where the trace terminates if the
         value is greater than or equal to 4. In the global case, after you
         have traversed two edges with a value of 2, you will have already
         reached a shape length sum of 4, so the trace stops. If local values
         are used, the local values along each path change, or the trace
         continues.
         The filter function barriers function value options are as follows:

         * AVERAGE-The average of the input values.

         * COUNT-The number of features.

         * MAX-The maximum of the input values.

         * MIN-The minimum of the input values.

         * ADD-The sum of the values.

         * SUBTRACT-The difference between the values. Subnetwork controllers
         and loops trace types do not support the subtract function.
         The filter function barriers operator value options are as follows:

         * IS_EQUAL_TO-The attribute is equal to the value.

         * DOES_NOT_EQUAL-The attribute is not equal to the value.

         * IS_GREATER_THAN-The attribute is greater than the value.

         * IS_GREATER_THAN_OR_EQUAL_TO-The attribute is greater than or equal
         to the value.

         * IS_LESS_THAN-The attribute is less than the value.

         * IS_LESS_THAN_OR_EQUAL_TO-The attribute is less than or equal to the
         value.

         * INCLUDES_THE_VALUES-A bitwise AND operation in which all bits in the
         value are present in the attribute (bitwise AND == value).

         * DOES_NOT_INCLUDE_THE_VALUES-A bitwise AND operation in which not all
         of the bits in the value are present in the attribute (bitwise AND !=
         value).

         * INCLUDES_ANY-A bitwise AND operation in which at least one bit in
         the value is present in the attribute (bitwise AND == True).

         * DOES_NOT_INCLUDE_ANY-A bitwise AND operation in which none of the
         bits in the value are present in the attribute (bitwise AND == False).
         The filter function barriers Use Local Values options are as follows:

         * TRUE-Local values will be used. This is the default.

         * FALSE-Global values will be used.
     filter_scope {String}:
         Specifies whether the filter for a specific category will be applied
         to junctions, edges, or both. For example, if a filter barrier is
         defined to stop the trace if Device Status is equal to Open and
         traversability scope is set to edges only, the trace will not
         stop-even if the trace encounters an open device-because Device Status
         is only applicable to junctions. In other words, this parameter
         indicates to the trace whether to ignore junctions, edges, or both.

         * BOTH_JUNCTIONS_AND_EDGES-The filter will be applied to both
         junctions and edges. This is the default.

         * JUNCTIONS_ONLY-The filter will be applied to junctions only.

         * EDGES_ONLY-The filter will be applied to edges only.
     filter_bitset_network_attribute_name {String}:
         The name of the network attribute that will be used to filter by
         bitset. This parameter is only applicable to upstream, downstream, and
         loops trace types. This parameter can be used to add special logic
         during a trace so the trace more closely reflects real-world
         scenarios. For example, for a loops trace, the Phases current network
         attribute can determine if the loop is a true electrical loop (the
         same phase is energized all around the loop, that is, A) and return
         only real electrical loops for the trace results. An example for an
         upstream trace is when tracing an electric distribution network,
         specify a Phases current network attribute, and the trace results will
         only include valid paths that are specified in the network attribute,
         not all paths.
     filter_nearest {Boolean}:
         Specifies whether the k-nearest neighbors algorithm will be used to
         return a number of features of a certain type within a given distance.
         You can specify a count and a cost as well as a collection of
         categories, an asset type, or both.

         * FILTER_BY_NEAREST-The k-nearest neighbors algorithm will be used to
         return a number of features as specified in the nearest_count,
         nearest_cost_network_attribute, nearest_categories, or nearest_assets
         parameter.

         * DO_NOT_FILTER-The k-nearest neighbors algorithm will not be used to
         filter results. This is the default.
     nearest_count {Long}:
         The number of features to be returned when filter_nearest is
         FILTER_BY_NEAREST.
     nearest_cost_network_attribute {String}:
         The numeric network attribute that will be used to calculate nearness,
         cost, or distance when filter_nearest is FILTER_BY_NEAREST-for
         example, shape length.
     nearest_categories {String}:
         The categories that will be returned when filter_nearest is
         FILTER_BY_NEAREST-for example, protective.
     nearest_assets {String}:
         The asset groups and asset types that will be returned when
         filter_nearest is FILTER_BY_NEAREST-for example,
         ElectricDistributionDevice/Transformer/Step Down.
     functions {Value Table}:
         The calculation function or functions that will be applied to the
         trace results. Functions components are as follows:

         * Function-Choose from a number of calculation functions.

         * Attribute-Filter by any network attribute defined in the system.

         * Filter Name-Filter the function results by attribute name.

         * Filter Operator-Choose from a number of operators.

         * Filter Type-Choose from a number of filter types.

         * Filter Value-Provide a specific value for the input filter
         attribute.
         The functions Function value options are as follows:

         * AVERAGE-The average of the input values.

         * COUNT-The number of features.

         * MAX-The maximum of the input values.

         * MIN-The minimum of the input values.

         * ADD-The sum of the values.

         * SUBTRACT-The difference between the values.Subnetwork controllers
         and loops trace types do not support the subtract function.
         For example, a starting point feature has a value of 20. The next
         feature has a value of 30. If you are using the MINIMUM function, the
         result is 20. MAXIMUM is 30, ADD is 50, AVERAGE is 25, COUNT is 2, and
         SUBTRACT is -10.The Filter Operator value options are as follows:

         * IS_EQUAL_TO-The attribute is equal to the value.

         * DOES_NOT_EQUAL-The attribute is not equal to the value.

         * IS_GREATER_THAN-The attribute is greater than the value.

         * IS_GREATER_THAN_OR_EQUAL_TO-The attribute is greater than or equal
         to the value.

         * IS_LESS_THAN-The attribute is less than the value.

         * IS_LESS_THAN_OR_EQUAL_TO-The attribute is less than or equal to the
         value.

         * INCLUDES_THE_VALUES-A bitwise AND operation in which all bits in the
         value are present in the attribute (bitwise AND == value).

         * DOES_NOT_INCLUDE_THE_VALUES-A bitwise AND operation in which not all
         of the bits in the value are present in the attribute (bitwise AND !=
         value).

         * INCLUDES_ANY-A bitwise AND operation in which at least one bit in
         the value is present in the attribute (bitwise AND == True).

         * DOES_NOT_INCLUDE_ANY-A bitwise AND operation in which none of the
         bits in the value are present in the attribute (bitwise AND == False).
         The functions Filter Type value options are as follows:

         * SPECIFIC_VALUE-Filter by a specific value.

         * NETWORK_ATTRIBUTE-Filter by a network attribute.
     propagators {Value Table}:
         Specifies the network attributes to propagate as well as how that
         propagation will occur during a trace. Propagated class attributes
         denote the key values on subnetwork controllers that are disseminated
         to the rest of the features in the subnetwork. For example, in an
         electric distribution model, you can propagate the phase value.
         Propagators components are as follows:

         * Attribute-Filter by any network attribute defined in the system.

         * Substitution Attribute-Use a substituted value instead of bitset
         network attribute values. Substitutions are encoded based on the
         number of bits in the network attribute being propagated. A
         substitution is a mapping of each bit in phase to another bit. For
         example, for Phase AC, one substitution could map bit A to B, and bit
         C to null. In this example, the substitution for 1010 (Phase AC) is
         0000-0010-0000-0000 (512). The substitution captures the mapping so
         you know that Phase A was mapped to B and Phase C was mapped to null,
         and not the other way around (that is, Phase A was not mapped to null
         and Phase C was not mapped to B).

         * Function-Choose from a number of calculation functions.

         * Operator-Choose from a number of operators.

         * Value-Provide a specific value for the input attribute type that
         would cause termination based on the operator value.
         The propagators function value options are as follows:

         * PROPAGATED_BITWISE_AND-Compare the values from one feature to the
         next.

         * PROPAGATED_MIN-Get the minimum value.

         * PROPAGATED_MAX-Get the maximum value.
         The propagators operator value options are as follows:

         * IS_EQUAL_TO-The attribute is equal to the value.

         * DOES_NOT_EQUAL-The attribute is not equal to the value.

         * IS_GREATER_THAN-The attribute is greater than the value.

         * IS_GREATER_THAN_OR_EQUAL_TO-The attribute is greater than or equal
         to the value.

         * IS_LESS_THAN-The attribute is less than the value.

         * IS_LESS_THAN_OR_EQUAL_TO-The attribute is less than or equal to the
         value.

         * INCLUDES_THE_VALUES-A bitwise AND operation in which all bits in the
         value are present in the attribute (bitwise AND == value).

         * DOES_NOT_INCLUDE_THE_VALUES-A bitwise AND operation in which not all
         of the bits in the value are present in the attribute (bitwise AND !=
         value).

         * INCLUDES_ANY-A bitwise AND operation in which at least one bit in
         the value is present in the attribute (bitwise AND == True).

         * DOES_NOT_INCLUDE_ANY-A bitwise AND operation in which none of the
         bits in the value are present in the attribute (bitwise AND == False).
         This parameter is only available for Python.
     output_assettypes {String}:
         Filters the output asset types to be included in the results-for
         example, only return overhead transformers.
     output_conditions {Value Table}:
         The types of features that will be returned based on a network
         attribute or category. For example, in a trace configured to filter
         out everything but Tap features, any traced features that do not have
         the Tap category assigned to them are not included in the results. Any
         traced features that do are returned in the result selection set. If
         you're using more than one attribute, you can use the Combine Using
         option to define an And or an Or condition. Output conditions
         components are as follows:

         * Name-Filter by any network attribute defined in the system.

         * Operator-Choose from a number of operators.

         * Type-Choose a specific value or network attribute from the value
         that is specified in the name parameter.

         * Value-Provide a specific value of the input attribute type that
         would cause termination based on the operator value.

         * Combine Using-Set this value if you have multiple attributes to add.
         You can combine them using an And or an Or condition.
         The output conditions operator value options are as follows:

         * IS_EQUAL_TO-The attribute is equal to the value.

         * DOES_NOT_EQUAL-The attribute is not equal to the value.

         * IS_GREATER_THAN-The attribute is greater than the value.

         * IS_GREATER_THAN_OR_EQUAL_TO-The attribute is greater than or equal
         to the value.

         * IS_LESS_THAN-The attribute is less than the value.

         * IS_LESS_THAN_OR_EQUAL_TO-The attribute is less than or equal to the
         value.

         * INCLUDES_THE_VALUES-A bitwise AND operation in which all bits in the
         value are present in the attribute (bitwise AND == value).

         * DOES_NOT_INCLUDE_THE_VALUES-A bitwise AND operation in which not all
         of the bits in the value are present"""
    ...

@gptooldoc("UpdateDiagram_un", None)
def UpdateDiagram(
    in_diagrams=...,
    template_names=...,
    diagram_names=...,
    update_option=...,
    autolayout_option=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """UpdateDiagram_un(in_diagrams, {template_names;template_names...}, {diagram_names;diagram_names...}, {update_option}, {autolayout_option})

       Update Network Diagram

    INPUTS:
     in_diagrams (Utility Network / Trace Network / Utility Network Layer / Trace Network Layer / Diagram Layer):
         Input Network or Network Diagram Layer
     template_names {String}:
         Template Names
     diagram_names {String}:
         Diagram Names
     update_option {Boolean}:
         Update inconsistent diagrams only
     autolayout_option {Boolean}:
         Re-apply automatic layouts on the updated diagrams"""
    ...

@gptooldoc("UpdateIsConnected_un", None)
def UpdateIsConnected(
    in_utility_network=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """UpdateIsConnected_un(in_utility_network)

       Updates the IsConnected attribute on all the network features for the
       specified utility network based on connectivity.

    INPUTS:
     in_utility_network (Utility Network / Utility Network Layer):
         The utility network where the IsConnected attribute will be updated."""
    ...

@gptooldoc("UpdateSubnetwork_un", None)
def UpdateSubnetwork(
    in_utility_network=...,
    domain_network=...,
    tier=...,
    all_subnetworks_in_tier=...,
    subnetwork_name=...,
    continue_on_failure=...,
    condition_barriers=...,
    function_barriers=...,
    include_barriers=...,
    traversability_scope=...,
    propagators=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """UpdateSubnetwork_un(in_utility_network, domain_network, tier, all_subnetworks_in_tier, {subnetwork_name}, {continue_on_failure}, {condition_barriers;condition_barriers...}, {function_barriers;function_barriers...}, {include_barriers}, {traversability_scope}, {propagators;propagators...})

       Updates subnetwork information in the Subnetworks table, the
       SubnetLine feature class, and subnetwork system diagrams for the
       specified subnetworks.

    INPUTS:
     in_utility_network (Utility Network / Utility Network Layer):
         The utility network that contains the subnetwork.
     domain_network (String):
         The domain network that contains the subnetwork.
     tier (String):
         The tier that contains the subnetwork.
     all_subnetworks_in_tier (Boolean):
         Specifies whether all subnetworks in the tier will be updated. To
         update a subset of subnetworks in the tier, use the subnetwork_name
         parameter.

         * ALL_SUBNETWORKS_IN_TIER-All subnetworks in the tier will be updated.
         This option uses asynchronous processing to update the subnetworks
         using the system UtilityNetworkTools geoprocessing service. The
         service is reserved for utility network geoprocessing tasks and has a
         longer default timeout setting. This is the default.

         * SPECIFIC_SUBNETWORK-Only the subnetworks that are specified in the
         subnetwork_name parameter will be updated.
     subnetwork_name {String}:
         The name of the subnetwork that will be updated from the tier. If all
         subnetworks will be updated using the all_subnetworks_in_tier
         parameter, this parameter is ignored.
     continue_on_failure {Boolean}:
         Specifies whether the update process will stop if a subnetwork fails
         to update when updating multiple subnetworks.

         * CONTINUE_ON_FAILURE-The update process will not stop if a subnetwork
         failure occurs; it will continue.

         * STOP_ON_FAILURE-The update process will stop if a subnetwork failure
         occurs. This is the default.
     condition_barriers {Value Table}:
         Sets a traversability barrier condition on features based on a
         comparison to a network attribute or check for a category string. A
         condition barrier uses a network attribute, an operator and a type,
         and an attribute value. For example, stop a trace when a feature has
         the Device Status attribute equal to the specific value of Open. When
         a feature meets this condition, the trace stops. If you're using more
         than one attribute, you can use the Combine using parameter to define
         an And or an Or condition. Condition barrier components are as
         follows:

         * Name-Choose to filter by any network attribute defined in the
         system.

         * Operator-Choose from a number of different operators.

         * Type-Choose a specific value or network attribute from the value
         that is specified in the name parameter.

         * Value-Set a specific value of the input attribute type that will
         cause termination based on the operator value.

         * Combine Using-Set this value if you have multiple attributes to add.
         You can combine them using an And or an Or condition.
         The condition barrier Operator values are as follows:

         * IS_EQUAL_TO-The attribute is equal to the value.

         * DOES_NOT_EQUAL-The attribute is not equal to the value.

         * IS_GREATER_THAN-The attribute is greater than the value.

         * IS_GREATER_THAN_OR_EQUAL_TO-The attribute is greater than or equal
         to the value.

         * IS_LESS_THAN-The attribute is less than the value.

         * IS_LESS_THAN_OR_EQUAL_TO-The attribute is less than or equal to the
         value.

         * INCLUDES_THE_VALUES-A bitwise AND operation where all bits in the
         value are present in the attribute (bitwise AND == value).

         * DOES_NOT_INCLUDE_THE_VALUES-A bitwise AND operation where not all of
         the bits in the value are present in the attribute (bitwise AND !=
         value).

         * INCLUDES_ANY-A bitwise AND operation where at least one bit in the
         value is present in the attribute (bitwise AND == True).

         * DOES_NOT_INCLUDE_ANY-A bitwise AND operation where none of the bits
         in the value are present in the attribute (bitwise AND == False).
         The condition barrier type options are as follows:

         * SPECIFIC_VALUE-Filter by a specific value.

         * NETWORK_ATTRIBUTE-Filter by a network attribute.
         The Combine Using values are as follows:

         * AND-Combine the condition barriers.

         * OR-Use if either condition barrier is met.
     function_barriers {Value Table}:
         Sets a traversability barrier on features based on a function.
         Function barriers can be used to do such things as restrict how far
         the trace travels from the starting point, or set a maximum value to
         stop a trace. For example, the length of each line traveled is added
         to the total distance traveled so far. When the total length traveled
         reaches the value specified, the trace stops. Function barrier
         components are as follows:

         * Function-Choose from a number of different calculation functions.

         * Attribute-Choose to filter by any network attribute defined in the
         system.

         * Operator-Choose from a number of different operators.

         * Value-Set a specific value of the input attribute type that, if
         discovered, will cause the termination.

         * Use Local Values-Calculate values in each direction as opposed to an
         overall global value, for example, for a function barrier that is
         calculating the sum of Shape length in which the trace terminates if
         the value is greater than or equal to 4. In the global case, after you
         have traversed two edges with a value of 2, you have already reached a
         shape length sum of 4, so the trace stops. If local values are used,
         the local values along each path change, so the trace goes farther.

         * TRUE-Local values will be used.

         * FALSE-Global values will be used. This is the default.
         Possible values for the function barrier function options are as
         follows:

         * AVERAGE-The average of the input values.

         * COUNT-The number of features.

         * MAX-The maximum of the input values.

         * MIN-The minimum of the input values.

         * ADD-Add the values.

         * SUBTRACT-Subtract the values. Subnetwork controllers and loops trace
         types do not support the subtract function.
         For example, the starting point feature has a value of 20. The next
         feature has a value of 30. If you use the minimum function, the result
         is 20, maximum is 30, add is 50, average is 25, count is 2, and
         subtract is -10.The function barrier operator value options are as
         follows:

         * IS_EQUAL_TO-The attribute is equal to the value.

         * DOES_NOT_EQUAL-The attribute is not equal to the value.

         * IS_GREATER_THAN-The attribute is greater than the value.

         * IS_GREATER_THAN_OR_EQUAL_TO-The attribute is greater than or equal
         to the value.

         * IS_LESS_THAN-The attribute is less than the value.

         * IS_LESS_THAN_OR_EQUAL_TO-The attribute is less than or equal to the
         value.

         * INCLUDES_THE_VALUES-A bitwise AND operation where all bits in the
         value are present in the attribute (bitwise AND == value).

         * DOES_NOT_INCLUDE_THE_VALUES-A bitwise AND operation where not all of
         the bits in the value are present in the attribute (bitwise AND !=
         value).

         * INCLUDES_ANY-A bitwise AND operation where at least one bit in the
         value is present in the attribute (bitwise AND == True).

         * DOES_NOT_INCLUDE_ANY-A bitwise AND operation where none of the bits
         in the value are present in the attribute (bitwise AND == False).
     include_barriers {Boolean}:
         Specifies whether the traversability barrier features will be included
         in the trace results. Traversability barriers are optional even if
         they have been preset in the subnetwork definition.

         * INCLUDE_BARRIERS-Traversability barriers will be included in the
         trace results. This is the default.

         * EXCLUDE_BARRIERS-Traversability barriers will not be included in the
         trace results.
     traversability_scope {String}:
         Specifies the type of traversability that will be enforced.
         Traversability scope determines whether traversability will be
         enforced at junctions, edges, or both. For example, if a condition
         barrier is defined to stop the trace if DEVICESTATUS is equal to Open
         and traversability scope is set to edges only, the trace will not
         stop-even if the trace encounters an open device-because DEVICESTATUS
         is only applicable to junctions. In other words, this parameter
         indicates to the trace whether to ignore junctions, edges, or both.

         * BOTH_JUNCTIONS_AND_EDGES-Traversability will be applied to both
         junctions and edges. This is the default.

         * JUNCTIONS_ONLY-Traversability will be applied only to junctions.

         * EDGES_ONLY-Traversability will be applied only to edges.
     propagators {Value Table}:
         Specifies the network attributes to propagate as well as how that
         propagation will occur during a trace. Propagated class attributes
         denote the key values on subnetwork controllers that are disseminated
         to the rest of the features in the subnetwork. For example, in an
         electric distribution model, you can propagate the phase value.
         Propagators components are as follows:

         * Attribute-Filter by any network attribute defined in the system.

         * Substitution Attribute-Use a substituted value instead of bitset
         network attribute values. Substitutions are encoded based on the
         number of bits in the network attribute being propagated. A
         substitution is a mapping of each bit in phase to another bit. For
         example, for Phase AC, one substitution could map bit A to B, and bit
         C to null. In this example, the substitution for 1010 (Phase AC) is
         0000-0010-0000-0000 (512). The substitution captures the mapping so
         you know that Phase A was mapped to B and Phase C was mapped to null,
         and not the other way around (that is, Phase A was not mapped to null
         and Phase C was not mapped to B).

         * Function-Choose from a number of calculation functions.

         * Operator-Choose from a number of operators.

         * Value-Provide a specific value for the input attribute type that
         would cause termination based on the operator value.
         The propagators function value options are as follows:

         * PROPAGATED_BITWISE_AND-Compare the values from one feature to the
         next.

         * PROPAGATED_MIN-Get the minimum value.

         * PROPAGATED_MAX-Get the maximum value.
         The propagators operator value options are as follows:

         * IS_EQUAL_TO-The attribute is equal to the value.

         * DOES_NOT_EQUAL-The attribute is not equal to the value.

         * IS_GREATER_THAN-The attribute is greater than the value.

         * IS_GREATER_THAN_OR_EQUAL_TO-The attribute is greater than or equal
         to the value.

         * IS_LESS_THAN-The attribute is less than the value.

         * IS_LESS_THAN_OR_EQUAL_TO-The attribute is less than or equal to the
         value.

         * INCLUDES_THE_VALUES-A bitwise AND operation where all bits in the
         value are present in the attribute (bitwise AND == value).

         * DOES_NOT_INCLUDE_THE_VALUES-A bitwise AND operation where not all of
         the bits in the value are present in the attribute (bitwise AND !=
         value).

         * INCLUDES_ANY-A bitwise AND operation where at least one bit in the
         value is present in the attribute (bitwise AND == True).

         * DOES_NOT_INCLUDE_ANY-A bitwise AND operation where none of the bits
         in the value are present in the attribute (bitwise AND == False)."""
    ...

@gptooldoc("UpdateUtilityNetworkSchema_un", None)
def UpdateUtilityNetworkSchema(
    in_utility_network=..., operations=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """UpdateUtilityNetworkSchema_un(in_utility_network, operations)

       Updates the schema of a utility network based upon a Xml set of
       instructions

    INPUTS:
     in_utility_network (Utility Network / Utility Network Layer):
         Input Utility Network
     operations (File / String):
         Schema Operations"""
    ...

@gptooldoc("ValidateNetworkTopology_un", None)
def ValidateNetworkTopology(
    in_utility_network=..., extent=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """ValidateNetworkTopology_un(in_utility_network, {extent})

       Validates the network topology of a utility network after there have
       been edits to features in the network.

    INPUTS:
     in_utility_network (Utility Network / Utility Network Layer):
         The utility network for which the network topology will be validated.
     extent {Extent}:
         The geographical area for which to validate the network topology. This
         parameter is similar to the extent geoprocessing environment.

         * MAXOF-The maximum extent of all inputs will be used.

         * MINOF-The minimum area common to all inputs will be used.

         * DISPLAY-The extent is equal to the visible display.

         * Layer name-The extent of the specified layer will be used.

         * Extent object-The extent of the specified object will be used.

         * Space delimited string of coordinates-The extent of the specified
         string will be used. Coordinates are expressed in the order of x-min,
         y-min, x-max, y-max."""
    ...

@gptooldoc("VerifyNetworkTopology_un", None)
def VerifyNetworkTopology(
    in_utility_network=..., out_log_file=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """VerifyNetworkTopology_un(in_utility_network, {out_log_file})

       Verifies the network topology system tables and logs inconsistencies
       to an output log file.

    INPUTS:
     in_utility_network (Utility Network / Utility Network Layer):
         The utility network that will be verified for consistency.

    OUTPUTS:
     out_log_file {File}:
         The output log file containing the discovered issues."""
    ...

@gptooldoc("AddDomainNetwork_un", None)
def AddDomainNetwork(
    in_utility_network=...,
    domain_network_name=...,
    tier_definition=...,
    subnetwork_controller_type=...,
    domain_network_alias_name=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """AddDomainNetwork_un(in_utility_network, domain_network_name, tier_definition, subnetwork_controller_type, {domain_network_alias_name})

       Adds a domain network to a utility network.

    INPUTS:
     in_utility_network (Utility Network / Utility Network Layer):
         The utility network to which the domain network will be added.
     domain_network_name (String):
         The name of the new domain network. The domain network name will
         prefix the feature class names that are created. For example, a domain
         named ElectricDistribution would include a feature class named
         ElectricDistributionJunction.
     tier_definition (String):
         Specifies the tier definition for the new domain network.

         * HIERARCHICAL-The tier will be defined as hierarchical. In
         hierarchical domain networks, tiers are nested within one another, so
         features existing in subnetworks for a lower tier naturally
         participate in all higher tiers. For example, in a gas network, a
         valve isolation zone exists in a pressure zone, which in turn exists
         in a system zone. A feature in the isolation zone also exists in the
         pressure zone and in the system zone.

         * PARTITIONED-The tier will be defined as partitioned. Features in
         partitioned domain networks only exist in one tier. The relationship
         between tiers is ordered and linear. Features can exist in one or
         multiple subnetworks in one tier.
     subnetwork_controller_type (String):
         Specifies the subnetwork controller type for the new domain network.

         * SOURCE-The subnetwork controller type is a set of sources. A source
         is an origin of the delivered resource. For example, in an electric
         system, sources of electricity are power generating stations and
         substations.

         * SINK-The subnetwork controller type is a set of sinks. A sink is the
         destination of the gathered resource.
     domain_network_alias_name {String}:
         The alias name of the domain network. This optional parameter is used
         to give a more descriptive name to the domain network."""
    ...

@gptooldoc("AddNetworkAttribute_un", None)
def AddNetworkAttribute(
    in_utility_network=...,
    attribute_name=...,
    attribute_type=...,
    is_inline=...,
    is_apportionable=...,
    domain=...,
    is_overridable=...,
    is_nullable=...,
    is_substitution=...,
    network_attribute_to_substitute=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """AddNetworkAttribute_un(in_utility_network, attribute_name, attribute_type, {is_inline}, {is_apportionable}, {domain}, {is_overridable}, {is_nullable}, {is_substitution}, {network_attribute_to_substitute})

       Adds a network attribute to a utility network.

    INPUTS:
     in_utility_network (Utility Network / Utility Network Layer):
         The input utility network where the network attribute will be added.
     attribute_name (String):
         The name of the network attribute to add to the utility network.
     attribute_type (String):
         Specifies the data type of the network attribute.

         * SHORT-The field type will be short.

         * LONG-The field type will be long.

         * DOUBLE-The field type will be double.

         * DATE-The field type will be date.
     is_inline {Boolean}:
         Specifies whether the network attribute will be persisted in line. In-
         line network attributes are slightly more efficient, but the number of
         bits for user-defined in-line network attributes is limited to 25 per
         utility network. Store the most frequently used network attributes
         (for example, phase for electric networks, pressure for gas and water
         networks) in line if possible. The size of the bits is determined by
         the domain parameter. In-line attributes are only supported for
         integer network attributes (short, long).

         * INLINE-The attribute will be added internally to the topology,
         making retrieval more efficient.

         * NOT_INLINE-The attribute will be stored in an external table, and
         retrieval will require a call to the external weights table. This is
         the default.
     is_apportionable {Boolean}:
         Specifies whether the network attribute will be apportioned across
         multiple edges belonging to the same feature.For example, with the
         shape_length network attribute, if one line
         feature consists of five edge elements, and if the total length of
         that line feature is 100 feet, that attribute will be apportioned
         across all edges, with 20 feet for each. The distribution of the value
         depends on the percentage along each edge element with respect to the
         from point of the original feature.

         * APPORTIONABLE-The network attribute will be apportioned.

         * NOT_APPORTIONABLE-The network attribute will not be apportioned.
         This is the default.
     domain {String}:
         The domain with which the network attribute will be associated. This
         parameter is required when is_inline is INLINE. This domain is used to
         determine the number of bits to allocate for the in-line attribute and
         must be a coded value type. For example, the LifeCycleStatusDomain (0,
         Unknown | 1, In-Service | 2, Proposed | 3, Abandoned) domain has four
         entries, which means 2 bits are required to store the in-line
         attribute. The coded value domain must have sequential codes starting
         from 0.
     is_overridable {Boolean}:
         Specifies whether the current value stored in the topology
         will be overridden using an external override table. This parameter
         can be used, for example, to input live data from external systems,
         such as present position in the case of electric or pressure value in
         the case of gas. An example is a SCADA system pushing the updated
         switching positions of Device A to the override table of the
         DeviceStatus network attribute, which the topology engine then uses to
         override its current value of device status for Device A with the
         override value. This parameter is not used in the current
         release, and any value
         provided will be ignored. The functionality of this parameter is under
         development and will be applicable in a future release.

         * OVERRIDE-The current value stored in the topology will be
         overridden.

         * NOT_OVERRIDABLE-The current value stored in the topology will not be
         overridden. This is the default.
     is_nullable {Boolean}:
         Specifies whether the network attribute will support null values.

         * NULLABLE-The network attribute will support null values.

         * NOT_NULLABLE-The network attribute will not support null values.
         This is the default.
     is_substitution {Boolean}:
         Specifies whether the network attribute will be used as a
         substitution. Substitution network attributes allow a substituted
         value to be used instead of bitset network attribute values during a
         propagation in a trace operation.

         * SUBSTITUTION-The network attribute will be used as a substitution.

         * NOT_SUBSTITUTION-The network attribute will not be used as a
         substitution. This is the default.
     network_attribute_to_substitute {String}:
         The network attribute to be used as a substitution. Substitutions are
         encoded based on the number of bits in the network attribute being
         propagated. The network attribute must be in line and an integer field
         type less than or equal to 8 bits."""
    ...

@gptooldoc("AddNetworkCategory_un", None)
def AddNetworkCategory(
    in_utility_network=..., category_name=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """AddNetworkCategory_un(in_utility_network, category_name)

       Adds a network category to an existing utility network.

    INPUTS:
     in_utility_network (Utility Network / Utility Network Layer):
         The input utility network where the network category will be added.
     category_name (String):
         The name of the category to be created."""
    ...

@gptooldoc("AddRule_un", None)
def AddRule(
    in_utility_network=...,
    rule_type=...,
    from_class=...,
    from_assetgroup=...,
    from_assettype=...,
    to_class=...,
    to_assetgroup=...,
    to_assettype=...,
    from_terminal=...,
    to_terminal=...,
    via_class=...,
    via_assetgroup=...,
    via_assettype=...,
    via_terminal=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """AddRule_un(in_utility_network, rule_type, from_class, from_assetgroup, from_assettype, to_class, to_assetgroup, to_assettype, {from_terminal}, {to_terminal}, {via_class}, {via_assetgroup}, {via_assettype}, {via_terminal})

       Adds a rule to a utility network.

    INPUTS:
     in_utility_network (Utility Network / Utility Network Layer):
         The utility network for which the rule will be added.
     rule_type (String):
         Specifies the type of rule that will be created.

         * JUNCTION_JUNCTION_CONNECTIVITY-A junction-junction connectivity rule
         will be created allowing two point features to connect through a
         connectivity association (features are offset geometrically).

         * CONTAINMENT-A containment rule will be created in which the from
         parameters are the container and the to parameters are the contents in
         a containment association.

         * STRUCTURAL_ATTACHMENT-A structural attachment rule will be created
         in which the from parameters are the structure features and the to
         parameters are the attachment features in a structural attachment
         association.

         * JUNCTION_EDGE_CONNECTIVITY-A junction-edge connectivity rule will be
         created allowing edge and junction features to connect through
         geometric coincidence (features are at the same x,y,z location).

         * EDGE_JUNCTION_EDGE_CONNECTIVITY-An edge-junction-edge connectivity
         rule will be created allowing an edge to connect to either side of a
         junction feature.
     from_class (String):
         The from utility network feature class or table that will be included
         in the rule.Structural attachment and containment association rules
         require that
         the container or structure feature be in this parameter.When creating
         junction-edge and edge-junction-edge connectivity rules,
         this parameter must reference the junction.
     from_assetgroup (String):
         An asset group for the from_class parameter value to which the rule
         will apply.
     from_assettype (String):
         An asset type for the from_class parameter value to which the rule
         will apply.
     to_class (String):
         The to utility network feature class or table that will be included in
         the rule.Structural attachment and containment associations rules
         require that
         the content or attachment feature be in this parameter.When creating
         junction-edge and edge-junction-edge connectivity rules,
         the from_class parameter must reference the junction.
     to_assetgroup (String):
         An asset group for the to_class parameter value to which the rule will
         apply.
     to_assettype (String):
         An asset type for the to_class parameter value to which the rule will
         apply.
     from_terminal {String}:
         The from terminal to which the rule will apply. This will be a
         terminal in the from_class parameter value. When creating a
         connectivity rule for a feature with terminals to connect to another
         feature, the terminal side to connect from must be specified, for
         example, the high-side terminal on a transformer.This parameter is
         required if the asset type has terminals. It is
         ignored for structural attachment or containment rule types.
     to_terminal {String}:
         The to terminal to which the rule will apply. This will be a terminal
         in the to_class parameter value. When creating a connectivity rule for
         a feature to connect to another feature with terminals, the terminal
         side to connect to must be specified, for example, the low-side
         terminal on a transformer.This parameter is required if the asset type
         has terminals. It is
         ignored for structural attachment or containment rule types.
     via_class {String}:
         The junction utility network feature class or table to which the rule
         will apply. This parameter can only be specified when the rule_type
         parameter is set to EDGE_JUNCTION_EDGE_CONNECTIVITY, since three
         feature classes or tables are required to participate in edge-
         junction-edge connectivity.
     via_assetgroup {String}:
         An asset group of the via_class parameter value to which the rule will
         apply. This parameter can only be specified when the rule_type
         parameter is set to EDGE_JUNCTION_EDGE_CONNECTIVITY.
     via_assettype {String}:
         An asset type of the via_class parameter value to which the rule will
         apply. This parameter can only be specified when the rule_type
         parameter is set to EDGE_JUNCTION_EDGE_CONNECTIVITY.
     via_terminal {String}:
         The terminal from the via_class parameter value to which the rule will
         apply. This parameter can only be specified when the rule_type
         parameter is set to EDGE_JUNCTION_EDGE_CONNECTIVITY."""
    ...

@gptooldoc("AddTerminalConfiguration_un", None)
def AddTerminalConfiguration(
    in_utility_network=...,
    terminal_configuration_name=...,
    traversability_model=...,
    terminals_directional=...,
    terminals_bidirectional=...,
    valid_paths=...,
    default_path=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """AddTerminalConfiguration_un(in_utility_network, terminal_configuration_name, traversability_model, {terminals_directional;terminals_directional...}, {terminals_bidirectional;terminals_bidirectional...}, {valid_paths;valid_paths...}, {default_path})

       Adds a terminal configuration to an existing utility network.

    INPUTS:
     in_utility_network (Utility Network / Utility Network Layer):
         The input utility network to which the terminal configuration will be
         added.
     terminal_configuration_name (String):
         The name of the terminal configuration.
     traversability_model (String):
         Specifies the directionality of the terminal configuration. A
         directional traversability model means the flow for the terminal will
         only go in one direction. A bidirectional traversability model means
         the terminal allows flow in both directions.

         * DIRECTIONAL-Only one flow direction is permitted.

         * BIDIRECTIONAL-Both flow directions are permitted.
     terminals_directional {Value Table}:
         The name and directional flow of each directional terminal. A minimum
         of two terminals must be specified, and a maximum of eight can be
         specified. The name of each terminal cannot exceed 32 characters. This
         parameter is required if the traversability_model parameter value is
         DIRECTIONAL.

         * Name-Provide the name of the terminal.

         * Upstream-Indicate whether the terminal is upstream or
         downstream.

         * True-The terminal is upstream.

         * False-The terminal is downstream.
     terminals_bidirectional {Value Table}:
         The name of each bidirectional terminal. A minimum of two terminals
         must be specified, and a maximum of eight can be specified. The name
         of each terminal cannot exceed 32 characters. This parameter is
         required if the Directionality parameter value is Bidirectional
         (traversability_model = "BIDIRECTIONAL" in Python).
     valid_paths {Value Table}:
         The name or names and valid path or paths for the terminal
         configuration. For bidirectional traversability, this parameter is
         required if you have three or four terminals. If you are using
         directional traversability, one of the terminals must be upstream to
         have valid configurations. Valid paths must be created to indicate
         which path or paths in a device or junction object are valid for a
         resource to travel through. Provide a name for each valid path as well
         as a value.

         * Name-The name of the valid path.

         * Value-The value of the valid path.

         * All-Enter a value of All to create an option that indicates all
         paths are valid.

         * None-Enter a value of None to create an option that indicates that
         no paths are valid.

         * Terminal pair(s)-Enter a single or collection of terminal pairs.
         Enter a single terminal pair by specifying the path from one terminal
         to another separated by a hyphen, for example, A-B. Enter a collection
         of terminal pairs separated by a comma, for example, A-B, A-C.
     default_path {String}:
         The default path of the valid configurations. This will be assigned to
         new features that have this terminal configuration assigned to their
         asset type. If no valid paths have been specified, the default path
         All will be used.

         * ALL-All paths are valid. This is the default.

         * NONE-No paths are valid."""
    ...

@gptooldoc("AddTier_un", None)
def AddTier(
    in_utility_network=...,
    domain_network=...,
    name=...,
    rank=...,
    topology_type=...,
    tier_group_name=...,
    subnetwork_field_name=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """AddTier_un(in_utility_network, domain_network, name, rank, {topology_type}, {tier_group_name}, {subnetwork_field_name})

       Creates a new tier for a domain network in a utility network.

    INPUTS:
     in_utility_network (Utility Network / Utility Network Layer):
         The utility network that contains the domain network where the tier
         will be added.
     domain_network (String):
         The domain network where the tier will be created.
     name (String):
         The name of the new tier. The name must be unique in the entire
         utility network.
     rank (Long):
         The rank of the tier being added. The highest rank is the number 1.
     topology_type {String}:
         Specifies the topology type for the new tier. Subnetworks with radial
         and mesh topology types both support one or more subnetwork
         controllers. This parameter is disabled on the tool dialog box if the
         input domain network was created with a hierarchical tier definition
         and the topology type defaults to mesh. If the input domain network
         was created with a hierarchical tier definition, the default topology
         type is MESH. If the input domain network was created with a
         partitioned tier definition, the topology type parameter is
         required.For tracing or subnetwork management, this parameter does not
         currently provide a difference in behavior. The functionality of this
         parameter is under development and will be applicable in a future
         release.

         * RADIAL-The subnetworks will have a radial topology type.

         * MESH-The subnetworks will have a mesh topology type. This is the
         default topology type for a tier created with a hierarchical tier
         definition.
     tier_group_name {String}:
         The existing tier group to which the new tier will be added. This
         parameter is required for domain networks with a hierarchical tier
         definition.
     subnetwork_field_name {String}:
         The name of the field where the subnetwork names for this tier will be
         stored. This is a system-maintained field that will be created the
         first time a tier is added to a tier group and reused for any
         additional tiers. For example, you have two tier groups: Distribution
         and Transmission. When you add a tier named system to the Distribution
         group and specify the subnetwork field name to be systemsubnet, the
         field is created. Next, you add a second tier named system to the
         Transmission group. This parameter will detect that the systemsubnet
         field should be used as the subnetwork field name. This parameter is
         required for hierarchical tier types."""
    ...

@gptooldoc("AddTierGroup_un", None)
def AddTierGroup(
    in_utility_network=..., domain_network=..., name=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """AddTierGroup_un(in_utility_network, domain_network, name)

       Adds a tier group to a domain network in a utility network.

    INPUTS:
     in_utility_network (Utility Network / Utility Network Layer):
         The utility network that contains the domain network where the tier
         group will be added.
     domain_network (String):
         The name of the domain network to which the tier group will be added.
         Tier groups can only be added to domain networks that have a
         hierarchical tier definition.
     name (String):
         A unique name for the new tier group. The name can be a maximum of 64
         characters in length."""
    ...

@gptooldoc("CreateUtilityNetwork_un", None)
def CreateUtilityNetwork(
    in_feature_dataset=...,
    in_utility_network_name=...,
    service_territory_feature_class=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """CreateUtilityNetwork_un(in_feature_dataset, in_utility_network_name, service_territory_feature_class)

       Creates a utility network in an enterprise, file, or mobile
       geodatabase feature dataset.

    INPUTS:
     in_feature_dataset (Feature Dataset):
         The geodatabase feature dataset in which the utility network and
         schema will be created.
     in_utility_network_name (String):
         The name of the utility network that will be created.
     service_territory_feature_class (Polygon):
         The existing polygon feature class that will be used to create the
         utility network's geographical extent. Utility network features cannot
         be created outside of this extent.The feature class must be z- and
         m-enabled."""
    ...

@gptooldoc("DeleteNetworkCategory_un", None)
def DeleteNetworkCategory(
    in_utility_network=..., category_name=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """DeleteNetworkCategory_un(in_utility_network, category_name)

       Deletes a network category in a utility network.

    INPUTS:
     in_utility_network (Utility Network / Utility Network Layer):
         The utility network that contains the network category to be deleted.
     category_name (String):
         The name of the network category to delete."""
    ...

@gptooldoc("DeleteRule_un", None)
def DeleteRule(
    in_utility_network=..., rule_type=..., rule_desc=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """DeleteRule_un(in_utility_network, rule_type, {rule_desc})

       Permanently deletes a rule from a utility network.

    INPUTS:
     in_utility_network (Utility Network / Utility Network Layer):
         The utility network for which the rule will be removed.
     rule_type (String):
         The type of rule being deleted.

         * ALL-Delete all rules.

         * JUNCTION_JUNCTION_CONNECTIVITY-Delete a junction-junction
         connectivity association rule.

         * CONTAINMENT-Delete a containment association rule.

         * STRUCTURAL_ATTACHMENT-Delete a structural attachment association
         rule.

         * JUNCTION_EDGE_CONNECTIVITY-Delete a junction-edge connectivity rule.

         * EDGE_JUNCTION_EDGE_CONNECTIVITY-Delete an edge-junction-edge
         connectivity rule.
     rule_desc {String}:
         Specifies which rule to remove. This includes the rule ID and
         the description of the rule. You can find the rule ID by
         browsing the Rules section of the Network
         Properties, which is available on the Layer Properties dialog box."""
    ...

@gptooldoc("DeleteTerminalConfiguration_un", None)
def DeleteTerminalConfiguration(
    in_utility_network=..., terminal_configuration_name=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """DeleteTerminalConfiguration_un(in_utility_network, terminal_configuration_name)

       Deletes a terminal configuration from a utility network.

    INPUTS:
     in_utility_network (Utility Network / Utility Network Layer):
         The utility network that contains the terminal configuration to be
         deleted.
     terminal_configuration_name (String):
         The name of the terminal configuration to delete."""
    ...

@gptooldoc("DisableNetworkTopology_un", None)
def DisableNetworkTopology(
    in_utility_network=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """DisableNetworkTopology_un(in_utility_network)

       Disables the network topology for an existing utility network.

    INPUTS:
     in_utility_network (Utility Network / Utility Network Layer):
         The utility network where the network topology will be disabled."""
    ...

@gptooldoc("EnableNetworkTopology_un", None)
def EnableNetworkTopology(
    in_utility_network=..., max_number_of_errors=..., only_generate_errors=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """EnableNetworkTopology_un(in_utility_network, {max_number_of_errors}, {only_generate_errors})

       Enables a network topology for a utility network.

    INPUTS:
     in_utility_network (Utility Network / Utility Network Layer):
         The utility network for which the network topology will be enabled.
     max_number_of_errors {Long}:
         The maximum number of errors that can be generated before the process
         of enabling the network topology will stop. Errors will be recorded in
         the dirty areas sublayer. The default value is 10000.Increasing the
         maximum number of errors value will increase the length
         of time to enable the topology. Setting a value higher than the
         default value of 10000 is not recommended.
     only_generate_errors {Boolean}:
         Specifies whether the topology will be enabled or only network errors
         will be generated.

         * ONLY_ERRORS-The utility network will only be evaluated for network
         errors. The topology will not be enabled. If you are working with an
         enterprise geodatabase, the data cannot be registered as versioned.
         This allows you to inspect and fix errors in the network until you are
         ready to enable the topology.

         * ENABLE_TOPO-The topology will be enabled and any existing errors
         will generate dirty areas with errors. This is the default."""
    ...

@gptooldoc("ExportAssociations_un", None)
def ExportAssociations(
    in_utility_network=..., association_type=..., out_csv_file=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """ExportAssociations_un(in_utility_network, association_type, out_csv_file)

       Exports associations from a utility network to a comma-separated-
       values file (.csv). This tool can be used in conjunction with the
       Import Associations tool.

    INPUTS:
     in_utility_network (Utility Network / Utility Network Layer):
         The utility network containing the associations to export.
     association_type (String):
         Specifies the type of association to export.

         * ALL-All association types in the utility network will be exported to
         a .csv file.

         * JUNCTION_JUNCTION_CONNECTIVITY-Connectivity associations allowing
         two junction subtypes to connect via a connectivity association
         (features are offset geometrically) will be exported to a .csv file.

         * CONTAINMENT-The containment association type will be exported to a
         .csv file.

         * STRUCTURAL_ATTACHMENT-The structural attachment association type
         will be exported to a .csv file.

         * JUNCTION_EDGE_FROM_CONNECTIVITY-The junction-edge (from side of
         edge) connectivity association type will be exported to a .csv file.

         * JUNCTION_EDGE_MIDSPAN_CONNECTIVITY-The junction-edge (midspan)
         connectivity association type will be exported to a .csv file.

         * JUNCTION_EDGE_TO_CONNECTIVITY-The junction-edge (to side of edge)
         connectivity association type will be exported to a .csv file.

    OUTPUTS:
     out_csv_file (File):
         The name and location of the .csv file that will be generated."""
    ...

@gptooldoc("ExportRules_un", None)
def ExportRules(
    in_utility_network=..., rule_type=..., out_csv_file=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """ExportRules_un(in_utility_network, rule_type, out_csv_file)

       Exports connectivity, structural attachment, and containment rules
       from a utility network into a comma-separated values file.

    INPUTS:
     in_utility_network (Utility Network / Utility Network Layer):
         The utility network to export the rules from.
     rule_type (String):
         The type of rule to export.

         * ALL-All the rules in the utility network will be exported.

         * JUNCTION_JUNCTION_CONNECTIVITY-Junction-junction connectivity
         association rules will be exported.

         * JUNCTION_EDGE_CONNECTIVITY-Junction-edge connectivity rules will be
         exported.

         * CONTAINMENT-Containment association rules will be exported.

         * STRUCTURAL_ATTACHMENT-Structural attachment association rules will
         be exported.

         * EDGE_JUNCTION_EDGE_CONNECTIVITY-Edge-junction-edge connectivity
         association rules will be exported.

    OUTPUTS:
     out_csv_file (File):
         The folder location and name of the .csv file to be created."""
    ...

@gptooldoc("ExportSubnetworkControllers_un", None)
def ExportSubnetworkControllers(
    in_utility_network=..., out_csv_file=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """ExportSubnetworkControllers_un(in_utility_network, out_csv_file)

       Exports subnetwork controllers from a utility network to a .csv file.

    INPUTS:
     in_utility_network (Utility Network / Utility Network Layer):
         The utility network from which subnetwork controllers will be
         exported.

    OUTPUTS:
     out_csv_file (File):
         The location and name of the .csv file to be generated."""
    ...

@gptooldoc("ImportAssociations_un", None)
def ImportAssociations(
    in_utility_network=..., association_type=..., csv_file=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """ImportAssociations_un(in_utility_network, association_type, csv_file)

       Imports associations from a comma-separated values file (.csv) into an
       existing utility network. This tool can be used in conjunction with
       the Export Associations tool.

    INPUTS:
     in_utility_network (Utility Network / Utility Network Layer):
         The utility network to which the associations will be imported.
     association_type (String):
         Specifies the type of association that will be imported.

         * ALL-All association types will be imported.

         * JUNCTION_JUNCTION_CONNECTIVITY-The junction-junction connectivity
         association type will be imported.

         * CONTAINMENT-The containment association type will be imported.

         * STRUCTURAL_ATTACHMENT-The structural attachment association type
         will be imported.

         * JUNCTION_EDGE_FROM_CONNECTIVITY-The junction-edge connectivity (from
         side of edge) association type will be imported.

         * JUNCTION_EDGE_MIDSPAN_CONNECTIVITY-The junction-edge connectivity
         (midspan) association type will be imported.

         * JUNCTION_EDGE_TO_CONNECTIVITY-The junction-edge connectivity (to
         side of edge) association type will be imported.
     csv_file (File):
         The .csv file from which the associations will be imported."""
    ...

@gptooldoc("ImportRules_un", None)
def ImportRules(
    in_utility_network=..., rule_type=..., csv_file=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """ImportRules_un(in_utility_network, rule_type, csv_file)

       Import connectivity, structural attachment, and containment rules from
       a comma-separated values file into an existing utility network.

    INPUTS:
     in_utility_network (Utility Network / Utility Network Layer):
         Specifies the utility network to import the rules to.
     rule_type (String):
         Specifies the type of rules to import.

         * ALL-One or more types of rules

         * JUNCTION_JUNCTION_CONNECTIVITY-Junction-junction connectivity
         association rules

         * JUNCTION_EDGE_CONNECTIVITY-Junction-edge connectivity rules

         * CONTAINMENT-Containment association rules

         * STRUCTURAL_ATTACHMENT-Structural attachment association rules

         * EDGE_JUNCTION_EDGE_CONNECTIVITY-Edge-junction-edge association
         rules
     csv_file (File):
         Specifies the .csv file containing the rules to import."""
    ...

@gptooldoc("ImportSubnetworkControllers_un", None)
def ImportSubnetworkControllers(
    in_utility_network=..., csv_file=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """ImportSubnetworkControllers_un(in_utility_network, csv_file)

       Imports subnetwork controllers from a .csv file into a utility
       network.

    INPUTS:
     in_utility_network (Utility Network / Utility Network Layer):
         The utility network to which the subnetwork controllers will be
         imported.
     csv_file (File):
         The .csv file containing the subnetwork controllers to import."""
    ...

@gptooldoc("SetAssociationRole_un", None)
def SetAssociationRole(
    in_utility_network=...,
    domain_network=...,
    featureclass=...,
    assetgroup=...,
    assettype=...,
    association_role_type=...,
    association_deletion_semantics=...,
    view_scale=...,
    split_content=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """SetAssociationRole_un(in_utility_network, domain_network, featureclass, assetgroup, assettype, association_role_type, association_deletion_semantics, {view_scale}, {split_content})

       Alters the association role assigned to a network feature class or
       table at the asset type level.

    INPUTS:
     in_utility_network (Utility Network / Utility Network Layer):
         The utility network that contains the asset type with an association
         role to set.
     domain_network (String):
         The domain network that contains the asset type with an association
         role to set.
     featureclass (String):
         The utility network feature class or table where the association role
         will be set.
     assetgroup (String):
         The asset group that contains the asset type.
     assettype (String):
         The asset type that the association role will be set for.
     association_role_type (String):
         Specifies the type of association role that will be assigned to the
         asset type.

         * CONTAINER-The container association role type will be assigned.
         Features or objects of this role type can contain other features and
         objects as content.

         * STRUCTURE-The structure association role type will be assigned.
         Features or objects of this role type can have other features and
         objects attached to them.

         * NONE-No role type will be assigned. These are features or objects
         that are neither a container nor a structure but do connect to other
         structures.
     association_deletion_semantics (String):
         Specifies the deletion semantics for the network features, which
         defines how content or attachment network features will be managed
         when the container or structure is deleted. This applies to both
         container and structure association roles.

         * CASCADE-When the container or structure is deleted, all content or
         attachment network features will be deleted.

         * SET_TO_NONE-When a container or structure is deleted, its content
         or attachment network features are not deleted, but are removed from
         the containment or structural attachment association.

         * RESTRICTED-If content or attachment network features exist, an
         error will be returned when attempting to delete the container or
         structure. The content or attachment network features must be removed
         before deleting the container or structure.
     view_scale {Double}:
         The scale at which containment mode will be entered to edit features
         participating in the container. For example, setting the view scale to
         5 means that when you enter containment mode of the container feature,
         the scale will be 1:5. Units are based on the utility network units,
         which are located on the Source tab of the utility network layer
         properties pane. This property does not apply to junction and edge
         objects.
     split_content {Boolean}:
         Specifies whether the associated content of a container will be split
         if the container feature is split. This parameter is only available if
         the association role is container and is only applicable for line
         features.

         * SPLIT-The container's content will be split if the container feature
         is split. If a parallel content line feature is found, the content is
         also split and each section will be contained by the closest container
         feature. If the content line is not parallel, the content will be
         contained by the container feature that is closest to it.

         * DO_NOT_SPLIT-The container's content will not be split if the
         container feature is split. If a parallel content line feature is
         found, the content will be contained by both sections of the container
         feature. If the content line is not parallel, the content will be
         contained by the container feature that is closest to it. This is the
         default."""
    ...

@gptooldoc("SetEdgeConnectivity_un", None)
def SetEdgeConnectivity(
    in_utility_network=...,
    domain_network=...,
    line_featureclass=...,
    assetgroup=...,
    assettype=...,
    edge_connectivity=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """SetEdgeConnectivity_un(in_utility_network, domain_network, line_featureclass, assetgroup, assettype, edge_connectivity)

       Defines how features will connect to a line or edge object of a given
       asset type.

    INPUTS:
     in_utility_network (Utility Network / Utility Network Layer):
         The utility network that contains the asset type with the edge
         connectivity to set.
     domain_network (String):
         The domain network that contains the asset type with the edge
         connectivity to set.
     line_featureclass (String):
         The name of the input feature class or table that contains the asset
         type with the edge connectivity to set.
     assetgroup (String):
         The asset group that contains the asset type with the edge
         connectivity to set.
     assettype (String):
         The asset type that requires the edge connectivity to set.
     edge_connectivity (String):
         Specifies the edge connectivity type that will be assigned to the
         asset type.

         * ANY_VERTEX-Features will connect anywhere along the edge including
         end vertices.

         * END_VERTEX-Features will only connect to the end vertex of an edge."""
    ...

@gptooldoc("SetNetworkAttribute_un", None)
def SetNetworkAttribute(
    in_utility_network=...,
    network_attribute=...,
    domain_network=...,
    featureclass=...,
    field=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """SetNetworkAttribute_un(in_utility_network, network_attribute, domain_network, featureclass, field)

       Assigns a network attribute to a feature class or table at the asset
       type level to be used during tracing operations.

    INPUTS:
     in_utility_network (Utility Network / Utility Network Layer):
         The utility network that contains the network attribute to set.
     network_attribute (String):
         The network attribute to be assigned to the field in the feature class
         or table.
     domain_network (String):
         The domain network that contains the feature class or table that will
         have a network attribute set on it.
     featureclass (String):
         The input feature class or table that contains the field that will be
         used to set the network attribute.
     field (String):
         An existing field that will be assigned the network attribute. The
         field data type must match the data type of the network attribute. For
         example, if the network attribute is a short integer type, the field
         must also be a short integer type. Network attributes that do not
         support nulls can only be assigned to fields that do not allow null
         values."""
    ...

@gptooldoc("SetNetworkCategory_un", None)
def SetNetworkCategory(
    in_utility_network=...,
    domain_network=...,
    featureclass=...,
    assetgroup=...,
    assettype=...,
    category=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """SetNetworkCategory_un(in_utility_network, domain_network, featureclass, assetgroup, assettype, {category;category...})

       Assigns a network category to a feature class or table at the asset
       type level to be used during tracing operations.

    INPUTS:
     in_utility_network (Utility Network / Utility Network Layer):
         The utility network that contains the network category.
     domain_network (String):
         The domain network in the utility network that contains the network
         category.
     featureclass (String):
         The utility network feature class or table to which the asset type
         belongs.
     assetgroup (String):
         The asset group to which the asset type belongs.
     assettype (String):
         The asset type to alter the category configuration.
     category {String}:
         The categories to be assigned to the asset type. The categories that
         are specified for this parameter will replace the current categories
         that are assigned to the asset type. To unassign a network category
         from an asset type, do not specify a category for this parameter.The
         Subnetwork Controller system-provided network category is only
         available for asset types in the device feature class and junction
         object table. In a domain network with a partitioned tier definition,
         the selected asset type must also have a directional terminal
         configuration assigned with a minimum of one upstream and one
         downstream terminal."""
    ...

@gptooldoc("SetSubnetworkDefinition_un", None)
def SetSubnetworkDefinition(
    in_utility_network=...,
    domain_network=...,
    tier_name=...,
    support_disjoint_subnetwork=...,
    valid_devices=...,
    valid_subnetwork_controller=...,
    valid_lines=...,
    aggregated_line=...,
    diagram_template=...,
    summaries=...,
    condition_barriers=...,
    function_barriers=...,
    include_barriers=...,
    traversability_scope=...,
    propagators=...,
    update_structure_features=...,
    update_container_features=...,
    edit_mode_for_default_version=...,
    edit_mode_for_named_version=...,
    valid_junctions=...,
    valid_junction_objects=...,
    valid_junction_object_subnetwork_controller=...,
    valid_edge_objects=...,
    manage_subnetwork_isdirty=...,
    include_containers=...,
    include_content=...,
    include_structures=...,
    validate_locatability=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """SetSubnetworkDefinition_un(in_utility_network, domain_network, tier_name, support_disjoint_subnetwork, {valid_devices;valid_devices...}, {valid_subnetwork_controller;valid_subnetwork_controller...}, {valid_lines;valid_lines...}, {aggregated_line;aggregated_line...}, {diagram_template;diagram_template...}, {summaries;summaries...}, {condition_barriers;condition_barriers...}, {function_barriers;function_barriers...}, {include_barriers}, {traversability_scope}, {propagators;propagators...}, {update_structure_features}, {update_container_features}, {edit_mode_for_default_version}, {edit_mode_for_named_version}, {valid_junctions;valid_junctions...}, {valid_junction_objects;valid_junction_objects...}, {valid_junction_object_subnetwork_controller;valid_junction_object_subnetwork_controller...}, {valid_edge_objects;valid_edge_objects...}, {manage_subnetwork_isdirty}, {include_containers}, {include_content}, {include_structures}, {validate_locatability})

       Sets the domain network tier's properties for a subnetwork in a
       utility network.

    INPUTS:
     in_utility_network (Utility Network / Utility Network Layer):
         The input utility network that contains the tier's subnetwork.
     domain_network (String):
         The domain network that contains the tier.
     tier_name (String):
         The name of the tier that contains the subnetwork.
     support_disjoint_subnetwork (Boolean):
         Specifies whether the input tier will support disjoint subnetworks.
         Disjoint subnetworks are two or more subnetworks that belong to the
         same tier and have the same subnetwork name but are not traversable.
         This parameter is only available for tiers in domain networks with a
         partitioned tier definition. This parameter is set to SUPPORT_DISJOINT
         for tiers in a domain network with a hierarchical tier definition to
         support disjoint subnetworks.

         * SUPPORT_DISJOINT-The input tier will support disjoint subnetworks.

         * NO_DISJOINT-The input tier will not support disjoint subnetworks.
         This is the default except as noted.
     valid_devices {String}:
         The asset group/asset type pairs identified as valid devices for the
         subnetwork.
     valid_subnetwork_controller {String}:
         The asset group/asset type pairs identified as valid device subnetwork
         controllers in the subnetwork.
     valid_lines {String}:
         The asset group/asset type pairs identified as valid lines for the
         subnetwork.
     aggregated_line {String}:
         The valid lines with geometry that will be aggregated to generate the
         SubnetLine features. This list is a subset of the values specified in
         the valid_lines parameter.
     diagram_template {String}:
         The templates that will be used to generate subnetwork system diagrams
         for each subnetwork.
     summaries {Value Table}:
         Sets the summary field to store function results when inserting or
         updating SubnetLine features. Summaries components are as
         follows:

         * Function-Choose from a number of calculation functions.

         * Attribute-Filter by any network attribute defined in the system.

         * Filter Name-Filter the function results by attribute name.

         * Filter Operator-Choose from a number of operators.

         * Filter Type-Choose from a number of filter types.

         * Filter Value-Provide a specific value for the input filter
         attribute.

         * Summary Attribute-The field in the SubnetLine feature class that
         will persist the function result. Depending on the selected function
         and network attribute type, only the applicable type of user-added
         subnetwork attributes will be valid for this parameter. If a field to
         store the summary result does not exist in the SubnetLine feature
         class, the Add Field tool can be used to create one. A field can only
         support the result of one summary; each summary requires its own field
         in the SubnetLine feature class. See the Usages section for a matrix
         of valid field types for the summary attribute field based on the
         specified function.
         The summaries Function value options are as follows:

         * AVERAGE-The average of the input values.

         * COUNT-The number of features.

         * MAX-The maximum of the input values.

         * MIN-The minimum of the input values.

         * ADD-The sum of the input values.

         * SUBTRACT-The difference of the input values. Subnetwork controllers
         and loops trace types do not support the subtract function.
         The summaries Filter Operator value options are as follows:

         * IS_EQUAL_TO-The attribute is equal to the value.

         * DOES_NOT_EQUAL-The attribute is not equal to the value.

         * IS_GREATER_THAN-The attribute is greater than the value.

         * IS_GREATER_THAN_OR_EQUAL_TO-The attribute is greater than or equal
         to the value.

         * IS_LESS_THAN-The attribute is less than the value.

         * IS_LESS_THAN_OR_EQUAL_TO-The attribute is less than or equal to the
         value.

         * INCLUDES_THE_VALUES-A bitwise AND operation in which all bits in the
         value are present in the attribute (bitwise AND == value).

         * DOES_NOT_INCLUDE_THE_VALUES-A bitwise AND operation in which not all
         of the bits in the value are present in the attribute (bitwise AND !=
         value).

         * INCLUDES_ANY-A bitwise AND operation in which at least one bit in
         the value is present in the attribute (bitwise AND == True).

         * DOES_NOT_INCLUDE_ANY-A bitwise AND operation in which none of the
         bits in the value are present in the attribute (bitwise AND == False).
         The summaries Filter Type value options are as follows:

         * SPECIFIC_VALUE-Filter by a specific value.

         * NETWORK_ATTRIBUTE-Filter by a network attribute.
     condition_barriers {Value Table}:
         Sets a traversability barrier condition on features based on a
         comparison to a network attribute or check for a category string. A
         condition barrier uses a network attribute, an operator and a type,
         and an attribute value. For example, stop a trace when a feature has
         the Device Status attribute equal to the specific value of Open. When
         a feature meets this condition, the trace stops. If you're using more
         than one attribute, you can use the Combine using parameter to define
         an And or an Or condition. Condition barrier components are as
         follows:

         * Name-Filter by any network attribute defined in the system.

         * Operator-Choose from a number of operators.

         * Type-Choose a specific value or network attribute from the value
         that is specified in the name parameter.

         * Value-Provide a specific value of the input attribute type that
         would cause termination based on the operator value.

         * Combine Using-Set this value if you have multiple attributes to add.
         You can combine them using an And or an Or condition.
         The condition barriers Operator values are as follows:

         * IS_EQUAL_TO-The attribute is equal to the value.

         * DOES_NOT_EQUAL-The attribute is not equal to the value.

         * IS_GREATER_THAN-The attribute is greater than the value.

         * IS_GREATER_THAN_OR_EQUAL_TO-The attribute is greater than or equal
         to the value.

         * IS_LESS_THAN-The attribute is less than the value.

         * IS_LESS_THAN_OR_EQUAL_TO-The attribute is less than or equal to the
         value.

         * INCLUDES_THE_VALUES-A bitwise AND operation in which all bits in the
         value are present in the attribute (bitwise AND == value).

         * DOES_NOT_INCLUDE_THE_VALUES-A bitwise AND operation in which not all
         of the bits in the value are present in the attribute (bitwise AND !=
         value).

         * INCLUDES_ANY-A bitwise AND operation in which at least one bit in
         the value is present in the attribute (bitwise AND == True).

         * DOES_NOT_INCLUDE_ANY-A bitwise AND operation in which none of the
         bits in the value are present in the attribute (bitwise AND == False).
         The condition barriers Type value options are as follows:

         * SPECIFIC_VALUE-Filter by a specific value.

         * NETWORK_ATTRIBUTE-Filter by a network attribute.
         The Combine Using values are as follows:

         * AND-Combine the condition barriers.

         * OR-Use if either condition barrier is met.
     function_barriers {Value Table}:
         Sets a traversability barrier on features based on a function.
         Function barriers can be used to do such things as restrict how far
         the trace travels from the starting point, or set a maximum value to
         stop a trace. For example, the length of each line traveled is added
         to the total distance traveled so far. When the total length traveled
         reaches the value specified, the trace stops. Function barrier
         components are as follows:

         * Function-Choose from a number of calculation functions.

         * Attribute-Filter by any network attribute defined in the system.

         * Operator-Choose from a number of operators.

         * Value-Provide a specific value of the input attribute type that, if
         discovered, will cause the termination.

         * Use Local Values-Calculate values in each direction as opposed to an
         overall global value, for example, for a function barrier that is
         calculating the sum of a shape length in which the trace terminates if
         the value is greater than or equal to 4. In the global case, after you
         have traversed two edges with a value of 2, you have already reached a
         shape length sum of 4, so the trace stops. If local values are used,
         the local values along each path change, and the trace continues.
         The function barrier Function value options are as follows:

         * AVERAGE-The average of the input values.

         * COUNT-The number of features.

         * MAX-The maximum of the input values.

         * MIN-The minimum of the input values.

         * ADD-The sum of the input values.

         * SUBTRACT-The difference in the input values.Subnetwork controllers
         and loops trace types do not support the subtract function.
         The function barrier Operator value options are as follows:

         * IS_EQUAL_TO-The attribute is equal to the value.

         * DOES_NOT_EQUAL-The attribute is not equal to the value.

         * IS_GREATER_THAN-The attribute is greater than the value.

         * IS_GREATER_THAN_OR_EQUAL_TO-The attribute is greater than or equal
         to the value.

         * IS_LESS_THAN-The attribute is less than the value.

         * IS_LESS_THAN_OR_EQUAL_TO-The attribute is less than or equal to the
         value.

         * INCLUDES_THE_VALUES-A bitwise AND operation in which all bits in the
         value are present in the attribute (bitwise AND == value).

         * DOES_NOT_INCLUDE_THE_VALUES-A bitwise AND operation in which not all
         of the bits in the value are present in the attribute (bitwise AND !=
         value).

         * INCLUDES_ANY-A bitwise AND operation in which at least one bit in
         the value is present in the attribute (bitwise AND == True).

         * DOES_NOT_INCLUDE_ANY-A bitwise AND operation in which none of the
         bits in the value are present in the attribute (bitwise AND == False).
         The function barrier Use Local Values value options are as follows:

         * TRUE-Use local values.

         * FALSE-Use global values. This is the default.
     include_barriers {Boolean}:
         Specifies whether the traversability barrier features will be included
         in the trace results. Traversability barriers are optional even if
         they have been preset in the subnetwork definition.

         * INCLUDE_BARRIERS-Traversability barriers will be included in the
         trace results. This is the default.

         * EXCLUDE_BARRIERS-Traversability barriers will not be included in the
         trace results.
     traversability_scope {String}:
         The type of traversability that will be applied. Traversability scope
         determines whether traversability is applied at junctions, edges, or
         both. For example, if a condition barrier is defined to stop the trace
         if Device Status is equal to Open and traversability scope is set to
         edges only, the trace will not stop-even if it encounters an open
         device-because Device Status is only applicable to junctions. In other
         words, this parameter indicates to the trace whether to ignore
         junctions, edges, or both.

         * BOTH_JUNCTIONS_AND_EDGES-Traversability will be applied to both
         junctions and edges. This is the default.

         * JUNCTIONS_ONLY-Traversability will be applied to junctions only.

         * EDGES_ONLY-Traversability will be applied to edges only.
     propagators {Value Table}:
         Specifies the network attributes to propagate as well as how that
         propagation will occur during a trace. Propagated class attributes
         denote the key values on subnetwork controllers that are disseminated
         to the rest of the features in the subnetwork. For example, in an
         electric distribution model, you can propagate the phase value.
         Propagators components are as follows:

         * Attribute-Filter by any network attribute defined in the system.

         * Substitution Attribute-Use a substituted value instead of bitset
         network attribute values. Substitutions are encoded based on the
         number of bits in the network attribute being propagated. A
         substitution is a mapping of each bit in a phase to another bit. For
         example, for Phase AC, one substitution could map bit A to B and bit C
         to null. In this example the substitution for 1010 (Phase AC) is
         0000-0010-0000-0000 (512). The substitution captures the mapping so
         you know that Phase A was mapped to B and Phase C was mapped to null
         and not the other way around (that is, Phase A was not mapped to null
         and Phase C was not mapped to B).

         * Function-Choose from a number of calculation functions.

         * Operator-Choose from a number of operators.

         * Value-Provide a specific value for the input attribute type that
         would cause termination based on the operator value.

         * Propagated Attribute-The name of the field in the network class that
         is used to store the calculated propagated values. The field type
         should be the same as the field type of the network attribute chosen
         for the Attribute value.
         The propagators Function value options are as follows:

         * PROPAGATED_BITWISE_AND-Compare the values from one feature to the
         next.

         * PROPAGATED_MIN-Get the minimum value.

         * PROPAGATED_MAX-Get the maximum value.
         The propagators Operator value options are as follows:

         * IS_EQUAL_TO-The attribute is equal to the value.

         * DOES_NOT_EQUAL-The attribute is not equal to the value.

         * IS_GREATER_THAN-The attribute is greater than the value.

         * IS_GREATER_THAN_OR_EQUAL_TO-The attribute is greater than or equal
         to the value.

         * IS_LESS_THAN-The attribute is less than the value.

         * IS_LESS_THAN_OR_EQUAL_TO-The attribute is less than or equal to the
         value.

         * INCLUDES_THE_VALUES-A bitwise AND operation in which all bits in the
         value are present in the attribute (bitwise AND == value).

         * DOES_NOT_INCLUDE_THE_VALUES-A bitwise AND operation in which not all
         of the bits in the value are present in the attribute (bitwise AND !=
         value).

         * INCLUDES_ANY-A bitwise AND operation in which at least one bit in
         the value is present in the attribute (bitwise AND == True).

         * DOES_NOT_INCLUDE_ANY-A bitwise AND operation in which none of the
         bits in the value are present in the attribute (bitwise AND == False).
         This parameter is only available via Python.
     update_structure_features {Boolean}:
         Specifies whether the update subnetwork process will update the
         supported subnetwork name attribute for structure network containers.

         * UPDATE-The structure network containers will be updated. This is the
         default.

         * NOT_UPDATE-The structure network containers will not be updated.
         This parameter requires a Utility Network Version value of 4 or later.
     update_container_features {Boolean}:
         Specifies whether the update subnetwork process will update the
         supported subnetwork name for domain network containers.

         * UPDATE-The domain network containers will be updated. This is the
         default.

         * NOT_UPDATE-The domain network containers will not be updated.
         This parameter requires a Utility Network Version value of 4 or later.
     edit_mode_for_default_version {String}:
         Specifies the edit mode that will be used for subnetwork updates on
         the default version and with file and mobile geodatabases.

         * WITHOUT_EVENTING-Eventing will not be used for subnetwork updates on
         the default version or in a file or mobile geodatabase. This edit mode
         updates the subnetwork name and propagated values in place. This is
         the default.

         * WITH_EVENTING-Eventing will be used for subnetwork updates on the
         default version and in a file or mobile geodatabase. This edit mode
         executes geodatabase behavior (for example, attribute rules, editor
         tracking, and so on) when the subnetwork is updated and updates the
         subnetwork name and propagated values for all applicable features and
         objects.
         This parameter requires a Utility Network Version value of 4 or later.
     edit_mode_for_named_version {String}:
         Specifies the edit mode that will be used for subnetwork updates on a
         named version.

         * WITHOUT_EVENTING-Eventing will not be used for subnetwork updates on
         named versions. This edit mode updates the subnetwork name and
         propagated values in place for features and objects edited in the
         version. This is the default.

         * WITH_EVENTING-Eventing will be used for subnetwork updates on named
         versions. This edit mode executes geodatabase behavior (for example,
         attribute rules, editor tracking, and so on) when the subnetwork is
         updated and updates the subnetwork name and propagated values for all
         applicable features and objects.
         This parameter requires a Utility Network Version value of 4 or later
         and is only applicable to enterprise geodatabases.
     valid_junctions {String}:
         The asset group/asset type pairs identified as valid junctions for the
         subnetwork.This parameter requires a Utility Network Version value of
         4 or later.
     valid_junction_objects {String}:
         The asset group/asset type pairs identified as valid junction objects
         for the subnetwork.This parameter requires a Utility Network Version
         value of 4 or later.
     valid_junction_object_subnetwork_controller {String}:
         The asset group/asset type pairs identified as valid junction object
         subnetwork controllers for the subnetwork.This parameter requires a
         Utility Network Version value of 4 or later.
     valid_edge_objects {String}:
         The asset group/asset type pairs identified as valid edge objects for
         the subnetwork.This parameter requires a Utility Network Version value
         of 4 or later.
     manage_subnetwork_isdirty {Boolean}:
         Specifies whether the Is dirty attribute in the subnetworks table will
         be managed by the update subnetwork operation. If no subnetwork
         controllers are defined for the tier, this parameter uses the
         NOT_MANAGE option.

         * MANAGE-The Is dirty attribute will be managed by the update
         subnetwork operation. This is the default except as noted.

         * NOT_MANAGE-The Is dirty attribute will not be managed by the update
         subnetwork operation.
         This parameter requires a Utility Network Version value of 5 or later.
     include_containers {Boolean}:
         Specifies whether the container features and objects will be included
         in the trace results.

         * INCLUDE_CONTAINERS-Container features and objects will be included
         in the trace results.

         * EXCLUDE_CONTAINERS-Container features and objects will not be
         included in the trace results. This is the default.
         This parameter requires a Utility Network Version value of 5 or later.
     include_content {Boolean}:
         Specifies whether the trace will return content of containers in the
         results.

         * INCLUDE_CONTENT-Content of container features and objects will be
         included in the trace results.

         * EXCLUDE_CONTENT-Content of container features and objects will not
         be included in the trace results. This is the default.
         This parameter requires a Utility Network Version value of 5 or later.
     include_structures {Boolean}:
         Specifies whether structure features and objects will be included in
         the trace results.

         * INCLUDE_STRUCTURES-Structure features and objects will be included
         in the trace results.

         * EXCLUDE_STRUCTURES-Structure features and objects will not be
         included in the trace results. This is the default.
         This parameter requires a Utility Network Version value of 5 or later.
     validate_locatability {Boolean}:
         Specifies whether an error will be returned during a trace or update
         subnetwork operation if nonspatial junction or edge objects are
         encountered without the necessary containment, attachment, or
         connectivity association in their association hierarchy of the
         traversed objects. This option ensures that nonspatial objects
         returned by a trace or update subnetwork operation can be located
         through an association with features or other locatable objects.

         * VALIDATE_LOCATABILITY-An error will be returned if nonspatial
         junction or edge objects are encountered without the necessary
         containment, attachment, or connectivity association in their
         association hierarchy of the traversed objects.

         * DO_NOT_VALIDATE_LOCATABILITY-The trace will not check for
         unlocatable objects and will return results regardless of whether
         unlocatable objects are present in the association hierarchy of the
         traversed objects. This is the default.
         This parameter requires a Utility Network Version value of 5 or later."""
    ...

@gptooldoc("SetTerminalConfiguration_un", None)
def SetTerminalConfiguration(
    in_utility_network=...,
    domain_network=...,
    device_featureclass=...,
    assetgroup=...,
    assettype=...,
    terminal_configuration=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """SetTerminalConfiguration_un(in_utility_network, domain_network, device_featureclass, assetgroup, assettype, terminal_configuration)

       Assigns a terminal configuration to an asset type in a utility
       network.

    INPUTS:
     in_utility_network (Utility Network / Utility Network Layer):
         The utility network containing the terminal configuration that will be
         assigned to a specific asset type.
     domain_network (String):
         The domain network to which the asset type belongs.
     device_featureclass (String):
         The utility network feature class or table to which the asset type
         belongs.
     assetgroup (String):
         The asset group to which the asset type belongs.
     assettype (String):
         The asset type that will receive the terminal configuration.
     terminal_configuration (String):
         The terminal configuration that will be assigned to the asset type."""
    ...

@gptooldoc("AddTraceConfiguration_un", None)
def AddTraceConfiguration(
    in_utility_network=...,
    trace_config_name=...,
    trace_type=...,
    description=...,
    tags=...,
    domain_network=...,
    tier=...,
    target_tier=...,
    subnetwork_name=...,
    shortest_path_network_attribute_name=...,
    include_containers=...,
    include_content=...,
    include_structures=...,
    include_barriers=...,
    validate_consistency=...,
    condition_barriers=...,
    function_barriers=...,
    traversability_scope=...,
    filter_barriers=...,
    filter_function_barriers=...,
    filter_scope=...,
    filter_bitset_network_attribute_name=...,
    filter_nearest=...,
    nearest_count=...,
    nearest_cost_network_attribute=...,
    nearest_categories=...,
    nearest_assets=...,
    functions=...,
    propagators=...,
    output_assettypes=...,
    output_conditions=...,
    include_isolated_features=...,
    ignore_barriers_at_starting_points=...,
    include_up_to_first_spatial_container=...,
    result_types=...,
    allow_indeterminate_flow=...,
    validate_locatability=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """AddTraceConfiguration_un(in_utility_network, trace_config_name, trace_type, {description}, {tags;tags...}, {domain_network}, {tier}, {target_tier}, {subnetwork_name}, {shortest_path_network_attribute_name}, {include_containers}, {include_content}, {include_structures}, {include_barriers}, {validate_consistency}, {condition_barriers;condition_barriers...}, {function_barriers;function_barriers...}, {traversability_scope}, {filter_barriers;filter_barriers...}, {filter_function_barriers;filter_function_barriers...}, {filter_scope}, {filter_bitset_network_attribute_name}, {filter_nearest}, {nearest_count}, {nearest_cost_network_attribute}, {nearest_categories;nearest_categories...}, {nearest_assets;nearest_assets...}, {functions;functions...}, {propagators;propagators...}, {output_assettypes;output_assettypes...}, {output_conditions;output_conditions...}, {include_isolated_features}, {ignore_barriers_at_starting_points}, {include_up_to_first_spatial_container}, {result_types;result_types...}, {allow_indeterminate_flow}, {validate_locatability})

       Creates a named trace configuration in the utility network.

    INPUTS:
     in_utility_network (Utility Network / Utility Network Layer):
         The utility network that will contain the new named trace
         configuration.
     trace_config_name (String):
         The name for the named trace configuration.
     trace_type (String):
         Specifies the type of trace that will be configured.

         * CONNECTED-A connected trace that begins at one or more starting
         points and spans outward along connected features will be used. This
         is the default.

         * SUBNETWORK-A subnetwork trace that begins at one or more starting
         points and spans outward to encompass the extent of the subnetwork
         will be used.

         * SUBNETWORK_CONTROLLERS-A subnetwork controllers trace that locates
         sources and sinks on subnetwork controllers associated with a
         subnetwork will be used.

         * UPSTREAM-An upstream trace that discovers features upstream from a
         location in the network will be used.

         * DOWNSTREAM-A downstream trace that discovers features downstream
         from a location in the network will be used.

         * LOOPS-Loops are areas of the network where flow direction is
         ambiguous. A loops trace that spans outward from the starting point
         based on connectivity will be used.

         * SHORTEST_PATH-A shortest path trace that identifies the shortest
         path between two starting points will be used.

         * ISOLATION-An isolation trace that discovers features that isolate an
         area of a network will be used.
     description {String}:
         The description of the named trace configuration.
     tags {String}:
         A set of tags used to identify the named trace configuration. The tags
         can be used in search and indexing.
     domain_network {String}:
         The name of the domain network where the trace will be run. This
         parameter is required when running the subnetwork, subnetwork
         controllers, upstream, and downstream trace types.
     tier {String}:
         The name of the tier to start the trace. This parameter is required
         when running the subnetwork, subnetwork controllers, upstream, and
         downstream trace types.
     target_tier {String}:
         The name of the target tier to which the input tier flows. If this
         parameter is missing for upstream and downstream traces, those traces
         will stop when they reach the boundary of the starting subnetwork.
         This parameter can be used to allow these traces to continue either
         farther up or farther down the hierarchy.
     subnetwork_name {String}:
         The name of the subnetwork where the trace will be run. This parameter
         can be used when running a subnetwork trace type. If a subnetwork name
         is specified, the starting_points parameter is not required.
     shortest_path_network_attribute_name {String}:
         The name of the network attribute used to calculate the shortest path.
         When running a shortest path trace type, the shortest path is
         calculated using a numeric network attribute such as shape length.
         Cost and distance based paths can both be achieved. This parameter is
         required when running a shortest path trace.
     include_containers {Boolean}:
         Specifies whether the container features will be included in the trace
         results.

         * INCLUDE_CONTAINERS-Container features will be included in the trace
         results.

         * EXCLUDE_CONTAINERS-Container features will not be included in the
         trace results. This is the default.
     include_content {Boolean}:
         Specifies whether the trace will return content in containers in the
         results.

         * INCLUDE_CONTENT-Content in container features will be included in
         the trace results.

         * EXCLUDE_CONTENT-Content in container features will not be included
         in the trace results. This is the default.
     include_structures {Boolean}:
         Specifies whether structure features and objects will be included in
         the trace results.

         * INCLUDE_STRUCTURES-Structure features and objects will be included
         in the trace results.

         * EXCLUDE_STRUCTURES-Structure features and objects will not be
         included in the trace results. This is the default.
     include_barriers {Boolean}:
         Specifies whether the traversability barrier features will be included
         in the trace results. Traversability barriers are optional even if
         they have been preset in the subnetwork definition. This parameter
         does not apply to device features with terminals.

         * INCLUDE_BARRIERS-Traversability barrier features will be included in
         the trace results. This is the default.

         * EXCLUDE_BARRIERS-Traversability barrier features will not be
         included in the trace results.
     validate_consistency {Boolean}:
         Specifies whether an error will be returned if dirty areas are
         encountered in any of the traversed features. This is the only way to
         guarantee a trace is passing through features with consistent status
         in the network. To remove dirty areas, validate the network topology.

         * VALIDATE_CONSISTENCY-The trace will return an error if dirty areas
         are encountered in any of the traversed features. This is the default.

         * DO_NOT_VALIDATE_CONSISTENCY-The trace will return results regardless
         of whether dirty areas are encountered in any of the traversed
         features.
     condition_barriers {Value Table}:
         Sets a traversability barrier condition on features based on a
         comparison to a network attribute or check for a category string. A
         condition barrier uses a network attribute, an operator and a type,
         and an attribute value. For example, stop a trace when a feature has
         the Device Status attribute equal to the specific value of Open. When
         a feature meets this condition, the trace stops. If you're using more
         than one attribute, you can use the Combine using parameter to define
         an And or an Or condition. Condition barrier components are as
         follows:

         * Name-Filter by any network attribute defined in the system.

         * Operator-Choose from a number of operators.

         * Type-Choose a specific value or network attribute from the value
         that is specified in the name parameter.

         * Value-Provide a specific value for the input attribute type that
         would cause termination based on the operator value.

         * Combine Using-Set this value if you have multiple attributes to add.
         You can combine them using an And or an Or condition.
         The condition barriers operator value options are as follows:

         * IS_EQUAL_TO-The attribute is equal to the value.

         * DOES_NOT_EQUAL-The attribute is not equal to the value.

         * IS_GREATER_THAN-The attribute is greater than the value.

         * IS_GREATER_THAN_OR_EQUAL_TO-The attribute is greater than or equal
         to the value.

         * IS_LESS_THAN-The attribute is less than the value.

         * IS_LESS_THAN_OR_EQUAL_TO-The attribute is less than or equal to the
         value.

         * INCLUDES_THE_VALUES-A bitwise AND operation in which all bits in the
         value are present in the attribute (bitwise AND == value).

         * DOES_NOT_INCLUDE_THE_VALUES-A bitwise AND operation in which not all
         of the bits in the value are present in the attribute (bitwise AND !=
         value).

         * INCLUDES_ANY-A bitwise AND operation in which at least one bit in
         the value is present in the attribute (bitwise AND == True).

         * DOES_NOT_INCLUDE_ANY-A bitwise AND operation in which none of the
         bits in the value are present in the attribute (bitwise AND == False).
         The condition barriers Type value options are as follows:

         * SPECIFIC_VALUE-Filter by a specific value.

         * NETWORK_ATTRIBUTE-Filter by a network attribute.
         The condition barriers Combine Using value options are as follows:

         * AND-Combine the condition barriers.

         * OR-Use if either condition barrier is met.
     function_barriers {Value Table}:
         Sets a traversability barrier on features based on a function.
         Function barriers can be used to do such things as restrict how far
         the trace travels from the starting point, or set a maximum value to
         stop a trace. For example, the length of each line traveled is added
         to the total distance traveled so far. When the total length traveled
         reaches the value specified, the trace stops. Function barrier
         components are as follows:

         * Function-Choose from a number of calculation functions.

         * Attribute-Filter by any network attribute defined in the system.

         * Operator-Choose from a number of operators.

         * Value-Provide a specific value for the input attribute type that, if
         discovered, will cause the termination.

         * Use Local Values-Calculate values in each direction as opposed to an
         overall global value. For example, a function barrier that is
         calculating the sum of shape length in which the trace terminates if
         the value is greater than or equal to 4. In the global case, after you
         have traversed two edges with a value of 2, you will have already
         reached a shape length sum of 4, so the trace stops. If local values
         are used, the local values along each path change, and the trace
         continues.
         The function barrier function value options are as follows:

         * AVERAGE-The average of the input values.

         * COUNT-The number of features.

         * MAX-The maximum of the input values.

         * MIN-The minimum of the input values.

         * ADD-The sum of the values.

         * SUBTRACT-The difference between the values. Subnetwork controllers
         and loops trace types do not support the subtract function.
         The function barrier operator value options are as follows:

         * IS_EQUAL_TO-The function result is equal to the value.

         * DOES_NOT_EQUAL-The function result is not equal to the value.

         * IS_GREATER_THAN-The function result is greater than the value.

         * IS_GREATER_THAN_OR_EQUAL_TO-The function result is greater than or
         equal to the value.

         * IS_LESS_THAN-The function result is less than the value.

         * IS_LESS_THAN_OR_EQUAL_TO-The function result is less than or equal
         to the value.

         * INCLUDES_THE_VALUES-A bitwise AND operation in which all bits in the
         value are present in the attribute (bitwise AND == value).

         * DOES_NOT_INCLUDE_THE_VALUES-A bitwise AND operation in which not all
         of the bits in the value are present in the attribute (bitwise AND !=
         value).

         * INCLUDES_ANY-A bitwise AND operation in which at least one bit in
         the value is present in the attribute (bitwise AND == True).

         * DOES_NOT_INCLUDE_ANY-A bitwise AND operation in which none of the
         bits in the value are present in the attribute (bitwise AND == False).
         The function barrier Use Local Values options are as follows:

         * TRUE-Local values will be used.

         * FALSE-Global values will be used. This is the default.
     traversability_scope {String}:
         Specifies whether traversability will be applied to junctions, edges,
         or both. For example, if a condition barrier is defined to stop the
         trace if Device Status is equal to Open and traversability scope is
         set to edges only, the trace will not stop-even if it encounters an
         open device-because Device Status is only applicable to junctions. In
         other words, this parameter indicates to the trace whether to ignore
         junctions, edges, or both.

         * BOTH_JUNCTIONS_AND_EDGES-Traversability will be applied to both
         junctions and edges. This is the default.

         * JUNCTIONS_ONLY-Traversability will be applied to junctions only.

         * EDGES_ONLY-Traversability will be applied to edges only.
     filter_barriers {Value Table}:
         Specifies when a trace will stop for a specific category or network
         attribute. For example, stop a trace at features that have a life
         cycle status attribute that is equal to a certain value. This
         parameter is used to set a terminator based on a value of a network
         attribute that is defined in the system. If you're using more than one
         attribute, you can use the Combine Using option to define an And or an
         Or condition. Filter barrier components are as follows:

         * Name-Filter by category or any network attribute defined in the
         system.

         * Operator-Choose from a number of operators.

         * Type-Choose a specific value or network attribute from the value
         that is specified in the name parameter.

         * Value-Provide a specific value of the input attribute type that
         would cause termination based on the operator value.

         * Combine Using-Set this value if you have multiple attributes to add.
         You can combine them using an And or an Or condition.
         The filter barriers operator value options are as follows:

         * IS_EQUAL_TO-The attribute is equal to the value.

         * DOES_NOT_EQUAL-The attribute is not equal to the value.

         * IS_GREATER_THAN-The attribute is greater than the value.

         * IS_GREATER_THAN_OR_EQUAL_TO-The attribute is greater than or equal
         to the value.

         * IS_LESS_THAN-The attribute is less than the value.

         * IS_LESS_THAN_OR_EQUAL_TO-The attribute is less than or equal to the
         value.

         * INCLUDES_THE_VALUES-A bitwise AND operation in which all bits in the
         value are present in the attribute (bitwise AND == value).

         * DOES NOT INCLUDE_THE_VALUES-A bitwise AND operation in which not all
         of the bits in the value are present in the attribute (bitwise AND !=
         value).

         * INCLUDES_ANY-A bitwise AND operation in which at least one bit in
         the value is present in the attribute (bitwise AND == True).

         * DOES_NOT_INLCUDE_ANY-A bitwise AND operation in which none of the
         bits in the value are present in the attribute (bitwise AND == False).
         The filter barriers Type value options are as follows:

         * SPECIFIC_VALUE-Filter by a specific value.

         * NETWORK_ATTRIBUTE-Filter by a network attribute.
         The filter barriers Combine Using value options are as follows:

         * AND-Combine the condition barriers.

         * OR-Use if either condition barrier is met.
     filter_function_barriers {Value Table}:
         Filters the results of the trace for a specific category.
         Filter function barriers components are as follows:

         * Function-Choose from a number of calculation functions.

         * Attribute-Filter by any network attribute defined in the system.

         * Operator-Choose from a number of operators.

         * Value-Provide a specific value for the input attribute type that, if
         discovered, will cause the termination.

         * Use Local Values-Calculate values in each direction as opposed to an
         overall global value. For example, a function barrier that is
         calculating the sum of shape length where the trace terminates if the
         value is greater than or equal to 4. In the global case, after you
         have traversed two edges with a value of 2, you will have already
         reached a shape length sum of 4, so the trace stops. If local values
         are used, the local values along each path change, or the trace
         continues.
         The filter function barriers function value options are as follows:

         * AVERAGE-The average of the input values.

         * COUNT-The number of features.

         * MAX-The maximum of the input values.

         * MIN-The minimum of the input values.

         * ADD-The sum of the values.

         * SUBTRACT-The difference between the values. Subnetwork controllers
         and loops trace types do not support the subtract function.
         The filter function barriers operator value options are as follows:

         * IS_EQUAL_TO-The attribute is equal to the value.

         * DOES_NOT_EQUAL-The attribute is not equal to the value.

         * IS_GREATER_THAN-The attribute is greater than the value.

         * IS_GREATER_THAN_OR_EQUAL_TO-The attribute is greater than or equal
         to the value.

         * IS_LESS_THAN-The attribute is less than the value.

         * IS_LESS_THAN_OR_EQUAL_TO-The attribute is less than or equal to the
         value.

         * INCLUDES_THE_VALUES-A bitwise AND operation in which all bits in the
         value are present in the attribute (bitwise AND == value).

         * DOES_NOT_INCLUDE_THE_VALUES-A bitwise AND operation in which not all
         of the bits in the value are present in the attribute (bitwise AND !=
         value).

         * INCLUDES_ANY-A bitwise AND operation in which at least one bit in
         the value is present in the attribute (bitwise AND == True).

         * DOES_NOT_INCLUDE_ANY-A bitwise AND operation in which none of the
         bits in the value are present in the attribute (bitwise AND == False).
         The filter function barriers Use Local Values options are as follows:

         * TRUE-Local values will be used.

         * FALSE-Global values will be used. This is the default.
     filter_scope {String}:
         Specifies whether the filter for a specific category will be applied
         to junctions, edges, or both. For example, if a filter barrier is
         defined to stop the trace if Device Status is equal to Open and
         traversability scope is set to edges only, the trace will not
         stop-even if the trace encounters an open device-because Device Status
         is only applicable to junctions. In other words, this parameter
         indicates to the trace whether to ignore junctions, edges, or both.

         * BOTH_JUNCTIONS_AND_EDGES-The filter will be applied to both
         junctions and edges. This is the default.

         * JUNCTIONS_ONLY-The filter will be applied to junctions only.

         * EDGES_ONLY-The filter will be applied to edges only.
     filter_bitset_network_attribute_name {String}:
         The name of the network attribute that will be used to filter by
         bitset. This parameter is only applicable to upstream, downstream, and
         loops trace types. This parameter can be used to add special logic
         during a trace so the trace more closely reflects real-world
         scenarios. For example, for a loops trace, the Phases current network
         attribute can determine if the loop is a true electrical loop (the
         same phase is energized all around the loop, that is, A) and return
         only real electrical loops for the trace results. An example for an
         upstream trace is when tracing an electric distribution network,
         specify a Phases current network attribute, and the trace results will
         only include valid paths that are specified in the network attribute,
         not all paths.
     filter_nearest {Boolean}:
         Specifies whether the k-nearest neighbors algorithm will be used to
         return a number of features of a certain type within a given distance.
         When this parameter is used, you can specify a count and a cost as
         well as a collection of categories, an asset type, or both.

         * FILTER_BY_NEAREST-The k-nearest neighbors algorithm will be used to
         return a number of features as specified in the nearest_count,
         nearest_cost_network_attribute, nearest_categories, or nearest_assets
         parameter.

         * DO_NOT_FILTER-The k-nearest neighbors algorithm will not be used to
         filter results. This is the default.
     nearest_count {Long}:
         The number of features to be returned when filter_nearest is
         FILTER_BY_NEAREST.
     nearest_cost_network_attribute {String}:
         The numeric network attribute that will be used to calculate nearness,
         cost, or distance when filter_nearest is FILTER_BY_NEAREST-for
         example, shape length.
     nearest_categories {String}:
         The category or categories that will be returned when filter_nearest
         is FILTER_BY_NEAREST-for example, Protective.
     nearest_assets {String}:
         The asset groups and asset types that will be returned when
         filter_nearest is FILTER_BY_NEAREST-for example,
         ElectricDistributionDevice/Transformer/Step Down.
     functions {Value Table}:
         Applies a calculation function to the trace results. Functions
         components are as follows:

         * Function-Choose from a number of calculation functions.

         * Attribute-Filter by any network attribute defined in the system.

         * Filter Name-Filter the function results by attribute name.

         * Filter Operator-Choose from a number of operators.

         * Filter Type-Choose from a number of filter types.

         * Filter Value-Provide a specific value for the input filter
         attribute.
         The functions Function value options are as follows:

         * AVERAGE-The average of the input values.

         * COUNT-The number of features.

         * MAX-The maximum of the input values.

         * MIN-The minimum of the input values.

         * ADD-The sum of the values.

         * SUBTRACT-The difference between the values.Subnetwork controllers
         and loops trace types do not support the subtract function.
         For example, a starting point feature has a value of 20. The next
         feature has a value of 30. If you are using the MINIMUM function, the
         result is 20, MAXIMUM is 30, ADD is 50, AVERAGE is 25, COUNT is 2, and
         SUBTRACT is -10.The Filter Operator value options are as follows:

         * IS_EQUAL_TO-The attribute is equal to the value.

         * DOES_NOT_EQUAL-The attribute is not equal to the value.

         * IS_GREATER_THAN-The attribute is greater than the value.

         * IS_GREATER_THAN_OR_EQUAL_TO-The attribute is greater than or equal
         to the value.

         * IS_LESS_THAN-The attribute is less than the value.

         * IS_LESS_THAN_OR_EQUAL_TO-The attribute is less than or equal to the
         value.

         * INCLUDES_THE_VALUES-A bitwise AND operation in which all bits in the
         value are present in the attribute (bitwise AND == value).

         * DOES_NOT_INCLUDE_THE_VALUES-A bitwise AND operation in which not all
         of the bits in the value are present in the attribute (bitwise AND !=
         value).

         * INCLUDES_ANY-A bitwise AND operation in which at least one bit in
         the value is present in the attribute (bitwise AND == True).

         * DOES_NOT_INCLUDE_ANY-A bitwise AND operation in which none of the
         bits in the value are present in the attribute (bitwise AND == False).
         The functions Filter Type value options are as follows:

         * SPECIFIC_VALUE-Filter by a specific value.

         * NETWORK_ATTRIBUTE-Filter by a network attribute.
     propagators {Value Table}:
         Specifies the network attributes to propagate as well as how that
         propagation will occur during a trace. Propagated class attributes
         denote the key values on subnetwork controllers that are disseminated
         to the rest of the features in the subnetwork. For example, in an
         electric distribution model, you can propagate the phase value.
         Propagators components are as follows:

         * Attribute-Filter by any network attribute defined in the system.

         * Substitution Attribute-Use a substituted value instead of bitset
         network attribute values. Substitutions are encoded based on the
         number of bits in the network attribute being propagated. A
         substitution is a mapping of each bit in phase to another bit. For
         example, for Phase AC, one substitution could map bit A to B, and bit
         C to null. In this example, the substitution for 1010 (Phase AC) is
         0000-0010-0000-0000 (512). The substitution captures the mapping so
         you know that Phase A was mapped to B and Phase C was mapped to null,
         and not the other way around (that is, Phase A was not mapped to null
         and Phase C was not mapped to B).

         * Function-Choose from a number of calculation functions.

         * Operator-Choose from a number of operators.

         * Value-Provide a specific value for the input attribute type that
         would cause termination based on the operator value.
         The propagators function value options are as follows:

         * PROPAGATED_BITWISE_AND-Compare the values from one feature to the
         next.

         * PROPAGATED_MIN-Get the minimum value.

         * PROPAGATED_MAX-Get the maximum value.
         The propagators operator value options are as follows:

         * IS_EQUAL_TO-The attribute is equal to the value.

         * DOES_NOT_EQUAL-The attribute is not equal to the value.

         * IS_GREATER_THAN-The attribute is greater than the value.

         * IS_GREATER_THAN_OR_EQUAL_TO-The attribute is greater than or equal
         to the value.

         * IS_LESS_THAN-The attribute is less than the value.

         * IS_LESS_THAN_OR_EQUAL_TO-The attribute is less than or equal to the
         value.

         * INCLUDES_THE_VALUES-A bitwise AND operation in which all bits in the
         value are present in the attribute (bitwise AND == value).

         * DOES_NOT_INCLUDE_THE_VALUES-A bitwise AND operation in which not all
         of the bits in the value are present in the attribute (bitwise AND !=
         value).

         * INCLUDES_ANY-A bitwise AND operation in which at least one bit in
         the value is present in the attribute (bitwise AND == True).

         * DOES_NOT_INCLUDE_ANY-A bitwise AND operation in which none of the
         bits in the value are present in the attribute (bitwise AND == False).
         This parameter is only available via Python.
     output_assettypes {String}:
         Filters the output asset types to be included in the results-for
         example, only return overhead transformers.
     output_conditions {Value Table}:
         The types of features that will be returned based on a network
         attribute or category. For example, in a trace configured to filter
         out everything but Tap features, any traced features that do not have
         the Tap category assigned to them will not be included in the results.
         Any traced features that do will be returned in the result selection
         set. If you're using more than one attribute, you can use the Combine
         Using option to define an And or an Or condition. Output
         conditions components are as follows:

         * Name-Filter by any network attribute defined in the system.

         * Operator-Choose from a number of operators.

         * Type-Choose a specific value or network attribute from the value
         that is specified in the name parameter.

         * Value-Provide a specific value of the input attribute type that
         would cause termination based on the operator value.

         * Combine Using-Set this value if you have multiple attributes to add.
         You can combine them using an And or an Or condition.
         The output conditions operator value options are as follows:

         * IS_EQUAL_TO-The attribute is equal to the value.

         * DOES_NOT_EQUAL-The attribute is not equal to the value.

         * IS_GREATER_THAN-The attribute is greater than the value.

         * IS_GREATER_THAN_OR_EQUAL_TO-The attribute is greater than or equal
         to the value.

         * IS_LESS_THAN-The attribute is less than the value.

         * IS_LESS_THAN_OR_EQUAL_TO-The attribute is less than or equal to the
         value.

         * INCLUDES_THE_VALUES-A bitwise AND operation in which all bits in the
         value are present in the attribute (bitwise AND == value).

         * DOES_NOT_INCLUDE_THE_VALUES-A bitwise AND operation in which not all
         of the bits in the value are present in the attribute (bitwise AND !=
         value).

         * INCLUDES_ANY-A bitwise AND operation in which at least one bit in
         the value is present in the attribute (bitwise AND == True).

         * DOES_NOT_INCLUDE_ANY-A bitwise AND operation in which none of the
         bits in the value are present in the attribute (bitwise AND == False).
         The output conditions Type value options are as follows:

         * SPECIFIC_VALUE-Filter by a specific value.

         * NETWORK_ATTRIBUTE-Filter by a network attribute.
         The output conditions Combine Using value options are as follows:

         * AND-Combine the conditions.

         * OR-Use if either condition is met.
     include_isolated_features {Boolean}:
         Specifies whether isolated features will be included in the trace
         results. This parameter is only used when running an isolation trace.

         * INCLUDE_ISOLATED_FEATURES-Isolated features will be included in the
         trace results.

         * EXCLUDE_ISOLATED_FEATURES-Isolated features will not be included in
         the trace results. This is the default.
         The isolation trace type requires ArcGIS Enterprise 10.7 or later when
         using an enterprise geodatabase.
     ignore_barriers_at_starting_points {Boolean}:
         Specifies whether dynamic barriers in the trace configuration will be
         ignored for starting points. This may be useful when performing an
         upstream protective device trace and using the discovered protective
         devices (barriers) as starting points to find subsequent upstream
         protective devices.

    """
    ...

@gptooldoc("DeleteTraceConfiguration_un", None)
def DeleteTraceConfiguration(
    in_utility_network=..., trace_config_name=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """DeleteTraceConfiguration_un(in_utility_network, trace_config_name;trace_config_name...)

       Deletes one or more named trace configurations from a utility network.

    INPUTS:
     in_utility_network (Utility Network / Utility Network Layer):
         The utility network containing the named trace configuration to be
         deleted.
     trace_config_name (String):
         The named trace configurations to be deleted."""
    ...

@gptooldoc("ExportTraceConfigurations_un", None)
def ExportTraceConfigurations(
    in_utility_network=..., trace_config_name=..., out_json_file=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """ExportTraceConfigurations_un(in_utility_network, trace_config_name;trace_config_name..., out_json_file)

       Exports named trace configurations from a utility network to JSON
       format (.json file).

    INPUTS:
     in_utility_network (Utility Network / Utility Network Layer):
         The utility network containing the named trace configuration or
         configurations to export.
     trace_config_name (String):
         The named trace configuration or configurations to export.

    OUTPUTS:
     out_json_file (File):
         The output .json file."""
    ...

@gptooldoc("ImportTraceConfigurations_un", None)
def ImportTraceConfigurations(
    in_utility_network=..., in_json_file=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """ImportTraceConfigurations_un(in_utility_network, in_json_file)

       Imports named trace configurations from JSON format (.json file) to a
       utility network.

    INPUTS:
     in_utility_network (Utility Network / Utility Network Layer):
         The utility network to which the named trace configurations will be
         imported.
     in_json_file (File):
         The .json file containing the named trace configurations to import."""
    ...

@gptooldoc("AddSpatialQueryRule_un", None)
def AddSpatialQueryRule(
    in_utility_network=...,
    template_name=...,
    is_active=...,
    added_features=...,
    overlap_type=...,
    existing_features=...,
    search_distance=...,
    added_where_clause=...,
    existing_where_clause=...,
    description=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """AddSpatialQueryRule_un(in_utility_network, template_name, is_active, added_features, overlap_type, existing_features, {search_distance}, {added_where_clause}, {existing_where_clause}, {description})

       Add a spatial query rule to a diagram template

    INPUTS:
     in_utility_network (Utility Network / Trace Network):
         Input Network
     template_name (String):
         Input Diagram Template
     is_active (Boolean):
         Active
     added_features (Feature Class):
         Add Features
     overlap_type (String):
         Relationship
     existing_features (Feature Class):
         Existing Features
     search_distance {Linear Unit}:
         Search Distance
     added_where_clause {SQL Expression}:
         Added Features Query Definition
     existing_where_clause {SQL Expression}:
         Existing Features Query Definition
     description {String}:
         Description"""
    ...

@gptooldoc("ApplyRelativeMainlineLayout_un", None)
def ApplyRelativeMainlineLayout(
    in_network_diagram_layer=...,
    line_attribute=...,
    mainline_direction=...,
    offset_between_branches=...,
    breakpoint_angle=...,
    type_attribute=...,
    mainline_values=...,
    branch_values=...,
    excluded_values=...,
    is_compressing=...,
    compression_ratio=...,
    minimal_distance=...,
    alignment_attribute=...,
    initial_distances=...,
    length_attribute=...,
    run_async=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """ApplyRelativeMainlineLayout_un(in_network_diagram_layer, line_attribute, {mainline_direction}, {offset_between_branches}, {breakpoint_angle}, {type_attribute}, {mainline_values;mainline_values...}, {branch_values;branch_values...}, {excluded_values;excluded_values...}, {is_compressing}, {compression_ratio}, {minimal_distance}, {alignment_attribute}, {initial_distances}, {length_attribute}, {run_async})

       Apply the relative mainline layout to a diagram

    INPUTS:
     in_network_diagram_layer (Diagram Layer):
         Input Network Diagram Layer
     line_attribute (String):
         Line Attribute
     mainline_direction {String}:
         Direction
     offset_between_branches {Linear Unit}:
         Offset Between Branches
     breakpoint_angle {Double}:
         Break Point angle (in degree)
     type_attribute {String}:
         Type Attribute
     mainline_values {Value Table}:
         Mainline Values
     branch_values {Value Table}:
         Branch Values
     excluded_values {Value Table}:
         Excluded Values
     is_compressing {Boolean}:
         Compression along the direction
     compression_ratio {Double}:
         Ratio (%)
     minimal_distance {Linear Unit}:
         Minimal Distance
     alignment_attribute {String}:
         Alignment Attribute
     initial_distances {String}:
         Initial Distances
     length_attribute {String}:
         Length Attribute
     run_async {Boolean}:
         Run in asynchronous mode on the server"""
    ...
