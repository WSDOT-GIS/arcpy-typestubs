"""
This type stub file was generated by pyright.
"""
from typing import Any, Literal, Optional
from arcpy.arcobjects import mixins
from arcpy.arcobjects._base import _BaseArcObject
from .datatypes import ParameterDataType

class ArcSDESQLExecute(mixins.ArcSDESQLExecuteMixin, _BaseArcObject):
    """The ArcSDESQLExecute class provides a means of executing SQL statements
    via an enterprise geodatabase connection."""

    transactionAutoCommit = ...
    def execute(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """ArcSDESQLExecute.execute(sql_statement)

        Sends the SQL statement to the database via an ArcSDE connection. If
        execute is run outside of a transaction, a commit will automatically
        take place once the SQL DML (INSERT, UPDATE, DELETE . . .) statement
        has been executed.

          sql_statement(Variant):
        The SQL statement.

        The execute method returns a list of lists in the case where the
        statement returns rows from a table; for statements that do not
        return rows, it will return an indication of the success or failure
        of the statement ( True for success; None for failure).  Statements
        that return a single value from a single row will return the value in
        an appropriate type (string, float, float)."""
        ...
    def startTransaction(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """ArcSDESQLExecute.startTransaction()

        To control when your changes are committed to the database, call the
        startTransaction method before calling execute. This starts a
        transaction and no DML statements will be committed until the
        commitTransaction method is called."""
        ...
    def rollbackTransaction(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """ArcSDESQLExecute.rollbackTransaction()

        Rollback any DML operations to the previous commit."""
        ...
    def commitTransaction(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """ArcSDESQLExecute.commitTransaction()

        No DML statements will be committed until the CommitTransaction
        method is called.

        A commit may also occur when the connection to ArcSDE it terminated
        (check specific DBMS documentation to see how each DBMS deals with a
        disconnect while in a transaction)."""
        ...

class Array(mixins.ArrayMixin, _BaseArcObject):
    """The array object can contain points and arrays and is used to construct
    geometry objects."""

    count = ...
    def __next__(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Array.__next__()

        Returns the next object at the current index."""
        ...
    def add(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Array.add(value)

        Adds a point or array object to the end of the array

          value(Object):
        Either a point or array object can be appended to the array."""
        ...
    def getObject(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Array.getObject(index)

        Returns the object at the given index position in the array.

          index(Integer):
        The index position of the array."""
        ...
    def reset(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Array.reset()

        Sets the current enumeration index (used by the next method) back to
        the first element."""
        ...
    def next(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Array.next()

        Returns the next object at the current index."""
        ...
    def remove(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Array.remove(index)

        Removes the object at the specified index position from the array.

          index(Integer):
        The index position that will be removed."""
        ...
    def removeAll(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Array.removeAll()

        Removes all values and creates an empty object."""
        ...
    def insert(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Array.insert(index, value)

        Adds an object to the array at the specified index.

          index(Integer):
        The index position of the array.

          value(Object):
        Either a point or array object can be inserted into the array."""
        ...
    def replace(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Array.replace(index, value)

        Replaces the object at the specified index position in the array.

          index(Integer):
        The index position that will be replaced.

          value(Object):
        The new point or array object to be added to the array."""
        ...
    def clone(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Array.clone(point_object)

        Clone the point object.

          point_object(Point):
        A point object."""
        ...

class Cursor(mixins.CursorMixin, _BaseArcObject):
    """A cursor is a data access object that can be used either to iterate
    through the set of rows in a table or to insert new rows into a table.
    Cursors have three forms: search , insert , or update . Cursors are
    commonly used to read and update attributes."""

    def __next__(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Cursor.__next__()

        Returns the next object at the current index."""
        ...
    def reset(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Cursor.reset()

        Sets the current enumeration index (used by the next method) back to
        the first element."""
        ...
    def next(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Cursor.next()

        Returns the next object at the current index."""
        ...
    def newRow(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Cursor.newRow()

        Creates an empty row object."""
        ...
    def updateRow(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Cursor.updateRow(row)

        The updateRow method can be used to update the row at the current
        position of an update cursor.

          row(Row):
        The row used to update the current position of the cursor."""
        ...
    def insertRow(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Cursor.insertRow(row)

        Inserts a new row into the database.

          row(Row):
        The row to be inserted."""
        ...
    def deleteRow(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Cursor.deleteRow(row)

        Deletes a row in the database. The row corresponding to the current
        position of the cursor will be deleted.

          row(Row):
        The row to be deleted."""
        ...

class Extent(mixins.ExtentMixin, _BaseArcObject):
    """An extent is a rectangle specified by providing the coordinate of the
    lower left corner and the coordinate of the upper right corner in map
    units."""

    XMin = ...
    YMin = ...
    XMax = ...
    YMax = ...
    MMin = ...
    MMax = ...
    ZMin = ...
    ZMax = ...
    width = ...
    height = ...
    depth = ...
    lowerLeft = ...
    lowerRight = ...
    upperLeft = ...
    upperRight = ...
    spatialReference = ...
    geohash = ...
    geohashNeighbors = ...
    geohashCovers = ...
    polygon = ...
    JSON = ...
    def contains(
        self, second_geometry, relation=...
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Extent.contains(second_geometry)

        Indicates if the base geometry contains the comparison geometry.

        contains is the opposite of within .

        Only True relationships are shown in this illustration.  Possible
        contains relationships

          second_geometry(Object):
        A second geometry."""
        ...
    def crosses(
        self, second_geometry
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Extent.crosses(second_geometry)

        Indicates if the two geometries intersect in a geometry of a lesser
        shape type.

        Two polylines cross if they share only points in common, at least
        one of which is not an endpoint. A polyline and an polygon cross if
        they share a polyline or a point (for vertical line) in common on
        the interior of the polygon which is not equivalent to the entire
        polyline.

        Only True relationships are shown in this illustration.  Possible
        crosses relationships

          second_geometry(Object):
        A second geometry."""
        ...
    def disjoint(
        self, second_geometry
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Extent.disjoint(second_geometry)

        Indicates if the base and comparison geometries share no points in
        common.

        Two
        geometries intersect if disjoint returns False .

        Only True relationships are shown in this illustration.  Possible
        disjoint relationships

          second_geometry(Object):
        A second geometry."""
        ...
    def equals(
        self, second_geometry
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Extent.equals(second_geometry)

        Indicates if the base and comparison geometries are of the same shape
        type and define the
        same set of points in the plane.  This is a 2D comparison  only; M
        and Z values are ignored.

        Only True relationships are shown in this illustration.  Possible
        equals relationships

          second_geometry(Object):
        A second geometry."""
        ...
    def overlaps(
        self, second_geometry
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Extent.overlaps(second_geometry)

        Indicates if the intersection of the two geometries has the same
        shape type as one of the input geometries and is not equivalent to
        either of the input geometries.

        Only True relationships are shown in this illustration.  Possible
        overlaps relationships

          second_geometry(Object):
        A second geometry."""
        ...
    def touches(
        self, second_geometry
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Extent.touches(second_geometry)

        Indicates if the boundaries of the geometries intersect.

        Two geometries touch when the intersection of the
        geometries is not empty, but the intersection of their interiors is
        empty. For example, a point touches a polyline only if the point is
        coincident with one of the polyline end points.

        Only True relationships are shown in this illustration.  Possible
        touches relationships

          second_geometry(Object):
        A second geometry."""
        ...
    def within(
        self, second_geometry, relation=...
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Extent.within(second_geometry)

        Indicates if the base geometry is within the comparison geometry.

        within is the opposite operator of contains .

        Only True relationships are shown in this illustration.

          Possible within relationships

          second_geometry(Object):
        A second geometry."""
        ...
    def projectAs(
        self, spatial_reference, transformation_name=...
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Extent.projectAs(spatial_reference, {transformation_name})

        Projects a geometry and optionally applies a geotransformation.

        To project, the geometry needs to have a spatial reference, and not
        have an UnknownCoordinateSystem . The new spatial reference system
        passed to the method defines the output coordinate system. If either
        spatial reference is unknown the coordinates will not be changed. The
        Z- and measure values are not changed by the ProjectAs method.

          spatial_reference(SpatialReference):
        The new spatial reference.
        This can be a SpatialReference object or the coordinate system name.

          transformation_name{String}:
        The geotransformation name."""
        ...

class FeatureSet(mixins.FeatureSetMixin, _BaseArcObject):
    """FeatureSet objects are a lightweight representation of a feature class.
    They are a special data element that contains not only schema, but also
    the data. The FeatureSet object is also how feature data is sent and
    received from the server."""

    JSON = ...
    GeoJSON = ...
    def load(
        self, *args, **kwargs
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """FeatureSet.load(table_path)

        Import from a table.

          table_path(String):
        The table to be imported.
          where_clause(String):
        An SQL expression used to select a subset of records.
          time_filter(String):
        The time instant or the time extent to query.
          renderer(String):
        Renderer of the FeatureSet.
          is_renderer(Bool):
        Specifies the type of the value used with the renderer.
          geojson_geometry_type(String):
        Specifieds the type of geometry to load from geojson."""
        ...
    def save(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """FeatureSet.save(table_path)

        Export to a table.

          table_path(String):
        The output table to be created."""
        ...

class Field(mixins.FieldMixin, _BaseArcObject):
    """The field object represents a column in a table. A field has many
    properties, the most obvious ones being its name and its type."""

    name = ...
    aliasName = ...
    baseName = ...
    domain = ...
    type = ...
    length = ...
    precision = ...
    scale = ...
    editable = ...
    isNullable = ...
    required = ...
    defaultValue = ...

class FieldInfo(mixins.FieldInfoMixin, _BaseArcObject):
    """Provides field info methods and properties for layer and table views."""

    count = ...
    def addField(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """FieldInfo.addField(field_name, new_field_name, visible, split_rule)

        Adds a field info entry

          field_name(String):
        The field name from the input feature class or table.

          new_field_name(String):
        Sets the field name for the new layer or table view.

          visible(String):
        Sets whether the field is visible or hidden.

         * VISIBLE:   Field is visible.

         * HIDDEN:   Field is hidden.

          split_rule(String):
        Sets the behavior of an attribute's values when a feature is split.

         * NONE:   The attributes of the two resulting features take on a
         copy of the original value.

         * RATIO:   The attributes of resulting features are a ratio of the
         original feature's value. The ratio is based on the division of the
         original geometry. If the geometry is divided equally, each new
         feature's attribute gets one-half of the value of the original
         object's attribute."""
        ...
    def getFieldName(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """FieldInfo.getFieldName(index)

        Gets the field name from the table by index position.

          index(Integer):
        The index position."""
        ...
    def getNewName(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """FieldInfo.getNewName(index)

        Gets the new field name from the table by index position.

          index(Integer):
        The index position."""
        ...
    def getSplitRule(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """FieldInfo.getSplitRule(index)

        Gets the split rule from the table by index position.

          index(String):
        The index position."""
        ...
    def getVisible(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """FieldInfo.getVisible(index)

        Gets the visible flag from the table by index position.

          index(String):
        The index position."""
        ...
    def setFieldName(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """FieldInfo.setFieldName(index, field_name)

        Sets the field name into the table.

          index(Integer):
        The index position.

          field_name(String):
        The field name to set into the table."""
        ...
    def setNewName(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """FieldInfo.setNewName(index, new_field_name)

        Sets the new field name into the table.

          index(None):
        The index position.

          new_field_name(String):
        The new field name to set into the table."""
        ...
    def setSplitRule(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """FieldInfo.setSplitRule(index, rule)

        Sets the split rule into the table.

          index(Integer):
        The index position.

          rule(String):
        The split rule to set into the table.

         * NONE:   The attributes of the two resulting features take on a
         copy of the original value.

         * RATIO:   The attributes of resulting features are a ratio of the
         original feature's value. The ratio is based on the division of the
         original geometry. If the geometry is divided equally, each new
         feature's attribute gets one-half of the value of the original
         object's attribute."""
        ...
    def setVisible(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """FieldInfo.setVisible(index, visible)

        Set the visible flag of a field on the table.

          index(Integer):
        The index position.

          visible(String):
        The visible policy to set into the table.

         * VISIBLE:   Field is visible.

         * HIDDEN:   Field is hidden."""
        ...
    def removeField(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """FieldInfo.removeField(index)

        Removes the field info entry from a table.

          index(Integer):
        The index position of the field info object."""
        ...
    def findFieldByName(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """FieldInfo.findFieldByName(field_name)

        Finds the field index by field name

          field_name(String):
        The field name used to find its index position"""
        ...
    def findFieldByNewName(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """FieldInfo.findFieldByNewName(field_name)

        Finds the field index by new field name.

          field_name(String):
        The new field name used to find its index position."""
        ...
    def loadFromString(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """FieldInfo.loadFromString(string)

        Restore the object using its string representation.     The
        exportToString method can be used to create a string representation.

          string(String):
        The string representation of the object."""
        ...
    def exportToString(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """FieldInfo.exportToString()

        Exports the object to its string representation."""
        ...

class FieldMap(mixins.FieldMapMixin, _BaseArcObject):
    """The FieldMap object provides a field definition and a list of input
    fields taken from a set of tables or feature classes."""

    mergeRule = ...
    outputField = ...
    joinDelimiter = ...
    inputFieldCount = ...
    def addInputField(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """FieldMap.addInputField(table_dataset, field_name, {start_position},
        {end_position})

        Adds input field to the field map.

          table_dataset(String):
        The table added to the field map.

          field_name(String):
        The input field name.

          start_position{Integer}:
        The start position of an input text value.

          end_position{Integer}:
        The end position of an input text value."""
        ...
    def getInputTableName(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """FieldMap.getInputTableName(index)

        Gets the name of an input table from the field map, based on the
        table's index.

          index(Integer):
        The index position."""
        ...
    def getInputFieldName(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """FieldMap.getInputFieldName(index)

        Gets the name of an input field from the field map, based on the
        field's index.

          index(Integer):
        The index position."""
        ...
    def getStartTextPosition(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """FieldMap.getStartTextPosition(index)

        Gets start text position from the field map.

          index(Integer):
        The index position."""
        ...
    def getEndTextPosition(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """FieldMap.getEndTextPosition(index)

        Gets end text position from the field map.

          index(Integer):
        The index position."""
        ...
    def removeAll(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """FieldMap.removeAll()

        Removes all values and creates an empty object."""
        ...
    def removeInputField(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """FieldMap.removeInputField(index)

        Removes an input field from the field map.

          index(Integer):
        The index position."""
        ...
    def findInputFieldIndex(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """FieldMap.findInputFieldIndex(table_dataset, field_name)

        Finds an input field from the field map.

          table_dataset(String):
        The table added to the field map.

          field_name(String):
        The field name."""
        ...
    def setStartTextPosition(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """FieldMap.setStartTextPosition(index, start_position)

        Sets the start text position from the field map.

          index(Integer):
        The index position.

          start_position(Integer):
        The start position of an input text value."""
        ...
    def setEndTextPosition(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """FieldMap.setEndTextPosition(index, end_position)

        Sets end text position for the field map.

          index(Integer):
        The index position.

          end_position(Integer):
        The end position of an input text value."""
        ...

class FieldMappings(mixins.FieldMappingsMixin, _BaseArcObject):
    """The FieldMappings object is a collection of FieldMap objects and it is
    used as the parameter value for tools that perform field mapping, such as
    Merge."""

    fieldValidationWorkspace = ...
    fieldCount = ...
    fields = ...
    fieldMappings = ...
    def addTable(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """FieldMappings.addTable(table_dataset)

        Adds a table to the field mappings object.

          table_dataset(String):
        The table to add to the field mappings object."""
        ...
    def removeAll(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """FieldMappings.removeAll()

        Removes all values and creates an empty object."""
        ...
    def addFieldMap(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """FieldMappings.addFieldMap(field_map)

        Add a field map to the field mappings.

          field_map(FieldMap):
        The field map to add to the field mappings"""
        ...
    def getFieldMap(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """FieldMappings.getFieldMap(index)

        Gets a field map from the field mappings.

          index(Integer):
        The index position of the field map."""
        ...
    def replaceFieldMap(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """FieldMappings.replaceFieldMap(index, value)

        Replace a field map within the field mappings.

          index(Integer):
        The index position of the field map to be replaced.

          value(FieldMap):
        The replacement field map."""
        ...
    def removeFieldMap(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """FieldMappings.removeFieldMap(index)

        Removes a field map from the field mappings.

          index(Integer):
        The index position of the field map."""
        ...
    def findFieldMapIndex(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """FieldMappings.findFieldMapIndex(field_map_name)

        Find a field map within the field mappings by name.

          field_map_name(String):
        Find the field map by name."""
        ...
    def loadFromString(
        self, string: str
    ) -> (
        ...
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """FieldMappings.loadFromString(string)

        Restore the object using its string representation.     The
        exportToString method can be used to create a string representation.

          string(String):
        The string representation of the object."""
        ...
    def exportToString(self) -> str:
        """FieldMappings.exportToString()

        Exports the object to its string representation."""
        ...

FilterType = Literal["ValueList", "Range", "FeatureClass", "File", "Field", "Workspace"]

class Filter(_BaseArcObject):
    """The filter object allows you to specify the choices available for a
    parameter."""

    type: str = ...
    list: list[Any] = ...

class GeoProcessor(_BaseArcObject):
    messageCount = ...
    maxSeverity = ...
    parameterCount = ...
    toolbox = ...
    overwriteOutput = ...
    logHistory = ...
    logLineage = ...
    scriptVersion = ...
    severityLevel = ...
    def getInstallInfo(self, *args): ...
    def listInstallations(self, *args): ...
    def setProgressor(self, *args): ...
    def resetProgressor(self, *args): ...
    def setProgressorLabel(self, *args): ...
    def setProgressorPosition(self, *args): ...
    def resetEnvironments(self, *args): ...
    def clearEnvironment(self, *args): ...
    def getMessage(self, *args): ...
    def getSeverity(self, *args): ...
    def getReturnCode(self, *args): ...
    def getMessages(self, *args): ...
    def addMessage(self, *args): ...
    def addIDMessage(self, *args): ...
    def getIDMessage(self, *args): ...
    def addError(self, *args): ...
    def addWarning(self, *args): ...
    def addReturnMessage(self, *args): ...
    def productInfo(self, *args): ...
    def setProduct(self, *args): ...
    def checkProduct(self, *args): ...
    def checkOutExtension(self, *args): ...
    def checkInExtension(self, *args): ...
    def checkExtension(self, *args): ...
    def getParameterAsText(self, *args): ...
    def setParameterAsText(self, *args): ...
    def getParameter(self, *args): ...
    def setParameter(self, *args): ...
    def copyParameter(self, *args): ...
    def setParameterSymbology(self, *args): ...
    def listFiles(self, *args): ...
    def listTools(self, *args): ...
    def listEnvironments(self, *args): ...
    def listToolboxes(self, *args): ...
    def addToolbox(self, *args): ...
    def removeToolbox(self, *args): ...
    def getSystemEnvironment(self, *args): ...
    def command(self, *args): ...
    def usage(self, *args): ...
    def exists(self, *args): ...
    def listFeatureClasses(self, *args): ...
    def listDatasets(self, *args): ...
    def listTables(self, *args): ...
    def listRasters(self, *args): ...
    def listWorkspaces(self, *args): ...
    def listVersions(self, *args): ...
    def listUsers(self, *args): ...
    def disconnectUser(self, *args): ...
    def listFields(self, *args): ...
    def listIndexes(self, *args): ...
    def searchCursor(self, *args): ...
    def updateCursor(self, *args): ...
    def insertCursor(self, *args): ...
    def describe(self, *args): ...
    def createObject(self, *args): ...
    def validateFieldName(self, *args): ...
    def validateTableName(self, *args): ...
    def parseFieldName(self, *args): ...
    def parseTableName(self, *args): ...
    def createScratchName(self, *args): ...
    def createUniqueName(self, *args): ...
    def testSchemaLock(self, *args): ...
    def createRandomValueGenerator(self, *args): ...
    def isSynchronous(self, *args): ...
    def getParameterCount(self, *args): ...
    def getParameterValue(self, *args): ...
    def getParameterInfo(self, *args): ...
    def addFieldDelimiters(self, *args): ...
    def listPrinterNames(self, *args): ...
    def wildcardMatch(self, *args): ...
    def alterAliasName(self, *args): ...
    def listSpatialReferences(self, *args): ...
    def listTransformations(self, *args): ...
    def acceptConnections(self, *args): ...
    def logUsageMetering(self, *args): ...
    def createGPSDDraft(self, *args): ...
    def fromEsriJson(self, *args): ...
    def listDataStoreItems(self, *args): ...
    def validateDataStoreItem(self, *args): ...
    def removeDataStoreItem(self, *args): ...
    def addDataStoreItem(self, *args): ...
    def getSigninToken(self, *args): ...
    def getActivePortalURL(self, *args): ...
    def listPortalURLs(self, *args): ...
    def getPortalDescription(self, *args): ...
    def getPortalInfo(self, *args): ...
    def decryptPYT(self, *args): ...
    def encryptPYT(self, *args): ...

class Geometry(mixins.GeometrySpecializationMixin, _BaseArcObject):
    """Geometry objects define a spatial location and an associated geometric
    shape."""

    labelPoint = ...
    type = ...
    extent = ...
    trueCentroid = ...
    firstPoint = ...
    lastPoint = ...
    isMultipart = ...
    hullRectangle = ...
    area = ...
    length = ...
    length3D = ...
    partCount = ...
    pointCount = ...
    centroid = ...
    WKB = ...
    WKT = ...
    spatialReference = ...
    JSON = ...
    hasCurves = ...
    def getPart(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Geometry.getPart({index})

        Returns an array of point objects for a particular part of geometry
        or an array containing a number of arrays, one for each part.

          index{Integer}:
        The index position of the geometry."""
        ...
    def contains(
        self, second_geometry, relation=...
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Geometry.contains(second_geometry)

        Indicates if the base geometry contains the comparison geometry.

        contains is the opposite of within .

        Only True relationships are shown in this illustration.  Possible
        contains relationships

          second_geometry(Object):
        A second geometry."""
        ...
    def crosses(
        self, second_geometry
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Geometry.crosses(second_geometry)

        Indicates if the two geometries intersect in a geometry of a lesser
        shape type.

        Two polylines cross if they share only points in common, at least
        one of which is not an endpoint. A polyline and an polygon cross if
        they share a polyline or a point (for vertical line) in common on
        the interior of the polygon which is not equivalent to the entire
        polyline.

        Only True relationships are shown in this illustration.  Possible
        crosses relationships

          second_geometry(Object):
        A second geometry."""
        ...
    def disjoint(
        self, second_geometry
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Geometry.disjoint(second_geometry)

        Indicates if the base and comparison geometries share no points in
        common.

        Two
        geometries intersect if disjoint returns False .

        Only True relationships are shown in this illustration.  Possible
        disjoint relationships

          second_geometry(Object):
        A second geometry."""
        ...
    def equals(
        self, second_geometry
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Geometry.equals(second_geometry)

        Indicates if the base and comparison geometries are of the same shape
        type and define the
        same set of points in the plane.  This is a 2D comparison  only; M
        and Z values are ignored.

        Only True relationships are shown in this illustration.  Possible
        equals relationships

          second_geometry(Object):
        A second geometry."""
        ...
    def overlaps(
        self, second_geometry
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Geometry.overlaps(second_geometry)

        Indicates if the intersection of the two geometries has the same
        shape type as one of the input geometries and is not equivalent to
        either of the input geometries.

        Only True relationships are shown in this illustration.  Possible
        overlaps relationships

          second_geometry(Object):
        A second geometry."""
        ...
    def touches(
        self, second_geometry
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Geometry.touches(second_geometry)

        Indicates if the boundaries of the geometries intersect.

        Two geometries touch when the intersection of the
        geometries is not empty, but the intersection of their interiors is
        empty. For example, a point touches a polyline only if the point is
        coincident with one of the polyline end points.

        Only True relationships are shown in this illustration.  Possible
        touches relationships

          second_geometry(Object):
        A second geometry."""
        ...
    def within(
        self, second_geometry, relation=...
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Geometry.within(second_geometry)

        Indicates if the base geometry is within the comparison geometry.

        within is the opposite operator of contains .

        Only True relationships are shown in this illustration.

          Possible within relationships

          second_geometry(Object):
        A second geometry."""
        ...
    def projectAs(
        self, spatial_reference, transformation_name=...
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Geometry.projectAs(spatial_reference, {transformation_name})

        Projects a geometry and optionally applies a geotransformation.

        To project, the geometry needs to have a spatial reference, and not
        have an UnknownCoordinateSystem . The new spatial reference system
        passed to the method defines the output coordinate system. If either
        spatial reference is unknown the coordinates will not be changed. The
        Z- and measure values are not changed by the ProjectAs method.

          spatial_reference(SpatialReference):
        The new spatial reference.
        This can be a SpatialReference object or the coordinate system name.

          transformation_name{String}:
        The geotransformation name."""
        ...
    def positionAlongLine(
        self, value, use_percentage=..., geodesic=...
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Geometry.positionAlongLine(value, {use_percentage})

        Returns a point on a line at a specified distance from
        the beginning of the line.

          value(Double):
        The distance along the line.

        If the distance is less than zero, then the starting point of the
        line will be returned; if the distance is greater than the length of
        the line, then the end point of the line will be returned.

          use_percentage{Boolean}:
        The distance may be specified as a fixed unit of measure or a ratio
        of the length of the line.

        If True, value is used as a percentage; if False, value is used as a
        distance.  For percentages, the value should be expressed as a double
        from 0.0 (0%) to 1.0 (100%).

          geodesic{Boolean}:
        Indication of whether the distance measure is geodesic based or not.

        If True, the distance measure is treated as geodesic; if False, the
        distance measure is treated as planar.
        """
        ...
    def queryPointAndDistance(
        self, in_point, use_percentage=...
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Geometry.queryPointAndDistance(in_point, {as_percentage})

        Finds the point on the polyline nearest to the in_point and the
        distance between those points.  Also returns information about the
        side of the line the in_point is on as well as the distance along the
        line where the nearest point occurs.

          in_point(PointGeometry):
        The input point ( PointGeometry or Point ).

          as_percentage{Boolean}:
        If False , the measure will be returned as a distance; if True , the
        measure will be returned as a percentage."""
        ...
    def snapToLine(
        self, in_point
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Geometry.snapToLine(in_point)

        Returns a new point based on in_point snapped to this geometry.

          in_point(PointGeometry):
        A point ( PointGeometry or Point ) to be snapped to the line."""
        ...
    def measureOnLine(
        self, in_point, use_percentage=...
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Geometry.measureOnLine(in_point, {use_percentage})

        Returns a measure from the start point of this line to the in_point .

          in_point(PointGeometry):
        A point ( PointGeometry or Point ) that is used to measure from the
        start point of the polyline.

          use_percentage{Boolean}:
        If False , the measure will be returned as a distance; if True , the
        measure will be returned as a percentage."""
        ...
    def generalize(self, distance): ...
    def getLength(
        self, method=..., units=...
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Geometry.getLength({method}, {units})

        Returns the length of the feature using a measurement type.

          method{String}:
        PLANAR measurements reflect the projection of geographic data onto
        the 2D surface (in other words, they will not take into account the
        curvature of the earth). GEODESIC , GREAT_ELLIPTIC , LOXODROME ,  and
        PRESERVE_SHAPE measurement types may be chosen as an alternative, if
        desired.

         * GEODESIC: The shortest line between any two points on the earth's
         surface on a spheroid (ellipsoid). One use for a geodesic line is
         when you want to determine the shortest distance between two cities
         for an airplane's flight path. This is also known as a great circle
         line if based on a sphere rather than an ellipsoid.

         * GREAT_ELLIPTIC: The line on a spheroid (ellipsoid) defined by the
         intersection at the surface by a plane that passes through the
         center of the spheroid and the start and endpoints of a segment.
         This is also known as a great circle when a sphere is used.

         * LOXODROME: A loxodrome is not the shortest distance between two
         points but instead defines the line of constant bearing, or azimuth.
         Great circle routes are often broken into a series of loxodromes,
         which simplifies navigation. This is also known as a rhumb line.

         * PLANAR: Planar measurements use 2D Cartesian mathematics to
         calculate lengths and areas. This option is only available when
         measuring in a projected coordinate system and the 2D plane of that
         coordinate system will be used as the basis for the measurements.

         * PRESERVE_SHAPE: This type calculates the area or length of the
         geometry on the surface of the earth ellipsoid, for geometry defined
         in a projected or geographic coordinate system. This option
         preserves the shape of the geometry in its coordinate system.

          units{String}:
        The units in which the length will be calculated.

        Linear unit of measure keywords: CENTIMETERS | DECIMETERS | FEET |
        INCHES | KILOMETERS | METERS | MILES | MILLIMETERS | NAUTICALMILES |
        YARDS"""
        ...
    def getArea(
        self, method=..., units=...
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Geometry.getArea({method}, {units})

        Returns the area of the feature using a measurement type.

          method{String}:
        PLANAR measurements reflect the projection of geographic data onto
        the 2D surface (in other words, they will not take into account the
        curvature of the earth). GEODESIC , GREAT_ELLIPTIC , LOXODROME ,  and
        PRESERVE_SHAPE measurement types may be chosen as an alternative, if
        desired.

         * GEODESIC: The shortest line between any two points on the earth's
         surface on a spheroid (ellipsoid). One use for a geodesic line is
         when you want to determine the shortest distance between two cities
         for an airplane's flight path. This is also known as a great circle
         line if based on a sphere rather than an ellipsoid.

         * GREAT_ELLIPTIC: The line on a spheroid (ellipsoid) defined by the
         intersection at the surface by a plane that passes through the
         center of the spheroid and the start and endpoints of a segment.
         This is also known as a great circle when a sphere is used.

         * LOXODROME: A loxodrome is not the shortest distance between two
         points but instead defines the line of constant bearing, or azimuth.
         Great circle routes are often broken into a series of loxodromes,
         which simplifies navigation. This is also known as a rhumb line.

         * PLANAR: Planar measurements use 2D Cartesian mathematics to
         calculate lengths and areas. This option is only available when
         measuring in a projected coordinate system and the 2D plane of that
         coordinate system will be used as the basis for the measurements.

         * PRESERVE_SHAPE: This type calculates the area or length of the
         geometry on the surface of the earth ellipsoid, for geometry defined
         in a projected or geographic coordinate system. This option
         preserves the shape of the geometry in its coordinate system.

          units{String}:
        The units in which the area will be calculated.

        Areal unit of measure keywords: ACRES | ARES | HECTARES |
        SQUARECENTIMETERS | SQUAREDECIMETERS | SQUAREINCHES | SQUAREFEET |
        SQUAREKILOMETERS | SQUAREMETERS | SQUAREMILES | SQUAREMILLIMETERS |
        SQUAREYARDS"""
        ...
    def getGeohash(
        self, precision=...
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """getGeohash(precision)

        Converts a PointGeometry in geographic coordinate system coordinates
        of latitude and longitude to a geohash string that is accurate to an
        arbitrary precision within a bounding box in the geohash grid.

          precision(Integer):
        The precision length of the hash string to return for the
        PointGeometry . The minimum length is 1 and the maximum length is 20.
        The default length is 8."""
        ...
    def segmentAlongLine(
        self, start_measure, end_measure, use_percentage=...
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Geometry.segmentAlongLine(start_measure, end_measure,
        {use_percentage})

        Returns a Polyline between start and end measures. Similar to
        Polyline.positionAlongLine but will return a polyline segment between
        two points on the polyline instead of a single point.

          start_measure(Double):
        The starting distance from the beginning of the line.

          end_measure(Double):
        The ending distance from the beginning of the line.

          use_percentage{Boolean}:
        The start and end measures may be specified as fixed units or as a
        ratio.

        If True, start_measure and end_measure are used as a percentage; if
        False, start_measure and end_measure are used as a distance.  For
        percentages, the measures should be expressed as a double from 0.0 (0
        percent) to 1.0 (100 percent)."""
        ...
    def angleAndDistanceTo(
        self, other_geometry, method=...
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Geometry.angleAndDistanceTo(other, {method})

        Returns a tuple of angle and distance to another point using a
        measurement type.

          other(PointGeometry):
        The second geometry.

          method{String}:
        PLANAR measurements reflect the projection of geographic data onto
        the 2D surface (in other words, they will not take into account the
        curvature of the earth). GEODESIC , GREAT_ELLIPTIC , LOXODROME ,  and
        PRESERVE_SHAPE measurement types may be chosen as an alternative, if
        desired.

         * GEODESIC: The shortest line between any two points on the earth's
         surface on a spheroid (ellipsoid). One use for a geodesic line is
         when you want to determine the shortest distance between two cities
         for an airplane's flight path. This is also known as a great circle
         line if based on a sphere rather than an ellipsoid.

         * GREAT_ELLIPTIC: The line on a spheroid (ellipsoid) defined by the
         intersection at the surface by a plane that passes through the
         center of the spheroid and the start and endpoints of a segment.
         This is also known as a great circle when a sphere is used.

         * LOXODROME: A loxodrome is not the shortest distance between two
         points but instead defines the line of constant bearing, or azimuth.
         Great circle routes are often broken into a series of loxodromes,
         which simplifies navigation. This is also known as a rhumb line.

         * PLANAR: Planar measurements use 2D Cartesian mathematics to
         calculate lengths and areas. This option is only available when
         measuring in a projected coordinate system and the 2D plane of that
         coordinate system will be used as the basis for the measurements.

         * PRESERVE_SHAPE: This type calculates the area or length of the
         geometry on the surface of the earth ellipsoid, for geometry defined
         in a projected or geographic coordinate system. This option
         preserves the shape of the geometry in its coordinate system."""
        ...
    def pointFromAngleAndDistance(
        self, angle, distance, method=...
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Geometry.pointFromAngleAndDistance(angle, distance, {method})

        Returns a point at a given angle and distance in degrees and meters
        using the specified measurement type.

          angle(Double):
        The angle in degrees to the returned point.

          distance(Double):
        The distance in meters to the returned point.

          method{String}:
        PLANAR measurements reflect the projection of geographic data onto
        the 2D surface (in other words, they will not take into account the
        curvature of the earth). GEODESIC , GREAT_ELLIPTIC , LOXODROME ,  and
        PRESERVE_SHAPE measurement types may be chosen as an alternative, if
        desired.

         * GEODESIC: The shortest line between any two points on the earth's
         surface on a spheroid (ellipsoid). One use for a geodesic line is
         when you want to determine the shortest distance between two cities
         for an airplane's flight path. This is also known as a great circle
         line if based on a sphere rather than an ellipsoid.

         * GREAT_ELLIPTIC: The line on a spheroid (ellipsoid) defined by the
         intersection at the surface by a plane that passes through the
         center of the spheroid and the start and endpoints of a segment.
         This is also known as a great circle when a sphere is used.

         * LOXODROME: A loxodrome is not the shortest distance between two
         points but instead defines the line of constant bearing, or azimuth.
         Great circle routes are often broken into a series of loxodromes,
         which simplifies navigation. This is also known as a rhumb line.

         * PLANAR: Planar measurements use 2D Cartesian mathematics to
         calculate lengths and areas. This option is only available when
         measuring in a projected coordinate system and the 2D plane of that
         coordinate system will be used as the basis for the measurements.

         * PRESERVE_SHAPE: This type calculates the area or length of the
         geometry on the surface of the earth ellipsoid, for geometry defined
         in a projected or geographic coordinate system. This option
         preserves the shape of the geometry in its coordinate system."""
        ...
    def boundary(
        self,
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Geometry.boundary()

        Constructs the boundary of the geometry.   Boundary operator"""
        ...
    def buffer(
        self, distance
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Geometry.buffer(distance)

        Constructs a polygon at a specified distance from the geometry.
        Buffer operator

          distance(Double):
        The buffer distance.

        The buffer distance is in the same units as the geometry that
        is being buffered.

        A negative distance can only be specified against a polygon geometry."""
        ...
    def clip(
        self, envelope
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Geometry.clip(envelope)

        Constructs the intersection of the geometry and the specified extent.
        Clip operator

          envelope(Extent):
        An extent object used to define the clip extent."""
        ...
    def convexHull(
        self,
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Geometry.convexHull()

        Constructs the geometry that is the minimal bounding polygon such
        that all outer
        angles are convex.   ConvexHull operator"""
        ...
    def difference(
        self, other
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Geometry.difference(other)

        Constructs the geometry that is composed only of the region unique to
        the
        base geometry but not part of the other geometry. The following
        illustration shows the results when the red polygon is the source
        geometry.   Difference operator

          other(Object):
        A second geometry."""
        ...
    def intersect(
        self, other, dimension
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Geometry.intersect(other, dimension)

        Constructs a geometry that is the geometric intersection of
        the two input geometries. Different dimension values can be used to
        create different shape types.

        The intersection of two geometries of the same shape type is a
        geometry containing only the regions of overlap between the
        original geometries.  Intersect operator

        For faster results, test if the two geometries are disjoint before
        calling intersect .

          other(Object):
        The second geometry.

          dimension(Integer):
        The topological dimension (shape type) of the resulting geometry.

         * 1: A zero-dimensional geometry (point or multipoint).

         * 2: A one-dimensional geometry (polyline).

         * 4: A two-dimensional geometry (polygon)."""
        ...
    def symmetricDifference(
        self, other
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Geometry.symmetricDifference(other)

        Constructs
        the geometry that is the union of two geometries minus the
        instersection of those geometries.

        The two input geometries must be the same shape type.
        symmetricDifference operator

          other(Object):
        A second geometry."""
        ...
    def union(
        self, other
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Geometry.union(other)

        Constructs the geometry that is the set-theoretic union of the input
        geometries.

        The two geometries being unioned must be the same shape type.  Union
        operator

          other(Object):
        A second geometry."""
        ...
    def distanceTo(
        self, other
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Geometry.distanceTo(other)

        Returns the minimum distance between two geometries. If the
        geometries intersect, the minimum distance is 0.

        Both geometries must have the same projection.

          other(Object):
        A second geometry."""
        ...
    def cut(
        self, other
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Geometry.cut(cutter)

        Splits this geometry into a part left of the cutting polyline, and a
        part right of it.

        When a polyline or polygon is cut, it is split where it intersects
        the cutter polyline. Each piece is classified as left of or right of
        the cutter. This classification is based on the orientation of the
        cutter line. Parts of the target polyline that do not intersect the
        cutting polyline are returned as part of the right of result for that
        input polyline. If a geometry is not cut, the left geometry will be
        empty ( None ).  Cut operator

          cutter(PolyLine):
        The cutting polyline geometry."""
        ...
    def densify(
        self, method, distance=..., deviation=...
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Geometry.densify(method, distance, deviation)

        Creates a new geometry with

        added vertices.

          method(String):
        The method of densification, DISTANCE , ANGLE , or GEODESIC .

         * DISTANCE: Creates a new  feature that is a piecewise linear
         approximation of the input.

         * ANGLE: Creates a new  feature that is a piecewise linear
         approximation of the input. Vertices are introduced at points where
         the angle between tangents at those points is the provided angle .

         * GEODESIC: Densifies and reshapes segments between input vertices
         so that the output segments follow the shortest ground path
         connecting input vertices.

          distance(Double):
        The maximum distance between vertices.  The actual distance between
        vertices will usually be less than the maximum distance as new
        vertices will be evenly distributed along the original segment.

        If using a type of DISTANCE or ANGLE , the distance is measured in
        the units of the geometry's spatial reference. If using a type of
        GEODESIC , the distance is measured in meters.

          deviation(Double):
        Densify uses straight lines to approximate curves. You use deviation
        to control the accuracy of this approximation. The deviation is the
        maximum distance between the new segment and the original curve. The
        smaller its value, the more segments will be required to approximate
        the curve.

        If using a type of DISTANCE , the deviation is measured in the units
        of the geometry's spatial reference. If using a type of ANGLE , the
        deviation is measured in radians. If using a type of GEODESIC , the
        deviation is not used."""
        ...

class Index(_BaseArcObject):
    """The Index object contains information about an index on a table. There
    are two types of indexes: spatial and attribute. Spatial indexes exist on
    the shape field of a feature class."""

    name = ...
    isAscending = ...
    isUnique = ...
    fields = ...

class NetCDFFileProperties(mixins.NetCDFFilePropertiesMixin, _BaseArcObject):
    """The Network Common Data Form (netCDF) is a binary, self-describing,
    machine-independent file format for storing scientific data.

    Learn more about netCDF"""

    def getAttributeNames(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """NetCDFFileProperties.getAttributeNames({variable_name})

        Gets the attribute names of a variable in a NetCDF file.

          variable_name{String}:
        Variable name of the NetCDF file."""
        ...
    def getAttributeValue(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """NetCDFFileProperties.getAttributeValue(variable_name, attribute_name)

        Get the value of an attribute.

          variable_name(String):
        Variable name of the netCDF file.

          attribute_name(String):
        Attribute name of the netCDF file."""
        ...
    def getDimensionIndex(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """NetCDFFileProperties.getDimensionIndex(dimension_name, value)

        Gets the dimension index.

          dimension_name(String):
        Dimension name of the NetCDF file.

          value(Integer):
        The dimension value."""
        ...
    def getDimensions(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """NetCDFFileProperties.getDimensions()

        Gets the dimensions."""
        ...
    def getDimensionsByVariable(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """NetCDFFileProperties.getDimensionsByVariable(variable_name)

        Gets the dimensions by variable.

          variable_name(String):
        Variable name of the NetCDF file."""
        ...
    def getDimensionSize(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """NetCDFFileProperties.getDimensionSize(dimension_name)

        Gets the dimension size.

          dimension_name(String):
        Dimension name of the NetCDF file."""
        ...
    def getDimensionValue(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """NetCDFFileProperties.getDimensionValue(dimension_name, index)

        Gets the dimension value.

          dimension_name(String):
        Dimension name of the NetCDF file.

          index(Integer):
        The index position."""
        ...
    def getFieldType(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """NetCDFFileProperties.getFieldType(name)

        Gets the field type of a variable or dimension.

          name(String):
        Variable or dimension name of the NetCDF file."""
        ...
    def getSpatialReference(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """NetCDFFileProperties.getSpatialReference(variable_name, x_dimension,
        y_dimension)

        Gets the spatial reference of a variable.

          variable_name(String):
        Variable name of the NetCDF file.

          x_dimension(Integer):
        The x-dimension.

          y_dimension(Integer):
        The y-dimension."""
        ...
    def getVariables(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """NetCDFFileProperties.getVariables()

        Gets the variables."""
        ...
    def getVariablesByDimension(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """NetCDFFileProperties.getVariablesByDimension(dimension_name)

        Get the variables by dimension.

          dimension_name(String):
        Variable name of the netCDF file"""
        ...

class Parameter(mixins.ParameterMixin, _BaseArcObject):
    """Every tool parameter has an associated parameter object with properties
    and methods that are useful in tool validation. Parameters are contained
    in a Python list."""

    name: str = ...
    displayName: str = ...
    displayOrder: str = ...
    direction: str = ...
    datatype: ParameterDataType = ...
    charts = ...
    parameterType = ...
    parameterDependencies = ...
    enabled = ...
    value = ...
    defaultEnvironmentName = ...
    altered = ...
    hasBeenValidated = ...
    category = ...
    schema = ...
    filter = ...
    filters = ...
    symbology = ...
    message = ...
    multiValue = ...
    columns = ...
    valueAsText: str = ...
    values = ...
    controlCLSID = ...
    def setErrorMessage(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Parameter.setErrorMessage(message)

        Marks the parameter as having an error with the supplied message.
        Tools do not execute if any of the parameters have an error.

          message(String):
        The string to be added as an error message to the geoprocessing tool
        messages."""
        ...
    def setWarningMessage(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Parameter.setWarningMessage(message)

        Marks the parameter as having a warning with the supplied message.
        Unlike errors, tools will execute with warning messages.

          message(String):
        The string to be added as a warning message to the geoprocessing tool
        messages."""
        ...
    def setIDMessage(
        self,
        message_type: Literal["ERROR", "WARNING"],
        message_ID: int,
        add_argument1: Optional[object] = None,
        add_argument2: Optional[object] = None,
    ) -> None:
        """Parameter.setIDMessage(message_type, message_ID, {add_argument1},
        {add_argument2})

        Allows you to set a system message.

          message_type(String):
        Defines whether the message will be an error or a warning.

         * ERROR:   The message will be an error message.

         * WARNING:   The message will be a warning message.

          message_ID(Integer):
        The message ID allows you to reference existing system messages.

          add_argument1{Object}:
        Depending on which message ID is used, an argument may be necessary
        to complete the message. Common examples include dataset or field
        names. The datatype is variable depending on the message.

          add_argument2{Object}:
        Depending on which message ID is used, an argument may be necessary
        to complete the message. Common examples include dataset or field
        names. The datatype is variable depending on the message."""
        ...
    def clearMessage(self) -> None:
        """Parameter.clearMessage()

        Clears out any message text and sets the status to informative (no
        error or warning)."""
        ...
    def hasError(self) -> bool:
        """Parameter.hasError()

        Returns true if the parameter contains an error."""
        ...
    def hasWarning(self) -> bool:
        """Parameter.hasWarning()

        Returns True if the parameter contains a warning."""
        ...
    def isInputValueDerived(self) -> bool:
        """Parameter.isInputValueDerived()

        Returns True if the tool is being validated inside a Model and the
        input value is the output of another tool in the model."""
        ...

class Point(mixins.PointMixin, _BaseArcObject):
    """The point object is used frequently with cursors. Point features return a
    single point object instead of an array of point objects. All other
    feature typespolygon, polyline, and multipointreturn an array of point
    objects or an array containing multiple arrays of point objects if the feature has multiple parts.
    """

    X = ...
    Y = ...
    M = ...
    Z = ...
    ID = ...
    def clone(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Point.clone(point_object)

        Clone the point object.

          point_object(Point):
        A point object."""
        ...
    def contains(
        self, second_geometry, relation=...
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Point.contains(second_geometry)

        Indicates if the base geometry contains the comparison geometry.

        contains is the opposite of within .

        Only True relationships are shown in this illustration.  Possible
        contains relationships

          second_geometry(Object):
        A second geometry."""
        ...
    def crosses(
        self, second_geometry
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Point.crosses(second_geometry)

        Indicates if the two geometries intersect in a geometry of a lesser
        shape type.

        Two polylines cross if they share only points in common, at least
        one of which is not an endpoint. A polyline and an polygon cross if
        they share a polyline or a point (for vertical line) in common on
        the interior of the polygon which is not equivalent to the entire
        polyline.

        Only True relationships are shown in this illustration.  Possible
        crosses relationships

          second_geometry(Object):
        A second geometry."""
        ...
    def disjoint(
        self, second_geometry
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Point.disjoint(second_geometry)

        Indicates if the base and comparison geometries share no points in
        common.

        Two
        geometries intersect if disjoint returns False .

        Only True relationships are shown in this illustration.  Possible
        disjoint relationships

          second_geometry(Object):
        A second geometry."""
        ...
    def equals(
        self, second_geometry
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Point.equals(second_geometry)

        Indicates if the base and comparison geometries are of the same shape
        type and define the
        same set of points in the plane.  This is a 2D comparison  only; M
        and Z values are ignored.

        Only True relationships are shown in this illustration.  Possible
        equals relationships

          second_geometry(Object):
        A second geometry."""
        ...
    def overlaps(
        self, second_geometry
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Point.overlaps(second_geometry)

        Indicates if the intersection of the two geometries has the same
        shape type as one of the input geometries and is not equivalent to
        either of the input geometries.

        Only True relationships are shown in this illustration.  Possible
        overlaps relationships

          second_geometry(Object):
        A second geometry."""
        ...
    def touches(
        self, second_geometry
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Point.touches(second_geometry)

        Indicates if the boundaries of the geometries intersect.

        Two geometries touch when the intersection of the
        geometries is not empty, but the intersection of their interiors is
        empty. For example, a point touches a polyline only if the point is
        coincident with one of the polyline end points.

        Only True relationships are shown in this illustration.  Possible
        touches relationships

          second_geometry(Object):
        A second geometry."""
        ...
    def within(
        self, second_geometry, relation=...
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Point.within(second_geometry)

        Indicates if the base geometry is within the comparison geometry.

        within is the opposite operator of contains .

        Only True relationships are shown in this illustration.

          Possible within relationships

          second_geometry(Object):
        A second geometry."""
        ...

class RandomNumberGenerator(_BaseArcObject):
    """Determines the type and seed that will be used to create random numbers
    between 0 and 1 for all tools that utilize random numbers, for example,
    CreateRandomRaster, CreateRandomPoints, and the ArcGIS.Rand() function.

    Returned from the randomGenerator environment."""

    def loadFromString(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """RandomNumberGenerator.loadFromString(string)

        Restore the object using its string representation.     The
        exportToString method can be used to create a string representation.

          string(String):
        The string representation of the object."""
        ...
    def exportToString(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """RandomNumberGenerator.exportToString()

        Exports the object to its string representation."""
        ...

class RecordSet(mixins.RecordSetMixin, _BaseArcObject):
    """RecordSet objects are a lightweight representation of a table. They are a
    special data element that contains not only schema but also the data. The
    RecordSet object is also how tables are sent and received from the
    server."""

    JSON = ...
    def load(
        self, *args, **kwargs
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """RecordSet.load(table_path)

        Import from a table.

          table_path(String):
        The table to be imported.
          where_clause(String):
        An SQL expression used to select a subset of records."""
        ...
    def save(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """RecordSet.save(table_path)

        Export to a table.

          table_path(String):
        The output table to be created."""
        ...

class Result(mixins.ResultMixin, _BaseArcObject):
    """A Result object is returned by geoprocessing tools."""

    status = ...
    resultID = ...
    messageCount = ...
    maxSeverity = ...
    outputCount = ...
    inputCount = ...
    def getMessage(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Result.getMessage(index)

        Returns a specific message.

          index(Integer):
        The index position of the message."""
        ...
    def getMessages(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Result.getMessages({severity})

        Returns messages.

          severity{Integer}:
        The type of messages to be returned: 0=message, 1=warning, 2=error.
        Not specifying a value returns all message types.

         * 0:   informational message

         * 1:   warning message

         * 2:   error message"""
        ...
    def getSeverity(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Result.getSeverity(index)

        Returns the severity of a specific message.

          index(Integer):
        The message index position."""
        ...
    def getOutput(self, index: int) -> RecordSet | str:
        """Result.getOutput(index)

        Returns a given output, either as a recordset or a string.

        If the output of the tool, such as MakeFeatureLayer is a layer,
        getOutput will return a Layer object.

          index(Integer):
        The index position of the outputs."""
        ...
    def getInput(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Result.getInput(index)

        Returns a given input, either as a recordset or string.

          index(Integer):
        The index position of the input."""
        ...
    def getMapImageURL(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Result.getMapImageURL({parameter_list}, {height}, {width},
        {resolution})

        Gets a map service image for a given output, if one exists.

          parameter_list{Integer}:
        Parameter(s) on which the map service image will be based.

          height{Double}:
        The height of the image.

          width{Double}:
        The width of the image.

          resolution{Double}:
        The resolution of the image."""
        ...
    def cancel(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Result.cancel()

        Cancels an associated job"""
        ...
    def saveToFile(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Result.saveToFile(rlt_file)

        Saves the result to a result file (.rlt) .

          rlt_file(String):
        Full path to the output
        result file (.rlt) ."""
        ...

class Row(_BaseArcObject):
    """The Row object represents the row of a table. The Row object is returned
    from InsertCursor , SearchCursor , and UpdateCursor."""

    __passthrough_to_ao__ = ...
    def setValue(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Row.setValue(field_name, object)

        Sets the field value.

          field_name(String):
        The field that will be set to the new value.

          object(Object):
        The value used to set the field value."""
        ...
    def getValue(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Row.getValue(field_name)

        Gets the field value.

          field_name(String):
        The field from which the value will be accessed."""
        ...
    def setNull(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Row.setNull(field_name)

        Sets the field value to null.

          field_name(String):
        The field that will be set to null."""
        ...
    def isNull(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """Row.isNull(field_name)

        Is the field value null.

          field_name(None):
        The field to be queried."""
        ...

class Schema(_BaseArcObject):
    """The schema of a dataset."""

    type = ...
    clone = ...
    featureTypeRule = ...
    featureType = ...
    geometryTypeRule = ...
    geometryType = ...
    extentRule = ...
    extent = ...
    fieldsRule = ...
    additionalFields = ...
    cellSizeRule = ...
    cellSize = ...
    rasterRule = ...
    rasterFormatRule = ...
    additionalChildren = ...

class SpatialReference(mixins.SpatialReferenceMixin, _BaseArcObject):
    """Each part of the spatial reference has a number of properties (especially
    the coordinate system) that defines what map projection options are used
    to define horizontal coordinates."""

    type = ...
    name = ...
    alias = ...
    abbreviation = ...
    remarks = ...
    factoryCode = ...
    PCSName = ...
    PCSCode = ...
    GCSName = ...
    GCSCode = ...
    spheroidName = ...
    spheroidCode = ...
    projectionName = ...
    projectionCode = ...
    datumName = ...
    datumCode = ...
    primeMeridianName = ...
    primeMeridianCode = ...
    angularUnitName = ...
    angularUnitCode = ...
    linearUnitName = ...
    linearUnitCode = ...
    hasXYPrecision = ...
    hasZPrecision = ...
    hasMPrecision = ...
    falseOriginAndUnits = ...
    ZFalseOriginAndUnits = ...
    MFalseOriginAndUnits = ...
    domain = ...
    ZDomain = ...
    MDomain = ...
    usage = ...
    centralMeridian = ...
    centralMeridianInDegrees = ...
    longitudeOfOrigin = ...
    latitudeOfOrigin = ...
    latitudeOf1st = ...
    latitudeOf2nd = ...
    falseEasting = ...
    falseNorthing = ...
    centralParallel = ...
    standardParallel1 = ...
    standardParallel2 = ...
    longitudeOf1st = ...
    longitudeOf2nd = ...
    scaleFactor = ...
    azimuth = ...
    semiMajorAxis = ...
    semiMinorAxis = ...
    flattening = ...
    longitude = ...
    radiansPerUnit = ...
    metersPerUnit = ...
    GCS = ...
    isHighPrecision = ...
    XYTolerance = ...
    MTolerance = ...
    ZTolerance = ...
    XYResolution = ...
    MResolution = ...
    ZResolution = ...
    classification = ...
    VCS = ...
    def setFalseOriginAndUnits(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """SpatialReference.setFalseOriginAndUnits(false_x, false_y, xy_units)

        Sets the XY false origin and units.

          false_x(Double):
        The false x value.

          false_y(Double):
        The false y value.

          xy_units(String):
        The xy units."""
        ...
    def setZFalseOriginAndUnits(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """SpatialReference.setZFalseOriginAndUnits(false_z, z_units)

        Sets the Z false origin and units.

          false_z(Double):
        The false z-value.

          z_units(Double):
        The false z units."""
        ...
    def setMFalseOriginAndUnits(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """SpatialReference.setMFalseOriginAndUnits(false_m, m_units)

        Sets the M false origin and units.

          false_m(Double):
        The false m-value.

          m_units(Double):
        The m units."""
        ...
    def setDomain(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """SpatialReference.setDomain(x_min, x_max, y_min, y_max)

        Sets the XY domain.

          x_min(Double):
        The minimum x-value.

          x_max(Double):
        The maximum x-value.

          y_min(Double):
        The minimum y-value.

          y_max(Double):
        The maximum y-value."""
        ...
    def setZDomain(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """SpatialReference.setZDomain(z_min, z_max)

        Sets the Z domain.

          z_min(Double):
        The minimum z-value.

          z_max(Double):
        The maximum z-value."""
        ...
    def setMDomain(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """SpatialReference.setMDomain(m_min, m_max)

        Sets the M domain.

          m_min(Double):
        The minimum m-value.

          m_max(Double):
        The maximum m-value."""
        ...
    def createFromFile(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """SpatialReference.createFromFile(prj_file)

        Creates the spatial reference object from a projection file.

          prj_file(String):
        The projection file used to populate the spatial reference object."""
        ...
    def create(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """SpatialReference.create()

        Creates the spatial reference object using properties."""
        ...
    def loadFromString(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """SpatialReference.loadFromString(string)

        Restore the object using its string representation.     The
        exportToString method can be used to create a string representation.

          string(String):
        The string representation of the object."""
        ...
    def exportToString(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """SpatialReference.exportToString()

        Exports the object to its string representation."""
        ...

class Value(_BaseArcObject):
    """The value object is returned from GetParameterInfo when used in a script
    tool's ToolValidator class."""

    value: str | None = None
    isEmpty: bool = ...

class ValueTable(mixins.ValueTableMixin, _BaseArcObject):
    """A value table is a flexible object that can be used as input for a
    multivalue parameter. It exists only during the lifetime of the
    geoprocessing object that created it."""

    rowCount = ...
    columnCount = ...
    def setColumns(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """ValueTable.setColumns(number_of_columns)

        Sets the number of columns for the value table.

          number_of_columns(Integer):
        The number of columns for the value table."""
        ...
    def addColumns(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """ValueTable.addColumns(number_of_columns)

        Adds the number of columns for the value table.

          number_of_columns(Integer):
        The number of columns for the value table."""
        ...
    def addRow(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """ValueTable.addRow(value)

        Adds a row to the value table.

          addRow's value argument is space-delimited. Any value used in the
          value argument that contains spaces must be enclosed in quotations.
          In the following example, a value table with two columns has a
          feature class and an index value added:
          vtab.addRow("'c:/temp/land use.shp' 2")

          value(Object):
        The row to be added."""
        ...
    def getRow(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """ValueTable.getRow(row)

        Gets a row from the value table.

          row(Integer):
        The row index position."""
        ...
    def getTrueRow(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """ValueTable.getTrueRow(row)

        Gets a row from the value table.

          row(Integer):
        The row index position."""
        ...
    def getValue(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """ValueTable.getValue(row, column)

        Gets value from a given column and row.

          row(Integer):
        The row index position.

          column(Integer):
        The column index position."""
        ...
    def getTrueValue(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """ValueTable.getTrueValue(row, column)

        Gets value from a given column and row.

          row(Integer):
        The row index position.

          column(Integer):
        The column index position."""
        ...
    def loadFromString(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """ValueTable.loadFromString(string)

        Restore the object using its string representation.     The
        exportToString method can be used to create a string representation.

          string(String):
        The string representation of the object."""
        ...
    def exportToString(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """ValueTable.exportToString()

        Exports the object to its string representation."""
        ...
    def removeRow(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """ValueTable.removeRow(row)

        Deletes a row from the value table.

          row(Integer):
        The index position of the row to remove."""
        ...
    def setRow(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """ValueTable.setRow(row, value)

        Updates a given row within the value table.

        setRow's value argument is space-delimited. Any value used in the
        value argument that contains spaces must be enclosed in quotations.
        In the following example, a value table with two columns has a
        feature class and an index value added:   vtab.setRow(0,
        "'c:/temp/land use.shp' 2")

          row(Integer):
        The index position of the row to update.

          value(Object):
        The value to update the given row."""
        ...
    def setValue(
        self, *args
    ):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
        """ValueTable.setValue(row, column, value)

        Updates the value of a given row and column.

          row(Integer):
        The row index.

          column(Integer):
        The column index

          value(Object):
        The value to update the given row and column."""
        ...
