"""
This type stub file was generated by pyright.
"""

import abc
from datetime import datetime
from enum import IntEnum
from typing import Iterable, Union
from ._ndsc import Attribute, Edge, Junction, NetworkQuery, Turn

JunctionCode = ...
EdgeCode = ...
TurnCode = ...

class TraversedElementType(IntEnum):
    """Enumeration for traversed element type."""

    Unknown = ...
    Junction = ...
    Edge = ...
    Turn = ...
    Road = ...
    HighwayRoad = ...
    Ramp = ...
    Ferry = ...
    RoundaboutRoad = ...
    MajorRoad = ...
    Walkway = ...
    TurningArc = ...
    Stairs = ...
    Escalator = ...
    Elevator = ...
    PedestrianRamp = ...
    MovingWalkway = ...
    Hallway = ...
    Indoor = ...
    Transit = ...
    SailingLine = ...
    Stop = ...
    Waypoint = ...
    RestBreak = ...
    RoadIntersection = ...

class CurbApproach(IntEnum):
    """Enumeration for curb approach."""

    EitherSide = ...
    RightSide = ...
    LeftSide = ...
    NoUTurn = ...

class DrivingSide(IntEnum):
    """Enumeration for driving side."""

    Unknown = ...
    RightSide = ...
    LeftSide = ...

class LandmarkSide(IntEnum):
    """Enumeration for landmark side."""

    Both = ...
    Left = ...
    Right = ...

class ReferenceLandmarkType(IntEnum):
    """Enumeration for reference landmark type."""

    Turn = ...
    Confirmation = ...
    StopSign = ...
    TrafficLight = ...
    RailwayCrossing = ...

class NameClass(IntEnum):
    """Enumeration for directions name class."""

    StreetName = ...
    RouteNumber = ...

class DirectionPointType(IntEnum):
    """Enumeration for direction point type."""

    Unknown = ...
    Header = ...
    ManeuverArrive = ...
    ManeuverDepart = ...
    ManeuverStraight = ...
    ManeuverFerryOn = ...
    ManeuverFerryOff = ...
    ManeuverForkCentral = ...
    ManeuverRoundabout = ...
    ManeuverUTurn = ...
    ManeuverDoor = ...
    ManeuverStairs = ...
    ManeuverElevator = ...
    ManeuverEscalator = ...
    ManeuverPedestrianRamp = ...
    ManeuverForkLeft = ...
    ManeuverRampLeft = ...
    ManeuverRoundaboutLeft = ...
    ManeuverUTurnLeft = ...
    ManeuverBearLeft = ...
    ManeuverTurnLeft = ...
    ManeuverSharpLeft = ...
    ManeuverTurnLeftLeft = ...
    ManeuverTurnLeftRight = ...
    ManeuverForkRight = ...
    ManeuverRampRight = ...
    ManeuverRoundaboutRight = ...
    ManeuverUTurnRight = ...
    ManeuverBearRight = ...
    ManeuverTurnRight = ...
    ManeuverSharpRight = ...
    ManeuverTurnRightLeft = ...
    ManeuverTurnRightRight = ...
    ManeuverElevatorUp = ...
    ManeuverEscalatorUp = ...
    ManeuverStairsUp = ...
    ManeuverElevatorDown = ...
    ManeuverEscalatorDown = ...
    ManeuverStairsDown = ...
    Event = ...
    EventLandmark = ...
    EventTimeZone = ...
    EventTraffic = ...
    EventBarrier = ...
    EventBoundary = ...
    EventRestrictionViolation = ...

class DirectionsFieldMapping(IntEnum):
    """Enumeration for directions field mapping."""

    FullName = ...
    BaseName = ...
    PrefixType = ...
    SuffixType = ...
    HighwayDirection = ...
    PrefixDirection = ...
    SuffixDirection = ...
    Phrase = ...
    Language = ...
    NameClass = ...

class DirectionPoint:
    """Describes a maneuver or an event along a route."""

    @property
    def displayText(self) -> str:
        """The directions text, formatted for UI display."""
        ...
    @property
    def voiceInstruction(self) -> str:
        """The directions text, formatted for voice guidance.

        The text will have expanded abbreviations and plurals.
        """
        ...
    @property
    def shortVoiceInstruction(self) -> str:
        """A shortened version of the directions text, formatted for voice guidance.

        The text will have expanded abbreviations and plurals.
        """
        ...
    @property
    def directionPointType(self) -> DirectionPointType:
        """The direction point type."""
        ...
    @property
    def positionAlong(self) -> float:
        """The position of the direction point along an edge.

        The value needs to be between the edge's from and to position.
        If on a junction the value should be 0.0 (the default).
        """
        ...
    @property
    def azimuth(self) -> float:
        """The bearing, in degrees, of the vehicle departing this point in range [0, 360].

        Zero indicates north. The value is generated by the engine for new points.
        """
        ...
    @property
    def arrivalTime(self) -> datetime | None:
        """The time when the direction point will be reached (in local time).

        The value generated by the engine for new points.
        """
        ...
    @property
    def exitNumber(self) -> int:
        """The exit number on a roundabout."""
        ...
    @property
    def exitName(self) -> DirectionsName | None:
        """The highway exit name components in the directions."""
        ...
    @property
    def name(self) -> DirectionsName | None:
        """The name components of the direction point."""
        ...
    @property
    def alternateName(self) -> DirectionsName | None:
        """The alternate name components in the directions."""
        ...
    @property
    def intersectingNames(self) -> Iterable[DirectionsName]:
        """The iterable of name components of the intersecting or cross street in the directions."""
        ...
    @property
    def branchNames(self) -> Iterable[DirectionsName]:
        """The signpost branch names components in the directions."""
        ...
    @property
    def towardNames(self) -> Iterable[DirectionsName]:
        """The signpost toward destination names components in the directions."""
        ...

class DirectionsCustomizer(abc.ABC):
    """Base class for directions customizers."""

    @abc.abstractmethod
    def attach(self, network_query: NetworkQuery) -> bool:
        """Used to verify that the direction customizer can be applied to the network.

        Invoked when the direction customizer is attached to the network dataset.
        It may be invoked multiple times depending upon the number of threads accessing the network.

        Args:
            network_query (NetworkQuery): Network query instance for current network dataset.

        Returns:
            bool: True if can be attached to the network dataset.
        """
        ...
    @abc.abstractmethod
    def customize(self, directions_query: DirectionsQuery) -> None:
        """Used to customize the final directions output.

        Invoked by the directions engine once per route.

        Args:
            directions_query (DirectionsQuery): Directions query instance for current route.
        """
        ...

class DirectionsQuery:
    """Provides access to directions properties and query methods."""

    @property
    def routeID(self) -> int:
        """ID of the route in the result (zero-based)."""
        ...
    @property
    def routeName(self) -> str:
        """Name of the route."""
        ...
    @property
    def softRestrictionNames(self) -> Iterable[str]:
        """A Iterable of enabled soft restrictions."""
        ...
    @property
    def junctions(self) -> Iterable[TraversedJunction] | None:
        """Return all the junctions in the sequence being traversed."""
        ...
    @property
    def edges(self) -> Iterable[TraversedEdge] | None:
        """Return all the edges in the sequence being traversed."""
        ...
    def turns(self, junction: TraversedJunction) -> Iterable[TraversedTurn] | None:
        """Return the turns of the specified junction."""
        ...
    def previousTraversedEdge(
        self, junction: TraversedJunction
    ) -> TraversedEdge | None:
        """Return the previous edge of the specified junction."""
        ...
    def nextTraversedEdge(self, junction: TraversedJunction) -> TraversedEdge | None:
        """Return the next edge of the specified junction."""
        ...
    def adjacentEdges(
        self, junction: TraversedJunction
    ) -> Iterable[AdjacentNetworkEdge] | None:
        """Return the adjacent edges of the specified junction. These edges are not traversed."""
        ...
    def fromJunction(self, edge: TraversedEdge) -> TraversedJunction:
        """Return the from junction the specified edge."""
        ...
    def toJunction(self, edge: TraversedEdge) -> TraversedJunction:
        """Return the to junction the specified edge."""
        ...
    def fromEdge(self, turn: TraversedTurn) -> TraversedEdge:
        """Return the from edge of the specified turn."""
        ...
    def toEdge(self, turn: TraversedTurn) -> TraversedEdge:
        """Return the to edge of the specified turn."""
        ...
    def fieldValue(
        self, element: TraversedElement, mapped_field_name: str
    ) -> Union[int, float, str]:
        """Return the value of the specified mapped field for the specified element.

        Args:
            element (TraversedElement): A TraversedEdge, TraversedJunction, or TraversedTurn.
            mapped_field_name (str): The mapped field name.

        Returns:
            Union[int, float, str]: Field value or None if the field doesn't exist or is not mapped.
        """
        ...
    def attributeValue(
        self, element: TraversedElement, attribute: Attribute
    ) -> Union[int, float, bool]:
        """Returns the value of the specified network attribute for the element.

        Args:
            element (TraversedElement): Element to query for attribute value.
            attribute (Attribute): Attribute to get value for.

        Returns:
            Union[int, float, bool]:  Attribute value or None if the attribute doesn't exist.
        """
        ...

class TraversedElement:
    """Represents a single traversed element.

    Used as base class for shared properties of TraversedEdge, TraversedJunction and TraversedTurn.
    """

    @property
    def type(self) -> TraversedElementType:
        """The type of the traversed element."""
        ...
    @property
    def sourceID(self) -> int:
        """The network source id of the this element."""
        ...
    @property
    def sourceObjectID(self) -> int:
        """The network source object id of this element."""
        ...
    @property
    def rowID(self) -> int:
        """The traversed result element object ID."""
        ...
    @property
    def accumulatedTime(self) -> float:
        """Accumulated time of the route up to and including this element.

        Expressed in the network's time attribute units.
        """
        ...
    @property
    def accumulatedLength(self) -> float:
        """Accumulated length of a route up to and including this element.

        Expressed in the network's length attribute units.
        """
        ...
    @property
    def accumulatedImpedance(self) -> float:
        """Accumulated impedance of a route up to and including this element.

        Expressed in the network's impedance attribute units.
        """
        ...
    @property
    def violatedRestrictions(self) -> Iterable[str]:
        """Iterable of violated soft restrictions on this element."""
        ...

class TraversedTurn(TraversedElement):
    """Represents a single turn of a route."""

    @property
    def element(self) -> Turn:
        """The network turn element."""
        ...

class TraversedJunction(TraversedElement):
    """Represents a single junction of a route.

    A typical route is an alternating sequence of edges and junctions, for example:
    RouteJunction -> RouteEdge -> RouteJunction -> RouteEdge -> RouteJunction.
    """

    @property
    def element(self) -> Junction:
        """The network junction element."""
        ...
    @property
    def violationTime(self) -> float:
        """The violation time, expressed in the network's time attribute units."""
        ...
    @property
    def signpostID(self) -> int:
        """The OID of related signpost."""
        ...
    @property
    def roadSplitID(self) -> int:
        """The OID of related roadsplit."""
        ...
    @property
    def names(self) -> Iterable[DirectionsName]:
        """Iterable of the names of the junction."""
        ...
    @property
    def referenceLandmark(self) -> ReferenceLandmark | None:
        """The reference landmark related to the junction."""
        ...
    @property
    def spatialLandmarks(self) -> Iterable[SpatialLandmark]:
        """Iterable of spatial landmarks related to the junction."""
        ...
    @property
    def level(self) -> int | None:
        """The level of the junction."""
        ...
    @property
    def timeWindowStart(self) -> datetime | None:
        """The start value of a time window in which a stop on the junction will be visited (in local time)."""
        ...
    @property
    def timeWindowEnd(self) -> datetime | None:
        """The end value of a time window in which a stop on the junction will be visited (in local time)."""
        ...
    @property
    def waitTime(self) -> float | None:
        """The wait time between the arrival and the departure for a stop.

        Expressed in the network's time attribute units.
        """
        ...
    @property
    def arrivalTime(self) -> datetime | None:
        """The calculated time of arrival (in local time)."""
        ...
    @property
    def departureTime(self) -> datetime | None:
        """The time of departure (in local time)."""
        ...
    @property
    def arriveCurbApproach(self) -> CurbApproach | None:
        """The curb approach of a destination (if any) in the junction."""
        ...
    @property
    def directionPoints(self) -> Iterable[DirectionPoint]:
        """The direction points associated with the junction.

        Returns:
            Iterable[DirectionPoint]: Iterable of DirectionPoints.
        """
        ...
    def getName(
        self,
        index: int = ...,
        mapping: DirectionsFieldMapping = ...,
        fallback: str = ...,
    ) -> str | None:
        """Name of the junction.

        Either the full name or a portion of the name can be returned, depending on the mapping parameter value.

        Args:
            index (int, optional): The type of name to retrieve (e.g. PrimaryName = 0, AlternateName1 = 1,
            AlternateName2 = 2, etc.). Defaults to 0.
            mapping (DirectionsFieldMapping, optional): The portion of the name to return. Defaults to
            DirectionsFieldMapping.FullName.
            fallback (str, optional): Value if the junction does not contain the requested mapped property.
            Defaults to "".

        Returns:
            str | None: Name from the junction given the input parameters.
        """
        ...
    def getNames(
        self, mapping: DirectionsFieldMapping = ..., fallback: str = ...
    ) -> Iterable[str] | None:
        """Names of the junction.

        Args:
            mapping (DirectionsFieldMapping, optional): The portion of the name to return. Defaults to
            DirectionsFieldMapping.FullName.
            fallback (str, optional): Value if the junction does not contain the requested mapped property.
            Defaults to "".

        Returns:
            Iterable[str] | None: Iterable of the Names (primary and alternatives) from the junction for the specified
            DirectionsFieldMapping.
        """
        ...

class TraversedEdge(TraversedElement):
    """Represents a single edge of a route.

    A typical route is an alternating sequence of edges and junctions, for example:
    RouteJunction -> RouteEdge -> RouteJunction -> RouteEdge -> RouteJunction
    """

    @property
    def element(self) -> Edge:
        """The network edge element."""
        ...
    @property
    def fromPosition(self) -> float:
        """The position on a network element where the route edge starts.

        The values are in the range of 0.0 to 1.0.
        """
        ...
    @property
    def toPosition(self) -> float:
        """The position on a network element where the route edge ends.

        The values are in the range of 0.0 to 1.0.
        """
        ...
    @property
    def immediateAzimuths(self) -> tuple[float, float]:
        """The azimuth calculated at close proximity to the start and end of the edge.

        Returns:
            Tuple of "from" and "to" azimuth values.
        """
        ...
    @property
    def generalizedAzimuths(self) -> tuple[float, float]:
        """Generalized azimuth calculated further away from the start and end of the edge.

        Returns:
            Tuple of "from" and "to" azimuth values.
        """
        ...
    @property
    def names(self) -> Iterable[DirectionsName]:
        """Iterable of the names of the edge."""
        ...
    @property
    def referenceLandmarks(self) -> Iterable[ReferenceLandmark]:
        """Iterable of reference landmarks related to the edge."""
        ...
    @property
    def spatialLandmarks(self) -> Iterable[SpatialLandmark]:
        """Iterable of spatial landmarks related to the edge."""
        ...
    @property
    def drivingSide(self) -> DrivingSide | None:
        """Driving side value."""
        ...
    @property
    def fromLevel(self) -> int | None:
        """Level the edge starts at."""
        ...
    @property
    def toLevel(self) -> int | None:
        """Level the edge ends at."""
        ...
    @property
    def administrativeArea(self) -> str | None:
        """Name of administrative area the edge is in."""
        ...
    @property
    def floorName(self) -> str | None:
        """Name of a floor the edge is on."""
        ...
    @property
    def timezoneID(self) -> int | None:
        """ID of the time zone the edge is in."""
        ...
    @property
    def arrivalTime(self) -> datetime | None:
        """The time at the start of the edge (in UTC)."""
        ...
    @property
    def departureTime(self) -> datetime | None:
        """The time at the end of the edge (in UTC)."""
        ...
    @property
    def directionPoints(self) -> Iterable[DirectionPoint]:
        """The direction points associated with the edge.

        Returns:
            Iterable[DirectionPoint]: Iterable of DirectionPoints.
        """
        ...
    def getName(
        self,
        index: int = ...,
        mapping: DirectionsFieldMapping = ...,
        fallback: str = ...,
    ) -> str | None:
        """Name of the edge.

        Either the full name or a portion of the name can be returned, depending on the mapping parameter value.

        Args:
            index (int, optional): The type of name to retrieve (e.g. PrimaryName = 0, AlternateName1 = 1,
            AlternateName2 = 2, etc.). Defaults to 0.
            mapping (DirectionsFieldMapping, optional): The portion of the name to return. Defaults to
            DirectionsFieldMapping.FullName.
            fallback (str, optional): Value if the edge does not contain the requested mapped property.
            Defaults to "".

        Returns:
            str | None: Name from the edge given the input parameters.
        """
        ...
    def getNames(
        self, mapping: DirectionsFieldMapping = ..., fallback: str = ...
    ) -> Iterable[str] | None:
        """Names of the edge.

        Args:
            mapping (DirectionsFieldMapping, optional): The portion of the name to return. Defaults to
            DirectionsFieldMapping.FullName.
            fallback (str, optional): Value if the edge does not contain the requested mapped property.
            Defaults to "".

        Returns:
            Iterable[str] | None: Iterable of the Names (primary and alternatives) from the edge for the specified
            DirectionsFieldMapping.
        """
        ...

class AdjacentNetworkEdge:
    """Represents an edge adjacent to a junction."""

    @property
    def type(self) -> TraversedElementType:
        """The type of adjacent edge."""
        ...
    @property
    def immediateAzimuths(self) -> tuple[float, float]:
        """The azimuth calculated at close proximity to the start and end of the edge."""
        ...
    @property
    def element(self) -> Edge:
        """The network edge element of adjacent edge."""
        ...
    @property
    def sourceID(self) -> int:
        """The source ID of adjacent edge's network element."""
        ...
    @property
    def sourceObjectID(self) -> int:
        """The source object ID of adjacent edge's network element."""
        ...
    @property
    def names(self) -> Iterable[DirectionsName]:
        """Iterable of element names referring to the adjacent edge."""
        ...
    @property
    def fromPosition(self) -> float:
        """The position on a network element where the adjacent edge starts.

        The value is in the range of 0.0 to 1.0.
        """
        ...
    @property
    def toPosition(self) -> float:
        """The position on a network element where the adjacent edge ends.

        The value is in the range of 0.0 to 1.0.
        """
        ...
    def getName(
        self,
        index: int = ...,
        mapping: DirectionsFieldMapping = ...,
        fallback: str = ...,
    ) -> str | None:
        """Name of the adjacent edge.

        Either the full name or a portion of the name can be returned, depending on the mapping parameter value.

        Args:
            index (int, optional): The type of name to retrieve (e.g. PrimaryName = 0, AlternateName1 = 1,
            AlternateName2 = 2, etc.). Defaults to 0.
            mapping (DirectionsFieldMapping, optional): The portion of the name to return. Defaults to
            DirectionsFieldMapping.FullName.
            fallback (str, optional): Value if the edge does not contain the requested mapped property.
            Defaults to "".

        Returns:
            str | None: Name from the edge given the input parameters.
        """
        ...
    def getNames(
        self, mapping: DirectionsFieldMapping = ..., fallback: str = ...
    ) -> Iterable[str] | None:
        """Names of the adjacent edge.

        Args:
            mapping (DirectionsFieldMapping, optional): The portion of the name to return. Defaults to
            DirectionsFieldMapping.FullName.
            fallback (str, optional): Value if the edge does not contain the requested mapped property.
            Defaults to "".

        Returns:
            Iterable[str] | None: Iterable of the Names (primary and alternatives) from the edge for the specified
            DirectionsFieldMapping.
        """
        ...

class DirectionsName:
    """A set of names that the directions engine may output or uses during generation of directions.

    If full is empty then a name is generated using the values (separated by a space) of the fields:
    prefixDirection, prefixType, base, suffixType, suffixDirection, and highwayDirection.
    """

    @property
    def full(self) -> str:
        """The full name to display.

        If it is not populated the name generator will generate a value
        from existing components.
        """
        ...
    @property
    def base(self) -> str:
        """The base name of the element.

        For example "Main".
        """
        ...
    @property
    def highwayDirection(self) -> str:
        """The highway direction component.

        For example "N".
        """
        ...
    @property
    def prefixType(self) -> str:
        """The type of a base name that goes before the name.

        For example "St".
        """
        ...
    @property
    def prefixDirection(self) -> str:
        """The direction prefix of the name.

        For example "North".
        """
        ...
    @property
    def suffixType(self) -> str:
        """The type of a base name that goes after the name.

        For example "Ave".
        """
        ...
    @property
    def suffixDirection(self) -> str:
        """The direction suffix of the element name.

        For example "North".
        """
        ...
    @property
    def phrase(self) -> str:
        """The phase to help generate directions for landmarks.

        For example "before the 7-Eleven".
        """
        ...
    @property
    def language(self) -> str:
        """The language of the elements.

        For example "en".
        """
        ...
    @property
    def nameClass(self) -> NameClass | None:
        """The optional class of the name.

        StreetName - Ordinary street name (example: "Lake St" where "Lake" is name and "St" is suffix type).
        RouteNumber - Route number (example: "CR-J22 N" where "CR-J22" is name and "N" is direction).
        """
        ...

class SpatialLandmark:
    """Spatial landmark."""

    @property
    def name(self) -> DirectionsName:
        """Name of the landmark."""
        ...
    @property
    def position(self) -> float:
        """Position on an edge.

        The value is in the range of 0.0 to 1.0.
        For junctions the value is zero.
        """
        ...
    @property
    def distanceInMeters(self) -> float:
        """Distance to the landmark from the route."""
        ...
    @property
    def side(self) -> LandmarkSide:
        """Landmark side, relative to the route's direction of travel."""
        ...

class ReferenceLandmark:
    """Reference landmark."""

    @property
    def importance(self) -> int:
        """The priority of the landmark."""
        ...
    @property
    def position(self) -> float:
        """Position on an edge.

        The value is in the range of 0.0 to 1.0.
        For junctions the value is zero.
        """
        ...
    @property
    def side(self) -> LandmarkSide:
        """Landmark side, relative to the route's direction of travel."""
        ...
    @property
    def type(self) -> ReferenceLandmarkType:
        """Reference landmark type."""
        ...
    @property
    def name(self) -> DirectionsName:
        """Name of the landmark."""
        ...
