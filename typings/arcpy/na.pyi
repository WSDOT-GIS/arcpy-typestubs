"""
This type stub file was generated by pyright.
"""

from arcpy.geoprocessing._base import gptooldoc
from arcpy import _na
from arcpy._na import *

r"""The Network Analyst toolbox contains tools that perform network
analysis and network dataset maintenance. With the tools in this
toolbox, you can maintain network datasets that model transportation
networks and perform route, closest facility, service area, origin-
destination cost matrix, vehicle routing problem, and location-
allocation network analyses on transportation networks. Use the tools
in this toolbox whenever you want to perform an analysis on a
transportation network."""
__all__ = [
    "AddFieldToAnalysisLayer",
    "AddLocations",
    "AddVehicleRoutingProblemBreaks",
    "AddVehicleRoutingProblemRoutes",
    "BuildNetwork",
    "CalculateLocations",
    "CopyNetworkAnalysisLayer",
    "CopyTraversedSourceFeatures",
    "CreateNetworkDataset",
    "CreateNetworkDatasetFromTemplate",
    "CreateTemplateFromNetworkDataset",
    "CreateTurnFeatureClass",
    "DeleteNetworkAnalysisLayer",
    "Directions",
    "DissolveNetwork",
    "IncreaseMaximumEdges",
    "MakeClosestFacilityAnalysisLayer",
    "MakeClosestFacilityLayer",
    "MakeLocationAllocationAnalysisLayer",
    "MakeLocationAllocationLayer",
    "MakeNetworkDatasetLayer",
    "MakeODCostMatrixAnalysisLayer",
    "MakeODCostMatrixLayer",
    "MakeRouteAnalysisLayer",
    "MakeRouteLayer",
    "MakeServiceAreaAnalysisLayer",
    "MakeServiceAreaLayer",
    "MakeVehicleRoutingProblemAnalysisLayer",
    "PopulateAlternateIDFields",
    "ShareAsRouteLayers",
    "Solve",
    "SolveVehicleRoutingProblem",
    "TurnTableToTurnFeatureClass",
    "UpdateAnalysisLayerAttributeParameter",
    "UpdateByAlternateIDFields",
    "UpdateByGeometry",
    "UpgradeNetwork",
]
__alias__ = ...
__all__ += _na.__all__

@gptooldoc("AddFieldToAnalysisLayer_na", None)
def AddFieldToAnalysisLayer(
    in_network_analysis_layer=...,
    sub_layer=...,
    field_name=...,
    field_type=...,
    field_precision=...,
    field_scale=...,
    field_length=...,
    field_alias=...,
    field_is_nullable=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """AddFieldToAnalysisLayer_na(in_network_analysis_layer, sub_layer, field_name, field_type, {field_precision}, {field_scale}, {field_length}, {field_alias}, {field_is_nullable})

       Adds a field to a sublayer of a network analysis layer.

    INPUTS:
     in_network_analysis_layer (Network Analyst Layer):
         The network analysis layer to which the new field will be added.
     sub_layer (String):
         The sublayer of the network analysis layer to which the new field will
         be added.
     field_name (String):
         The name of the field that will be added to the specified sublayer of
         the network analysis layer.
     field_type (String):
         Specifies the field type that will be used in the creation of the new
         field.

         * LONG-The field type will be long. Long fields support whole numbers
         between -2,147,483,648 and 2,147,483,647.

         * TEXT-The field type will be text. Text fields support a string of
         characters.

         * FLOAT-The field type will be float. Float fields support fractional
         numbers between -3.4E38 and 1.2E38.

         * DOUBLE-The field type will be double. Double fields support
         fractional numbers between -2.2E308 and 1.8E308.

         * SHORT-The field type will be short. Short fields support whole
         numbers between -32,768 and 32,767.

         * DATE-The field type will be date. Date fields support date and time
         values.

         * BLOB-The field type will be BLOB. BLOB fields support data stored as
         a long sequence of binary numbers. You need a custom loader or viewer
         or a third-party application to load items into a BLOB field or view
         the contents of a BLOB field.
     field_precision {Long}:
         The number of digits that can be stored in the field. All digits are
         counted regardless of which side of the decimal they are on.The
         parameter value is only valid for numeric field types.
     field_scale {Long}:
         The number of decimal places stored in a field.
     field_length {Long}:
         The length of the field. This sets the maximum number of allowable
         characters for each record of the field.
     field_alias {String}:
         The alternate name for the field. This name is used to describe
         cryptic field names. This parameter only applies to geodatabases.
     field_is_nullable {Boolean}:
         Specifies whether the field can contain null values. Null values are
         different from zero or empty fields and are only supported for fields
         in a geodatabase.

         * NULLABLE-The field can contain null values. This is the default.

         * NON_NULLABLE-The field cannot contain null values."""
    ...

@gptooldoc("AddLocations_na", None)
def AddLocations(
    in_network_analysis_layer=...,
    sub_layer=...,
    in_table=...,
    field_mappings=...,
    search_tolerance=...,
    sort_field=...,
    search_criteria=...,
    match_type=...,
    append=...,
    snap_to_position_along_network=...,
    snap_offset=...,
    exclude_restricted_elements=...,
    search_query=...,
    allow_auto_relocate=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """AddLocations_na(in_network_analysis_layer, sub_layer, in_table, {field_mappings}, {search_tolerance}, {sort_field}, {search_criteria;search_criteria...}, {match_type}, {append}, {snap_to_position_along_network}, {snap_offset}, {exclude_restricted_elements}, {search_query;search_query...}, {allow_auto_relocate})

       Adds input features or records to a network analysis layer. The inputs
       are added to specific sublayers such as stops and barriers. When the
       network analysis layer references a network dataset as its network
       data source, the tool calculates the network locations of the inputs,
       unless precalculated network location fields are mapped from the
       inputs.

    INPUTS:
     in_network_analysis_layer (Network Analyst Layer):
         The network analysis layer to which the network analysis objects will
         be added.
     sub_layer (String):
         The name of the sublayer of the network analysis layer to which the
         network analysis objects will be added.
     in_table (Table View):
         The feature class or table containing the locations to be added to the
         network analysis sublayer.
     field_mappings {Network Analyst Class FieldMap}:
         The mapping between the input fields of the network analysis sublayer
         to which locations will be added and the fields in the input data or
         specified constants.Input sublayers of network analysis layers have a
         set of input fields
         that can be populated to modify or control analysis behavior. When
         adding locations to the sublayer, you can use this parameter to map
         field values from the input table to these fields in the sublayer. You
         can also use field mappings to specify a constant default value for
         each property.If neither the Field value nor the Default value is
         specified for a
         property, the resulting network analysis objects will have null values
         for that property.A complete list of input fields for each sublayer
         for each network
         analysis layer type is available in the documentation for each layer.
         For example, examine the Route layer's Stops sublayer's input
         fields.An NAClassFieldMappings object obtained from the
         NAClassFieldMappings
         class is used to specify the parameter value. The NAClassFieldMappings
         object is a collection of NAClassFieldMap objects that allow you to
         specify the default values or map a field name from the input features
         for the properties of the network analysis object. If the data being
         loaded contains network locations or location ranges based on the
         network dataset used for the analysis, map the network location fields
         from the input features to the network location properties. Specifying
         the network location fields in the field mappings is similar to using
         the Use Network Location Fields option on the tool dialog box.ArcGIS
         Online and some ArcGIS Enterprise portals do not support using
         network location fields. For network analysis layers that use one of
         these portals as the network data source, all inputs will be located
         at solve time, and any mapped location fields will be ignored.
     search_tolerance {Linear Unit}:
         The maximum search distance that will be used when locating the input
         features on the network. Features that are outside the search
         tolerance will be left unlocated. The parameter includes a value and
         units.The default value for this parameter is determined based on
         location
         properties stored in the input network analysis layer. If the network
         analysis layer has location settings overrides for the selected
         sublayer, those settings will be used. Otherwise, the network analysis
         layer's default location settings will be used. Setting a nondefault
         value for this parameter updates the network analysis layer's location
         settings overrides for the selected sublayer.The parameter is not used
         when adding locations to sublayers with line
         or polygon geometry, such as Line Barriers and Polygon Barriers.This
         parameter is not used when adding locations using existing
         network location fields.This parameter is not used when the network
         analysis layer's network
         data source is a portal running a version of ArcGIS Enterprise older
         than 11.0.
     sort_field {Field}:
         The field on which the network analysis objects will be sorted as they
         are added to the network analysis layer. The default is the ObjectID
         field in the input feature class or table.
     search_criteria {Value Table}:
         The edge and junction sources in the network dataset that will be
         searched when locating inputs on the network. For example, if the
         network dataset references separate feature classes representing
         streets and sidewalks, you can locate inputs on streets but not on
         sidewalks.The parameter value is specified as a list with nested
         lists. The
         nested lists are composed of two values indicating the name and snap
         type of each network source. The following are the available
         snap type choices for each
         network source:

         * NONE-The point will not locate on elements in this network source.

         * SHAPE-The point will locate on the closest point of an element in
         this network source.
         For example, a parameter value of
         [["Streets","SHAPE"],["Streets_ND_Junctions","NONE"]] specifies that
         the search can locate on the shape of the Streets source but not on
         the Streets_ND_Junctions source.Any network edge or junction source
         that is not included in this list
         will use its default snap type. It is recommended that you include all
         network sources in your list and explicitly set the snap type for
         each.Historically, the tool supported the snap type options MIDDLE,
         END,
         and MIDDLE_END. These options are deprecated and maintained for
         backward compatibility only. If one of these options is specified, the
         tool reverts to the SHAPE option for that network source.The default
         value for this parameter is determined based on location
         properties stored in the input network analysis layer. If the network
         analysis layer has location settings overrides for the selected
         sublayer, those settings will be used. Otherwise, the network analysis
         layer's default location settings will be used. Setting a nondefault
         value for this parameter updates the network analysis layer's location
         settings overrides for the selected sublayer.This parameter is not
         used when adding locations using existing
         network location fields.This parameter is not used when the network
         analysis layer's network
         data source is ArcGIS Online.This parameter is not used when the
         network analysis layer's network
         data source is a portal running a version of ArcGIS Enterprise older
         than 11.0.
     match_type {Boolean}:
         This parameter is deprecated and maintained only for backward
         compatibility. Inputs will always be matched to the closest network
         source among all the sources used for locating, corresponding to a
         parameter value of MATCH_TO_CLOSEST or True.
     append {Boolean}:
         Specifies whether new network analysis objects will be appended to
         existing objects.

         * APPEND-The new network analysis objects will be appended to the
         existing set of objects in the selected sublayer. This is the default.

         * CLEAR-The existing network analysis objects will be deleted and
         replaced with the new objects.
     snap_to_position_along_network {Boolean}:
         Specifies whether the inputs will be snapped to their calculated
         network locations or represented at their original geographic
         location.To use curb approach in the analysis to control which side of
         the road
         a vehicle must use to approach a location, do not snap the inputs to
         their network locations, or use a snap offset to ensure that the point
         remains clearly to one side of the road.The parameter is not used when
         adding locations to sublayers with line
         or polygon geometry, such as Line Barriers and Polygon Barriers.This
         parameter is not used when the input network analysis layer's
         network data source is a portal service.

         * NO_SNAP-The geometries of the network locations will be based on
         the geometries of the input features. This is the default.

         * SNAP-The geometries of the network locations will be snapped to
         their network locations.
     snap_offset {Linear Unit}:
         An offset distance that will be applied when snapping a point to the
         network. An offset distance of zero means the point will be coincident
         with the network feature (typically a line). To offset the point from
         the network feature, enter an offset distance. The offset is in
         relation to the original point location; that is, if the original
         point was on the left side, its new location will be offset to the
         left. If it was originally on the right side, its new location will be
         offset to the right.The default is 5 meters. However, this parameter
         is ignored if
         snap_to_position_along_network is set to NO_SNAP.The parameter is not
         used when adding locations to sublayers with line
         or polygon geometry, such as Line Barriers and Polygon Barriers.This
         parameter is not used when the input network analysis layer's
         network data source is a portal service.
     exclude_restricted_elements {Boolean}:
         This parameter is deprecated and maintained only for backward
         compatibility. Analysis inputs will never be located on network
         elements that are restricted, corresponding to a parameter value of
         EXCLUDE or True.
     search_query {Value Table}:
         A query that restricts the search to a subset of the features within a
         source feature class. This is useful if you don't want to find
         features that may be unsuited for a network location. For example, if
         you don't want to locate on highway ramps, you can define a query to
         exclude them. A separate SQL expression can be specified per edge or
         junction source feature class of the network dataset.The parameter
         value is specified as a list with nested lists, with one
         entry per network source. Each inner list is composed of two values
         indicating the name of the network source and the SQL expression used
         as the query for that source. An empty string, "", indicates no query
         for a particular source.For example, the value [["Streets",
         "ROAD_CLASS <> 3"],
         ["Streets_ND_Junctions", ""]] specifies an SQL expression for the
         Streets source feature class and no expression for the
         Streets_ND_Junctions source feature class. If a network source is not
         included in the list, it is interpreted to have no query. The value
         [["Streets", "ROAD_CLASS <> 3"]] is equivalent to [["Streets",
         "ROAD_CLASS <> 3"], ["Streets_ND_Junctions", ""]].For more information
         on SQL syntax, see SQL reference for query
         expressions used in ArcGIS.The default value for this parameter is
         determined based on location
         properties stored in the input network analysis layer. If the network
         analysis layer has location settings overrides for the selected
         sublayer, those settings will be used. Otherwise, the network analysis
         layer's default location settings will be used. Setting a nondefault
         value for this parameter updates the network analysis layer's location
         settings overrides for the selected sublayer.This parameter is not
         used when adding locations using existing
         network location fields.This parameter is not used when the network
         analysis layer's network
         data source is ArcGIS Online.This parameter is not used when the
         network analysis layer's network
         data source is a portal running a version of ArcGIS Enterprise older
         than 11.0.
     allow_auto_relocate {Boolean}:
         Specifies whether inputs with existing network location fields can be
         automatically relocated at solve time to ensure valid, routable
         location fields for the analysis.

         * ALLOW-Points located on restricted network elements and points
         affected by barriers will be relocated at solve time to the closest
         routable location. This is the default.

         * NO_ALLOW-Network location fields will be used at solve time as is,
         even if the points are unreachable, and this may cause the solve to
         fail.
         The default value for this parameter is determined based on location
         properties stored in the input network analysis layer. If the network
         analysis layer has location settings overrides for the selected
         sublayer, those settings will be used. Otherwise, the network analysis
         layer's default location settings will be used. Setting a nondefault
         value for this parameter updates the network analysis layer's location
         settings overrides for the selected sublayer.Even if the automatic
         relocating at solve time is not allowed, inputs
         with no location fields or incomplete location fields will be located
         at solve time.This parameter is not used when the network analysis
         layer's network
         data source is ArcGIS Online.This parameter is not used when the
         network analysis layer's network
         data source is an ArcGIS Enterprise portal that does not support using
         network location fields.This parameter is not used when the network
         analysis layer's network
         data source is a portal running a version of ArcGIS Enterprise older
         than 11.0."""
    ...

@gptooldoc("AddVehicleRoutingProblemBreaks_na", None)
def AddVehicleRoutingProblemBreaks(
    in_vrp_layer=...,
    target_route=...,
    break_type=...,
    time_window_properties=...,
    travel_time_properties=...,
    work_time_properties=...,
    append_to_existing_breaks=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """AddVehicleRoutingProblemBreaks_na(in_vrp_layer, {target_route}, {break_type}, {time_window_properties;time_window_properties...}, {travel_time_properties;travel_time_properties...}, {work_time_properties;work_time_properties...}, {append_to_existing_breaks})

       Creates breaks in a Vehicle Routing Problem (VRP) layer.

    INPUTS:
     in_vrp_layer (Network Analyst Layer):
         The vehicle routing problem analysis layer to which the breaks will be
         added.
     target_route {String}:
         The route for the break parameters.  If this parameter is not
         specified, breaks are created for each existing route.
     break_type {String}:
         Specifies the type of breaks for the current VRP layer. All breaks
         must be of the same type.

         * TIME_WINDOW_BREAK-Breaks take place during a specific time window.
         This is the default.

         * MAXIMUM_TRAVEL_TIME_BREAK-Breaks are taken after a certain amount
         of travel time. These values are given as the amount of time either
         until the first break or between breaks.

         * MAXIMUM_WORK_TIME_BREAK-Breaks are taken after a certain amount of
         cumulative time. These values are always an amount of elapsed time
         since the start of the route.
     time_window_properties {Value Table}:
         Specifies a time range within which the break will begin. To set up a
         time window break, use two time-of-day values.The options below are
         enabled when the Break Type parameter is set to
         Time Window Break.

         * Is Paid-A Boolean value indicating whether the break is paid.

         * Break Duration-The duration of the break. This field can't contain
         null values and has a default value of 60.

         * Time Window Start-The start time of the time window.

         * Time Window End-The end time of the time window.

         * Maximum Violation Time-The maximum allowable violation time for a
         time window break. A time window is considered violated if the arrival
         time falls outside the time range. A zero value indicates that the
         time window cannot be violated, that is, the time window is hard. A
         nonzero value indicates the maximum delay time. For example, the break
         can begin up to 30 minutes beyond the end of its time window but the
         delay is penalized pursuant to the Time Window Violation Importance
         setting, which rates the importance of honoring time windows without
         causing violations.
     travel_time_properties {Value Table}:
         Specifies how long a person can drive before the break is required.The
         properties below are enabled when the Break Type parameter is set
         to Maximum Travel Time Break.

         * Is Paid-A Boolean value indicating whether the break is paid.

         * Break Duration-The duration of the break. This field can't contain
         null values and has a default value of 60.

         * Maximum Travel Time Between Breaks-The maximum amount of
         travel time that can be accumulated before the break is taken. The
         travel time is accumulated either from the end of the previous break
         or, if a break has not yet been taken, from the start of the route.
         If this is the route's final break, The MaxTravelTimeBetweenBreaks
         field also indicates the maximum travel time that can be accumulated
         from the final break to the end depot. This field limits how long a
         person can drive until a break is
         required. For example, if the Time Field Units parameter (time_units
         in Python) of the analysis is set to Minutes, and the
         MaxTravelTimeBetweenBreaks field has a value of 120, the driver will
         get a break after two hours of driving. To assign a second break after
         two additional hours of driving, the second break's
         MaxTravelTimeBetweenBreaks field value must be 120. The unit for this
         field value is specified by the Time Field Units
         parameter (time_units in Python).
     work_time_properties {Value Table}:
         Specifies how long a person can work before a break is required.The
         properties below are enabled when the Break Type parameter is set
         to Maximum Work Time Break.

         * Is Paid-A Boolean value indicating whether the break is paid.

         * Break Duration-The duration of the break. This field can't contain
         null values and has a default value of 60.

         * Maximum Cumulative Work Time-The maximum amount of work
         time that can be accumulated before the break is taken. Work time is
         always accumulated from the beginning of the route. Work time is the
         sum of travel time and service times at orders, depots, and breaks.
         However, this excludes wait time, which is the time a route (or
         driver) spends waiting at an order or depot for a time window to
         begin. The MaxCumulWorkTime field also indicates the maximum
         amount of work
         time that can be accumulated before the break is taken. This field
         limits how long a person can work until a break is
         required. For example, if the Time Field Units parameter (time_units
         in Python) is set to Minutes, the MaxCumulWorkTime field has a value
         of 120, and the ServiceTime field has a value of 15, the driver will
         get a 15-minute break after 2 hours of work. Continuing with this
         example, assume a second break is needed after 3
         additional hours of work. To specify this break, you would enter 315
         (5 hours and 15 minutes) as the second break's MaxCumulWorkTime field
         value. This number includes the MaxCumulWorkTime and ServiceTime field
         values of the preceding break, along with the 3 additional hours of
         work time before granting the second break. To avoid taking maximum
         work time breaks prematurely, remember that work time is accumulated
         from the beginning of the route and it includes the service time at
         previously visited depots, orders, and breaks.
     append_to_existing_breaks {Boolean}:
         Specifies whether new breaks will be appended to the existing breaks
         attribute table.

         * APPEND-New breaks will be appended to the existing set in the breaks
         attribute table. This is the default.

         * CLEAR-Existing breaks will be replaced with new breaks."""
    ...

@gptooldoc("AddVehicleRoutingProblemRoutes_na", None)
def AddVehicleRoutingProblemRoutes(
    in_vrp_layer=...,
    number_of_routes=...,
    route_name_prefix=...,
    start_depot_name=...,
    end_depot_name=...,
    earliest_start_time=...,
    latest_start_time=...,
    max_order_count=...,
    capacities=...,
    route_constraints=...,
    costs=...,
    additional_route_time=...,
    append_to_existing_routes=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """AddVehicleRoutingProblemRoutes_na(in_vrp_layer, number_of_routes, route_name_prefix, {start_depot_name}, {end_depot_name}, {earliest_start_time}, {latest_start_time}, {max_order_count}, {capacities;capacities...}, {route_constraints;route_constraints...}, {costs;costs...}, {additional_route_time;additional_route_time...}, {append_to_existing_routes})

       Creates routes in a Vehicle Routing Problem (VRP) layer. This tool
       will append rows to the Routes sublayer and can add rows with specific
       settings while creating a unique name field.

    INPUTS:
     in_vrp_layer (Network Analyst Layer):
         The  vehicle routing problem analysis layer to which routes will be
         added.
     number_of_routes (Long):
         The number of routes that will be added.
     route_name_prefix (String):
         A qualifier that will be added to the title of every route layer item.
         For example, a route name prefix of WeekdayRoute would be used as the
         starting text for every route's name with the Object ID appended to it
         (WeekdayRoute1, WeekdayRoute2, and so on).
     start_depot_name {String}:
         The name of the starting depot for the route. If this value is null,
         the route will begin from the first order assigned. Omitting the start
         depot is useful when the vehicle's starting location is unknown or
         irrelevant to the problem. However, when this value is null, the End
         Depot Name parameter value cannot also be null. Virtual start depots
         are not allowed if orders or depots are in multiple time zones.
     end_depot_name {String}:
         The name of the ending depot for the route. If this value is null, the
         route will end at the last order assigned. When this value is null,
         the Start Depot Name parameter value cannot also be null.
     earliest_start_time {Date}:
         The earliest allowable start time for the route.This parameter is used
         by the solver in conjunction with the time
         window of the starting depot, provided in the Depots layer by the
         TimeWindowStart field, for determining feasible route start times.
         This parameter has a default time-only value of 8:00:00 a.m.,
         interpreted as 8:00:00 a.m. on the date provided by the Default Date
         property of the analysis layer. If no value is specified, the default
         value is used.
     latest_start_time {Date}:
         The latest allowable start time for the route.This parameter has a
         default time-only value of 10:00:00 a.m.,
         interpreted as 10:00:00 a.m. on the date provided by the Default Date
         property of the analysis layer. If no value is specified, the default
         value is used.
     max_order_count {Long}:
         The maximum allowable number of orders on the route. The default value
         is 30. If no value is specified, the default value is used.
     capacities {Value Table}:
         The maximum amount (volume, weight, quantity, and so on) that can be
         carried by the vehicle. A null value is the same as zero. A maximum of
         nine capacity fields are allowed, but use only the number necessary to
         model the needs of the vehicles.
     route_constraints {Value Table}:
         The constraints that will be placed on routes to limit total
         time, total travel time, and total distance.

         * Max Total Time-The maximum allowable route duration. The route
         duration includes travel times as well as service and wait times at
         orders, depots, and breaks.

         * Max Total Travel Time-The maximum allowable travel time for the
         route. The travel time includes only the time spent driving on the
         network and does not include service or wait times. This field value
         can't be larger than the MaxTotalTime  field value.

         * Max Total Distance-The maximum allowable travel distance for the
         route.
     costs {Value Table}:
         The costs that may be incurred by the route in a VRP solution.

         * Fixed Cost-A fixed monetary cost that is incurred only if the route
         is used in a solution (that is, it has orders assigned to it).

         * Cost Per Unit Time-The monetary cost incurred per unit of work time
         for the total route duration, including travel times and service and
         wait times at orders, depots, and breaks.

         * Cost Per Unit Distance-The monetary cost incurred per unit of
         distance traveled for the route length (total travel distance).

         * Overtime Start Time-The duration of regular work time before
         overtime computation begins.

         * Cost Per Unit Overtime-The monetary cost incurred per time unit of
         overtime work. This field can contain null values; a null value
         indicates that the Cost Per Unit Overtime value is the same as the
         Cost Per Unit Time value.
     additional_route_time {Value Table}:
         Additional route time options.

         * Start Depot Service Time-The service time at the starting depot.
         This can be used to model the time spent loading the vehicle.

         * End Depot Service Time-The service time at the ending depot. This
         can be used to model the time spent unloading the vehicle.

         * Arrive/Depart Delay-The amount of travel time needed to accelerate
         the vehicle to normal travel speeds, decelerate it to a stop, and move
         it off and on the network (for example, in and out of parking). By
         including an Arrive/Depart Delay value, the VRP solver is deterred
         from sending many routes to service physically coincident orders.
     append_to_existing_routes {Boolean}:
         Specifies whether new routes will be appended to the existing routes
         attribute table.

         * APPEND-New routes will be appended to the existing set in the routes
         attribute table. This is the default.

         * CLEAR-Existing routes will be deleted and replaced with new routes."""
    ...

@gptooldoc("CalculateLocations_na", None)
def CalculateLocations(
    in_point_features=...,
    in_network_dataset=...,
    search_tolerance=...,
    search_criteria=...,
    match_type=...,
    source_ID_field=...,
    source_OID_field=...,
    position_field=...,
    side_field=...,
    snap_X_field=...,
    snap_Y_field=...,
    distance_field=...,
    snap_Z_field=...,
    location_field=...,
    exclude_restricted_elements=...,
    search_query=...,
    travel_mode=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """CalculateLocations_na(in_point_features, {in_network_dataset}, {search_tolerance}, {search_criteria;search_criteria...}, {match_type}, {source_ID_field}, {source_OID_field}, {position_field}, {side_field}, {snap_X_field}, {snap_Y_field}, {distance_field}, {snap_Z_field}, {location_field}, {exclude_restricted_elements}, {search_query;search_query...}, {travel_mode})

       Locates input features on a network and adds fields to the input
       features that describe the network locations. The tool is used to
       precalculate the network locations of inputs that will be used in a
       Network Analyst workflow, improving performance of the analysis at
       solve time. The tool stores the calculated network locations of the
       inputs in fields in the input data.

    INPUTS:
     in_point_features (Table View):
         The input features for which the network locations will be
         calculated.For line and polygon features, since the network location
         information
         is stored in a BLOB field, only geodatabase feature classes are
         supported.
     in_network_dataset {Network Dataset Layer}:
         The network dataset that will be used to calculate the locations.This
         parameter is required unless a sublayer of a network analysis
         layer is used as input features. In that case, don't specify a value
         for this parameter or set it to the network dataset referenced by the
         network analysis layer.
     search_tolerance {Linear Unit}:
         The maximum search distance that will be used when locating the input
         features on the network. Features that are outside the search
         tolerance will be left unlocated. The parameter includes a value and
         units.The default is 5000 meters.If the input features are a sublayer
         of a network analysis layer, the
         default value for this parameter is determined based on location
         properties stored in the input network analysis layer. If the network
         analysis layer has location settings overrides for the selected
         sublayer, those settings will be used. Otherwise, the network analysis
         layer's default location settings will be used. Setting a nondefault
         value for this parameter updates the network analysis layer's location
         settings overrides for the selected sublayer.The parameter is not used
         when calculating locations for line or
         polygon features.
     search_criteria {Value Table}:
         The edge and junction sources in the network dataset that will be
         searched when locating inputs on the network. For example, if the
         network dataset references separate feature classes representing
         streets and sidewalks, you can locate inputs on streets but not on
         sidewalks.The parameter value is specified as a list with nested
         lists. The
         nested lists are composed of two values indicating the name and snap
         type of each network source. The following are the available
         snap type choices for each
         network source:

         * NONE-The point will not locate on elements in this network source.

         * SHAPE-The point will locate on the closest point of an element in
         this network source.
         For example, a parameter value of
         [["Streets","SHAPE"],["Streets_ND_Junctions","NONE"]] specifies that
         the search can locate on the shape of the Streets source but not on
         the Streets_ND_Junctions source.Any network edge or junction source
         that is not included in this list
         will use its default snap type. It is recommended that you include all
         network sources in your list and explicitly set the snap type for
         each.Historically, the tool supported the snap type options MIDDLE,
         END,
         and MIDDLE_END. These options are deprecated and maintained for
         backward compatibility only. If one of these options is specified, the
         tool reverts to the SHAPE option for that network source.The default
         value is to locate on all network sources except override
         junctions created by running the Dissolve Network tool and system
         junctions.If the input features are a sublayer of a network analysis
         layer, the
         default value for this parameter is determined based on location
         properties stored in the input network analysis layer. If the network
         analysis layer has location settings overrides for the selected
         sublayer, those settings will be used. Otherwise, the network analysis
         layer's default location settings will be used. Setting a nondefault
         value for this parameter updates the network analysis layer's location
         settings overrides for the selected sublayer.
     match_type {Boolean}:
         This parameter is deprecated and maintained only for backward
         compatibility. Inputs will always be matched to the closest network
         source among all the sources used for locating, corresponding to a
         parameter value of MATCH_TO_CLOSEST or True.
     source_ID_field {Field}:
         The name of the field to be created or updated that will be populated
         with the ID of the network dataset source feature class for the input
         feature's computed network location. The default value is SourceID.The
         parameter is not used when calculating locations for line or
         polygon features.Do not use this parameter when the input features are
         a sublayer of a
         network analysis layer. Network locations in a sublayer must be stored
         in location fields with the default names or they will not be used
         when the layer is solved.
     source_OID_field {Field}:
         The name of the field to be created or updated that will be populated
         with the ObjectID field value of the network dataset source feature
         class for the input feature's computed network location. The default
         value is SourceOID.The parameter is not used when calculating
         locations for line or
         polygon features.Do not use this parameter when the input features are
         a sublayer of a
         network analysis layer. Network locations in a sublayer must be stored
         in location fields with the default names or they will not be used
         when the layer is solved.
     position_field {Field}:
         The name of the field to be created or updated describing the computed
         network location's percent along the network element where it was
         located. The default value is PosAlong.The parameter is not used when
         calculating locations for line or
         polygon features.Do not use this parameter when the input features are
         a sublayer of a
         network analysis layer. Network locations in a sublayer must be stored
         in location fields with the default names or they will not be used
         when the layer is solved.
     side_field {Field}:
         The name of the field to be created or updated describing the side of
         the network edge on which the computed network location falls. The
         default value is SideOfEdge.The parameter is not used when calculating
         locations for line or
         polygon features.Do not use this parameter when the input features are
         a sublayer of a
         network analysis layer. Network locations in a sublayer must be stored
         in location fields with the default names or they will not be used
         when the layer is solved.
     snap_X_field {Field}:
         The name of the field to be created or updated with the x-coordinate
         of the computed network location. The default value is SnapX.The
         parameter is not used when calculating locations for line or
         polygon features.Do not use this parameter when the input features are
         a sublayer of a
         network analysis layer. Network locations in a sublayer must be stored
         in location fields with the default names or they will not be used
         when the layer is solved.
     snap_Y_field {Field}:
         The name of the field to be created or updated with the y-coordinate
         of the computed network location. The default value is SnapY.The
         parameter is not used when calculating locations for line or
         polygon features.Do not use this parameter when the input features are
         a sublayer of a
         network analysis layer. Network locations in a sublayer must be stored
         in location fields with the default names or they will not be used
         when the layer is solved.
     distance_field {Field}:
         The name of the field to be created or updated describing the distance
         in meters of the original point feature from its computed network
         location. The default value is DistanceToNetworkInMeters.The parameter
         is not used when calculating locations for line or
         polygon features.Do not use this parameter when the input features are
         a sublayer of a
         network analysis layer. Network locations in a sublayer must be stored
         in location fields with the default names or they will not be used
         when the layer is solved.
     snap_Z_field {Field}:
         The name of the field to be created or updated with the z-coordinate
         of the computed network location. The default value is SnapZ.The
         parameter is used only when the input network dataset supports
         connectivity based on z-coordinate values of the network sources.The
         parameter is not used when calculating locations for line or
         polygon features.Do not use this parameter when the input features are
         a sublayer of a
         network analysis layer. Network locations in a sublayer must be stored
         in location fields with the default names or they will not be used
         when the layer is solved.
     location_field {Field}:
         The name of the field to be created or updated with the location
         ranges of the computed network locations for line or polygon features.
         The default value is Locations.The parameter is used only when
         calculating locations for line or
         polygon features.Do not use this parameter when the input features are
         a sublayer of a
         network analysis layer. Network locations in a sublayer must be stored
         in location fields with the default names or they will not be used
         when the layer is solved.
     exclude_restricted_elements {Boolean}:
         This parameter is deprecated and maintained only for backward
         compatibility. Analysis inputs will never be located on network
         elements that are restricted, corresponding to a parameter value of
         EXCLUDE or True.
     search_query {Value Table}:
         A query that restricts the search to a subset of the features within a
         source feature class. This is useful if you don't want to find
         features that may be unsuited for a network location. For example, if
         you don't want to locate on highway ramps, you can define a query to
         exclude them. A separate SQL expression can be specified per edge or
         junction source feature class of the network dataset.The parameter
         value is specified as a list with nested lists, with one
         entry per network source. Each inner list is composed of two values
         indicating the name of the network source and the SQL expression used
         as the query for that source. An empty string, "", indicates no query
         for a particular source.For example, the value [["Streets",
         "ROAD_CLASS <> 3"],
         ["Streets_ND_Junctions", ""]] specifies an SQL expression for the
         Streets source feature class and no expression for the
         Streets_ND_Junctions source feature class. If a network source is not
         included in the list, it is interpreted to have no query. The value
         [["Streets", "ROAD_CLASS <> 3"]] is equivalent to [["Streets",
         "ROAD_CLASS <> 3"], ["Streets_ND_Junctions", ""]].For more information
         on SQL syntax, see SQL reference for query
         expressions used in ArcGIS.By default, no query is used for any
         source.If the input features are a sublayer of a network analysis
         layer, the
         default value for this parameter is determined based on location
         properties stored in the input network analysis layer. If the network
         analysis layer has location settings overrides for the selected
         sublayer, those settings will be used. Otherwise, the network analysis
         layer's default location settings will be used. Setting a nondefault
         value for this parameter updates the network analysis layer's location
         settings overrides for the selected sublayer.
     travel_mode {String}:
         The name of the travel mode that will be used.If you select a travel
         mode, the travel mode settings, such as
         restrictions and impedance attributes, will be considered when
         calculating network location. For example, if the closest network edge
         to one of the input points is restricted when the selected travel mode
         is applied, the tool will locate the point on the next-closest network
         edge that is not restricted.The available travel modes depend on the
         in_network_dataset parameter
         value.An arcpy.na.TravelMode object and a string containing the valid
         JSON
         representation of a travel mode can also be used as input to the
         parameter.If a sublayer of a network analysis layer is used as input
         features,
         do not set a value for this parameter. When network locations are
         calculated, the network analysis layer's current travel mode will
         automatically be used."""
    ...

@gptooldoc("CopyNetworkAnalysisLayer_na", None)
def CopyNetworkAnalysisLayer(
    in_network_analysis_layer=..., out_layer_name=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """CopyNetworkAnalysisLayer_na(in_network_analysis_layer, {out_layer_name})

       Copies a network analysis layer to a duplicate layer. The new layer
       will have the same analysis settings and network data source as the
       original layer and a copy of the original layer's analysis data.

    INPUTS:
     in_network_analysis_layer (Network Analyst Layer):
         The network analysis layer to copy.
     out_layer_name {String}:
         The name of the network analysis layer to create."""
    ...

@gptooldoc("CopyTraversedSourceFeatures_na", None)
def CopyTraversedSourceFeatures(
    input_network_analysis_layer=...,
    output_location=...,
    edge_feature_class_name=...,
    junction_feature_class_name=...,
    turn_table_name=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """CopyTraversedSourceFeatures_na(input_network_analysis_layer, output_location, edge_feature_class_name, junction_feature_class_name, turn_table_name)

       Creates two feature classes and a table, which together contain
       information about the edges, junctions, and turns that are traversed
       while solving a network analysis layer.

    INPUTS:
     input_network_analysis_layer (Network Analyst Layer):
         The network analysis layer from which traversed source features will
         be copied. If the network analysis layer does not have a valid result,
         the layer will be solved to produce one.
     output_location (Workspace / Feature Dataset):
         The workspace where the output table and two feature classes will be
         saved.
     edge_feature_class_name (String):
         The name of the feature class that will contain information about the
         traversed edge source features. If the solved network analysis layer
         doesn't traverse any edge features, an empty feature class is created.
     junction_feature_class_name (String):
         The name of the feature class that will contain information about the
         traversed junction source features, including system junctions and
         relevant points from the input network analysis layer. If the solved
         network analysis layer doesn't traverse any junctions, an empty
         feature class is created.
     turn_table_name (String):
         The name of the table that will contain information about the
         traversed global turns and turn features that scale cost for the
         underlying edges. If the solved network analysis layer doesn't
         traverse any turns, an empty table is created. Since restricted turns
         are never traversed, they are never included in the output."""
    ...

@gptooldoc("DeleteNetworkAnalysisLayer_na", None)
def DeleteNetworkAnalysisLayer(
    in_network_analysis_layers=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """DeleteNetworkAnalysisLayer_na(in_network_analysis_layers;in_network_analysis_layers...)

       Deletes a network analysis layer and its analysis data.

    INPUTS:
     in_network_analysis_layers (Network Analyst Layer):
         The network analysis layer or layers to delete."""
    ...

@gptooldoc("Directions_na", None)
def Directions(
    in_network_analysis_layer=...,
    file_type=...,
    out_directions_file=...,
    report_units=...,
    report_time=...,
    time_attribute=...,
    language=...,
    style_name=...,
    stylesheet=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """Directions_na(in_network_analysis_layer, file_type, out_directions_file, report_units, {report_time}, {time_attribute}, {language}, {style_name}, {stylesheet})

       Generates turn-by-turn directions from a network analysis layer with
       routes. The directions can be written to a file in text, XML, or HTML
       format. If you provide an appropriate stylesheet, the directions can
       be written to any other file format.

    INPUTS:
     in_network_analysis_layer (Network Analyst Layer):
         Network analysis layer for which directions will be generated.
         Directions can be generated only for route, closest facility, and
         vehicle routing problem network analysis layers.
     file_type (String):
         The format of the output directions file. This parameter is ignored if
         the stylesheet parameter has a value.

         * XML-The output directions file will be generated as an XML file.
         Apart from direction strings and the length and time information for
         the routes, the file will also contain information about the maneuver
         type and the turn angle for each direction.

         * TEXT-The output directions file will be generated as a simple TXT
         file containing the direction strings, the length and, optionally, the
         time information for the routes.

         * HTML-The output directions file will be generated as an HTML file
         containing the direction strings, the length and, optionally, the time
         information for the routes.
     report_units (String):
         Specifies the linear units in which the length information will be
         reported in the directions file. For example, even though your
         impedance was in meters, you can show directions in miles.

         * Feet-Feet

         * Yards-Yards

         * Miles-Miles

         * Meters-Meters

         * Kilometers-Kilometers

         * NauticalMiles-Nautical miles
     report_time {Boolean}:
         * NO_REPORT_TIME-Do not report travel times in the directions file.

         * REPORT_TIME-Report travel times in the directions file. This is the
         default.
     time_attribute {String}:
         The time-based cost attribute to provide travel times in the
         directions. The cost attribute must exist on the network dataset used
         by the input network analysis layer.
     language {String}:
         Choose a language in which to generate driving directions.The input
         for this parameter should be a two- or five-character
         language code representing one of the available languages for
         directions generation. In Python, you can retrieve a list of available
         language codes using the ListDirectionsLanguages function.
     style_name {String}:
         Choose the name of the formatting style for the directions.

         * NA Desktop-Printable turn-by-turn directions

         * NA Navigation-Turn-by-turn directions designed for an in-vehicle
         navigation device

         * NA Campus-Turn-by-turn walking directions, which are designed for
         pedestrian routes
     stylesheet {File}:
         The stylesheet for generating a formatted output file type (such as a
         PDF, Word, or HTML file). The suffix of the file in the output
         directions file parameter should match the file type that the
         stylesheet generates. The Directions tool overrides the output file
         type parameter if this parameter contains a value.If you want a head
         start on creating your own text and HTML
         stylesheets, copy and edit the stylesheets Network Analyst uses. You
         can find them in the following directory: <ArcGIS installation
         directory>\\ArcGIS\\ArcGIS
         Pro\\Resources\\NetworkAnalyst\\Directions\\Styles. The stylesheet is
         Dir2PHTML.xsl, and the text stylesheet is Dir2PlainText.xsl.

    OUTPUTS:
     out_directions_file (File):
         If you provide a stylesheet in the stylesheet parameter, make sure the
         file suffix for out_directions_file matches the file type your
         stylesheet produces."""
    ...

@gptooldoc("MakeClosestFacilityAnalysisLayer_na", None)
def MakeClosestFacilityAnalysisLayer(
    network_data_source=...,
    layer_name=...,
    travel_mode=...,
    travel_direction=...,
    cutoff=...,
    number_of_facilities_to_find=...,
    time_of_day=...,
    time_zone=...,
    time_of_day_usage=...,
    line_shape=...,
    accumulate_attributes=...,
    generate_directions_on_solve=...,
    ignore_invalid_locations=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """MakeClosestFacilityAnalysisLayer_na(network_data_source, {layer_name}, {travel_mode}, {travel_direction}, {cutoff}, {number_of_facilities_to_find}, {time_of_day}, {time_zone}, {time_of_day_usage}, {line_shape}, {accumulate_attributes;accumulate_attributes...}, {generate_directions_on_solve}, {ignore_invalid_locations})

       Makes a closest facility network analysis layer and sets its analysis
       properties. A closest facility analysis layer is useful in determining
       the closest facility or facilities to an incident based on a specified
       travel mode. The layer can be created using a local network dataset or
       a service hosted online or in a portal.

    INPUTS:
     network_data_source (Network Dataset Layer / String):
         The network dataset or service on which the network analysis will be
         performed. Use the portal URL for a service.
     layer_name {String}:
         The name of the network analysis layer to create.
     travel_mode {String}:
         The name of the travel mode to use in the analysis. The travel mode
         represents a collection of network settings, such as travel
         restrictions and U-turn policies, that determine how a pedestrian,
         car, truck, or other medium of transportation moves through the
         network. Travel modes are defined on your network data source.An
         arcpy.na.TravelMode object and a string containing the valid JSON
         representation of a travel mode can also be used as input to the
         parameter.
     travel_direction {String}:
         Specifies the direction of travel between facilities and incidents.

         * TO_FACILITIES-Direction of travel is from incidents to facilities.
         Retail stores commonly use this setting, since they are concerned with
         the time it takes the shoppers (incidents) to reach the store
         (facility). This is the default.

         * FROM_FACILITIES-Direction of travel is from facilities to incidents.
         Fire departments commonly use this setting, since they are concerned
         with the time it takes to travel from the fire station (facility) to
         the location of the emergency (incident).
         The direction of travel may influence the facilities found if the
         network contains one-way streets or impedances based on the direction
         of travel. For instance, it may take 10 minutes to drive from a
         particular incident to a particular facility, but the journey may take
         15 minutes traveling in the other direction, from the facility to the
         incident, because of one-way streets or different traffic conditions.
     cutoff {Double}:
         The impedance value at which to stop searching for facilities for a
         given incident in the units of the impedance attribute used by the
         travel_mode value. This cutoff can be overridden on a per-incident
         basis by specifying individual cutoff values in the incidents sublayer
         when travel_direction = 'TO_FACILITIES' or on a per-facility basis by
         specifying individual cutoff values in the facilities sublayer when
         travel_direction = 'FROM_FACILITIES' By default, no cutoff is used for
         the analysis.
     number_of_facilities_to_find {Long}:
         The number of closest facilities to find per incident. This default
         can be overridden by specifying an individual value for the
         TargetFacilityCount property in the incidents sublayer. The default
         number of facilities to find is one.
     time_of_day {Date}:
         The time and date at which the routes will begin or end. The
         interpretation of this value depends on whether time_of_day_usage is
         set to be the start time or the end time of the route.If you chose a
         traffic-based impedance attribute, the solution will be
         generated given dynamic traffic conditions at the time of day
         specified here. A date and time can be specified as 5/14/2012 10:30
         AM. Configure your analysis to use one of the following special
         dates to model a day of the week or the current date instead of a
         specific, static date:

         * Today-12/30/1899

         * Sunday-12/31/1899

         * Monday-1/1/1900

         * Tuesday-1/2/1900

         * Wednesday-1/3/1900

         * Thursday-1/4/1900

         * Friday-1/5/1900

         * Saturday-1/6/1900
     time_zone {String}:
         Specifies the time zone for the time_of_day parameter.

         * LOCAL_TIME_AT_LOCATIONS-The time_of_day parameter refers
         to the time zone in which the facilities or incidents are located.
         This is the default.

         * If time_of_day_usage is set to START_TIME and travel_direction is
         set to FROM_FACILITIES, this is the time zone of the facilities.

         * If time_of_day_usage is set to START_TIME and travel_direction is
         set to TO_FACILITIES, this is the time zone of the incidents.

         * If time_of_day_usage is set to END_TIME and travel_direction is set
         to FROM_FACILITIES, this is the time zone of the incidents.

         * If time_of_day_usage is set to END_TIME and travel_direction is set
         to TO_FACILITIES, this is the time zone of the facilities.

         * UTC-The time_of_day parameter refers to coordinated universal time
         (UTC). Choose this option if you want to find what's nearest for a
         specific time, such as now, but aren't certain in which time zone the
         facilities or incidents will be located.
     time_of_day_usage {String}:
         Specifies whether the value of the time_of_day parameter represents
         the arrival or departure time for the route or routes.

         * START_TIME-The time_of_day parameter value is interpreted as the
         departure time from the facility or incident. This is the default.When
         this setting is chosen, the time_of_day parameter indicates that the
         solver will find the best route given a departure time.

         * END_TIME-The time_of_dayparameter value is interpreted as the
         arrival time at the facility or incident. This option is useful if you
         want to know the time to depart from a location so you arrive at the
         destination at the time specified in the time_of_day parameter.
     line_shape {String}:
         Specifies the shape type that will be used for the route features that
         are output by the analysis.Regardless of the output shape type
         specified, the best route is
         always determined by the network impedance, never Euclidean distance.
         This means that only the route shapes are different, not the
         underlying traversal of the network.

         * ALONG_NETWORK-The output routes will have the exact shape of the
         underlying network sources. The output includes route measurements for
         linear referencing. The measurements increase from the first stop and
         record the cumulative impedance to reach a given position.

         * NO_LINES-No shape will be generated for the output routes.

         * STRAIGHT_LINES-The output route shape will be a single straight line
         between the stops.
     accumulate_attributes {String}:
         A list of cost attributes to be accumulated during analysis. These
         accumulated attributes are for reference only; the solver only uses
         the cost attribute used by the designated travel mode when solving the
         analysis.For each cost attribute that is accumulated, a
         Total_[Impedance]
         property is populated in the network analysis output features.This
         parameter is not available if the network data source is an
         ArcGIS Online service or the network data source is a service on a
         version of Portal for ArcGIS that does not support accumulation.
     generate_directions_on_solve {Boolean}:
         Specifies whether directions will be generated when running the
         analysis.

         * DIRECTIONS-Turn-by-turn directions will be generated on solve.

         * NO_DIRECTIONS-Turn-by-turn directions will not be generated on
         solve. This is the default.
         For an analysis in which generating turn-by-turn directions is not
         needed, use the default option NO_DIRECTIONS to reduce the time it
         takes to solve the analysis.
     ignore_invalid_locations {Boolean}:
         Specifies whether invalid input locations will be ignored. Typically,
         locations are invalid if they cannot be located on the network. When
         invalid locations are ignored, the solver will skip them and attempt
         to perform the analysis using the remaining locations.

         * SKIP-Invalid input locations will be ignored and only valid
         locations will be used. This is the default.

         * HALT-All input locations will be used. Invalid locations will cause
         the analysis to fail."""
    ...

@gptooldoc("MakeClosestFacilityLayer_na", None)
def MakeClosestFacilityLayer(
    in_network_dataset=...,
    out_network_analysis_layer=...,
    impedance_attribute=...,
    travel_from_to=...,
    default_cutoff=...,
    default_number_facilities_to_find=...,
    accumulate_attribute_name=...,
    UTurn_policy=...,
    restriction_attribute_name=...,
    hierarchy=...,
    hierarchy_settings=...,
    output_path_shape=...,
    time_of_day=...,
    time_of_day_usage=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """MakeClosestFacilityLayer_na(in_network_dataset, out_network_analysis_layer, impedance_attribute, {travel_from_to}, {default_cutoff}, {default_number_facilities_to_find}, {accumulate_attribute_name;accumulate_attribute_name...}, {UTurn_policy}, {restriction_attribute_name;restriction_attribute_name...}, {hierarchy}, {hierarchy_settings}, {output_path_shape}, {time_of_day}, {time_of_day_usage})

       Makes a closest facility network analysis layer and sets its analysis
       properties. A closest facility analysis layer is useful in determining
       the closest facility or facilities to an incident based on a specified
       network cost.

    INPUTS:
     in_network_dataset (Network Dataset Layer):
         The network dataset on which the closest facility analysis will be
         performed.
     out_network_analysis_layer (String):
         Name of the closest facility network analysis layer to create.
     impedance_attribute (String):
         The cost attribute to be used as impedance in the analysis.
     travel_from_to {String}:
         Specifies the direction of travel between facilities and incidents.

         * TRAVEL_FROM-Direction of travel is from facilities to incidents.
         Fire departments commonly use the this setting, since they are
         concerned with the time it takes to travel from the fire station
         (facility) to the location of the emergency (incident).

         * TRAVEL_TO-Direction of travel is from incidents to facilities.
         Retail stores commonly use this setting, since they are concerned with
         the time it takes the shoppers (incidents) to reach the store
         (facility).
         Using this option can find different facilities on a network with one-
         way restrictions and different impedances based on direction of
         travel. For instance, a facility may be a 10-minute drive from the
         incident while traveling from the incident to the facility, but while
         traveling from the facility to the incident, it may be a 15-minute
         journey because of different travel time in that direction.
     default_cutoff {Double}:
         Default impedance value at which to stop searching for facilities for
         a given incident. This default can be overridden by specifying the
         cutoff value on incidents when the direction of travel is from
         incidents to facilities or by specifying the cutoff value on
         facilities when the direction of travel is from facilities to
         incidents.
     default_number_facilities_to_find {Long}:
         Default number of closest facilities to find per incident. The default
         can be overridden by specifying a value for the TargetFacilityCount
         property on the incidents.
     accumulate_attribute_name {String}:
         A list of cost attributes to be accumulated during analysis. These
         accumulation attributes are for reference only; the solver only uses
         the cost attribute specified by the Impedance Attribute parameter to
         calculate the route.For each cost attribute that is accumulated, a
         Total_[Impedance]
         property is added to the routes that are output by the solver.
     UTurn_policy {String}:
         Specifies the U-turn policy that will be used at junctions. Allowing
         U-turns implies that the solver can turn around at a junction and
         double back on the same street. Given that junctions represent street
         intersections and dead ends, different vehicles may be able to turn
         around at some junctions but not at others-it depends on whether the
         junction represents an intersection or a dead end. To accommodate
         this, the U-turn policy parameter is implicitly specified by the
         number of edges that connect to the junction, which is known as
         junction valency. The acceptable values for this parameter are listed
         below; each is followed by a description of its meaning in terms of
         junction valency.

         * ALLOW_UTURNS-U-turns are permitted at junctions with any number of
         connected edges. This is the default value.

         * NO_UTURNS-U-turns are prohibited at all junctions, regardless of
         junction valency. However, U-turns are still permitted at network
         locations even when this setting is chosen, but you can set the
         individual network location's CurbApproach property to prohibit
         U-turns there as well.

         * ALLOW_DEAD_ENDS_ONLY-U-turns are prohibited at all junctions, except
         those that have only one adjacent edge (a dead end).

         * ALLOW_DEAD_ENDS_AND_INTERSECTIONS_ONLY-U-turns are prohibited at
         junctions where exactly two adjacent edges meet but are permitted at
         intersections (junctions with three or more adjacent edges) and dead
         ends (junctions with exactly one adjacent edge). Often, networks have
         extraneous junctions in the middle of road segments. This option
         prevents vehicles from making U-turns at these locations.
         If you need a more precisely defined U-turn policy, consider adding a
         global turn delay evaluator to a network cost attribute or adjusting
         its settings if one exists, and pay particular attention to the
         configuration of reverse turns. You can also set the CurbApproach
         property of your network locations.
     restriction_attribute_name {String}:
         A list of restriction attributes to be applied during the analysis.
     hierarchy {Boolean}:
         * USE_HIERARCHY-The hierarchy attribute will be used for the analysis.
         Using a hierarchy results in the solver preferring higher-order edges
         to lower-order edges. Hierarchical solves are faster, and they can be
         used to simulate the preference of a driver who chooses to travel on
         freeways rather than local roads when possible-even if that means a
         longer trip. This option is valid only if the input network dataset
         has a hierarchy attribute.

         * NO_HIERARCHY-The hierarchy attribute will not be used for the
         analysis. If hierarchy is not used, the result is an exact route for
         the network dataset.
         The parameter is not used if a hierarchy attribute is not defined on
         the network dataset used to perform the analysis.
     hierarchy_settings {Network Analyst Hierarchy Settings}:
         Prior to version 10, this parameter allowed you to change the
         hierarchy ranges for the analysis from the default hierarchy ranges
         established in the network dataset. At version 10, this parameter is
         no longer supported and should be specified as an empty string. To
         change the hierarchy ranges for the analysis, update the default
         hierarchy ranges in the network dataset.
     output_path_shape {String}:
         Specifies the shape type that will be used for the route features that
         are output by the analysis.

         * TRUE_LINES_WITH_MEASURES-The output routes will have the exact shape
         of the underlying network sources. The output includes route
         measurements for linear referencing. The measurements increase from
         the first stop and record the cumulative impedance to reach a given
         position.

         * TRUE_LINES_WITHOUT_MEASURES-The output routes will have the exact
         shape of the underlying network sources.

         * STRAIGHT_LINES-The output route shape will be a single straight line
         between each paired incident and facility.

         * NO_LINES-No shape will be generated for the output routes.
         Regardless of the output shape type specified, the best route is
         always determined by the network impedance, never Euclidean distance.
         This means that only the route shapes are different, not the
         underlying traversal of the network.
     time_of_day {Date}:
         Specifies the time and date at which the routes should begin or end.
         The interpretation of this value depends on whether Time of Day Usage
         is set to be the start time or the end time of the route.If you have
         chosen a traffic-based impedance attribute, the solution
         will be generated given dynamic traffic conditions at the time of day
         specified here. A date and time can be specified as 5/14/2012 10:30
         AM. Instead of using a particular date, a day of the week can
         be
         specified using the following dates.For example, to specify that
         travel should begin at 5:00 PM on Tuesday, specify the parameter value
         as 1/2/1900 5:00 PM.

         * Today-12/30/1899

         * Sunday-12/31/1899

         * Monday-1/1/1900

         * Tuesday-1/2/1900

         * Wednesday-1/3/1900

         * Thursday-1/4/1900

         * Friday-1/5/1900

         * Saturday-1/6/1900
     time_of_day_usage {String}:
         Indicates whether the value of the Time of Day parameter represents
         the arrival or departure time for the route or routes.

         * START_TIME-Time of Day is interpreted as the departure time from the
         facility or incident.When this setting is chosen, Time of Day
         indicates the solver should find the best route given a departure
         time.

         * END_TIME-Time of Day is interpreted as the arrival time at the
         facility or incident. This option is useful if you want to know what
         time to depart from a location so that you arrive at the destination
         at the time specified in Time of Day.

         * NOT_USED-When Time of Day doesn't have a value, this setting is the
         only choice. When Time of Day has a value, this setting isn't
         available."""
    ...

@gptooldoc("MakeLocationAllocationAnalysisLayer_na", None)
def MakeLocationAllocationAnalysisLayer(
    network_data_source=...,
    layer_name=...,
    travel_mode=...,
    travel_direction=...,
    problem_type=...,
    cutoff=...,
    number_of_facilities_to_find=...,
    decay_function_type=...,
    decay_function_parameter_value=...,
    target_market_share=...,
    capacity=...,
    time_of_day=...,
    time_zone=...,
    line_shape=...,
    accumulate_attributes=...,
    ignore_invalid_locations=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """MakeLocationAllocationAnalysisLayer_na(network_data_source, {layer_name}, {travel_mode}, {travel_direction}, {problem_type}, {cutoff}, {number_of_facilities_to_find}, {decay_function_type}, {decay_function_parameter_value}, {target_market_share}, {capacity}, {time_of_day}, {time_zone}, {line_shape}, {accumulate_attributes;accumulate_attributes...}, {ignore_invalid_locations})

       Makes a location-allocation network analysis layer and sets its
       analysis properties. A location-allocation analysis layer is useful
       for choosing a given number of facilities from a set of potential
       locations so that a demand will be allocated to facilities in an
       optimal and efficient manner. The layer can be created using a local
       network dataset or a service hosted online or in a portal.

    INPUTS:
     network_data_source (Network Dataset Layer / String):
         The network dataset or service on which the network analysis will be
         performed. Use the portal URL for a service.
     layer_name {String}:
         The name of the network analysis layer to create.
     travel_mode {String}:
         The name of the travel mode to use in the analysis. The travel mode
         represents a collection of network settings, such as travel
         restrictions and U-turn policies, that determine how a pedestrian,
         car, truck, or other medium of transportation moves through the
         network. Travel modes are defined on your network data source.An
         arcpy.na.TravelMode object and a string containing the valid JSON
         representation of a travel mode can also be used as input to the
         parameter.
     travel_direction {String}:
         Specifies the direction of travel between facilities and demand points
         when calculating the network costs.

         * FROM_FACILITIES-Direction of travel is from facilities to demand
         points. This is the default. Fire departments commonly use this
         setting, since they are concerned with the time it takes to travel
         from the fire station to the location of the emergency.

         * TO_FACILITIES-Direction of travel is from demand points to
         facilities. Retail stores commonly use this setting, since they are
         concerned with the time it takes the shoppers to reach the store.
         The direction of travel may affect the allocation of the demand points
         to the facilities on a network with one-way restrictions and different
         impedances based on direction of travel. For instance, it may take 15
         minutes to drive from the demand point to the facility but only 10
         minutes when driving from the facility to the demand point.
     problem_type {String}:
         The problem type that will be solved. The choice of the problem type
         depends on the kind of facility being located. Different kinds of
         facilities have different priorities and constraints.

         * MINIMIZE_IMPEDANCE-This option solves the warehouse location
         problem. It selects a set of facilities so that the total sum of
         weighted impedances (demand at a location times the impedance to the
         closest facility) is minimized. This problem type is often known as
         the P-Median problem. This is the default problem type.

         * MAXIMIZE_COVERAGE-This option solves the fire station location
         problem. It selects facilities so that all or the greatest amount of
         demand is within a specified impedance cutoff.

         * MAXIMIZE_CAPACITATED_COVERAGE-This option solves the location
         problem in which facilities have a finite capacity. It selects
         facilities so that all or the greatest amount of demand can be served
         without exceeding the capacity of any facility. In addition to
         honoring capacity, it selects facilities so that the total sum of
         weighted impedance (demand allocated to a facility multiplied by the
         impedance to or from the facility) is minimized.

         * MINIMIZE_FACILITIES-This option solves the fire station location
         problem. It selects the minimum number of facilities needed to cover
         all or the greatest amount of demand within a specified impedance
         cutoff.

         * MAXIMIZE_ATTENDANCE-This option solves the neighborhood store
         location problem in which the proportion of demand allocated to the
         nearest chosen facility falls with increasing distance. The set of
         facilities that maximize the total allocated demand is selected.
         Demand greater than the specified impedance cutoff does not affect the
         selected set of facilities.

         * MAXIMIZE_MARKET_SHARE-This option solves the competitive facility
         location problem. It selects facilities to maximize market share in
         the presence of competitive facilities. Gravity model concepts are
         used to determine the proportion of demand allocated to each facility.
         The set of facilities that maximizes the total allocated demand is
         selected.

         * TARGET_MARKET_SHARE-This option solves the competitive facility
         location problem. It selects facilities to reach a specified target
         market share in the presence of competitive facilities. Gravity model
         concepts are used to determine the proportion of demand allocated to
         each facility. The minimum number of facilities needed to reach the
         specified target market share is selected.
     cutoff {Double}:
         The maximum impedance at which a demand point can be allocated to a
         facility in the units of the impedance attribute used by the specified
         Travel Mode value. The maximum impedance is measured by the least-cost
         path along the network. If a demand point is outside the cutoff, it is
         left unallocated. This parameter can be used to model the maximum
         distance that people are willing to travel to visit stores or the
         maximum time that is permitted for a fire department to reach anyone
         in the community.This cutoff value can be overridden on a per-demand-
         point basis by
         specifying individual cutoff values in the demand points sublayer in
         the Cutoff_[Impedance] property. For example, it may show that people
         in rural areas are willing to travel up to 10 miles to reach a
         facility, while people in the city are only willing to travel up to 2
         miles. You can model this behavior by setting the cutoff value of the
         analysis layer to 10 and setting the Cutoff_Miles value of each demand
         point in urban areas to 2.By default, no cutoff value is used for the
         analysis.
     number_of_facilities_to_find {Long}:
         The number of facilities that the solver will locate. The default
         value is 1.The facilities with a FacilityType value of Required are
         always part
         of the solution when there are more facilities to find than required
         facilities; any excess facilities to choose are picked from candidate
         facilities.Any facilities that have a FacilityType value of Chosen
         before solving
         are treated as candidate facilities at solve time.This parameter value
         is not considered for the MINIMIZE_FACILITIES
         problem type since the solver searches for the minimum number of
         facilities to locate to maximize coverage.This parameter value is
         overridden for the TARGET_MARKET_SHARE problem
         type because the solver searches for the minimum number of facilities
         required to capture the specified market share.
     decay_function_type {String}:
         The equation that will be used for transforming the network cost
         between facilities and demand points. This parameter, along with the
         Decay Function Parameter Value parameter, specifies how severely the
         network impedance between facilities and demand points influences the
         solver's selection of facilities.

         * LINEAR-The transformed network impedance between the facility and
         the demand point is the same as the shortest-path network impedance
         between them. With this option, the impedance parameter is always set
         to 1. This is the default.

         * POWER-The transformed network impedance between the facility and the
         demand point is equal to the shortest-path network impedance raised to
         the power specified by the impedance parameter. Use this option with a
         positive impedance parameter to specify higher weight to nearby
         facilities.

         * EXPONENTIAL-The transformed network impedance between the facility
         and the demand point is equal to the mathematical constant e raised to
         the power specified by the shortest-path network impedance multiplied
         with the impedance parameter. Use this option with a positive
         impedance parameter to specify a very high weight to nearby
         facilities.Exponential transformations are commonly used in
         conjunction with an impedance cutoff.
         Demand points have an ImpedanceTransformation property, which, if set,
         overrides the Decay Function Parameter Value parameter of the analysis
         layer on a per-demand-point basis. You may determine that the decay
         function should be different for urban and rural residents. You can
         model this by setting the impedance transformation for the analysis
         layer to match that of rural residents and setting the impedance
         transformation for the individual demand points located in urban areas
         to match that of urbanites.
     decay_function_parameter_value {Double}:
         A parameter value for the equations specified in the
         decay_function_type parameter. This parameter value is ignored when
         the decay_function_type parameter is set to LINEAR. For the POWER and
         EXPONENTIAL options, the value should not be zero.Demand points have
         an ImpedanceTransformation property, which, if set,
         overrides the decay_function_parameter_value parameter of the analysis
         layer on a per-demand-point basis. You may determine that the decay
         function should be different for urban and rural residents. You can
         model this by setting the impedance transformation for the analysis
         layer to match that of rural residents and setting the impedance
         transformation for the individual demand points located in urban areas
         to match that of urbanites.
     target_market_share {Double}:
         The target market share, as a percentage, to solve for when the
         problem_type parameter is set to TARGET_MARKET_SHARE. It is the
         percentage of the total demand weight that you want the solution
         facilities to capture. The solver selects the minimum number of
         facilities required to capture the target market share specified by
         this numeric value.
     capacity {Double}:
         The default capacity of facilities when the problem_type parameter is
         set to MAXIMIZE_CAPACITATED_COVERAGE. This parameter is ignored for
         all other problem types.Facilities have a Capacity property, which, if
         set to a nonnull value,
         overrides the capacity parameter value for that facility.
     time_of_day {Date}:
         The time and date of departure. The departure time can be from
         facilities or demand points, depending on whether travel_direction is
         set to TO_FACILITIES or FROM_FACILITIES.If you chose a traffic-based
         impedance attribute, the solution will be
         generated given dynamic traffic conditions at the time of day
         specified here. A date and time can be specified as 5/14/2012 10:30
         AM. Configure your analysis to use one of the following special
         dates to model a day of the week or the current date instead of a
         specific, static date:

         * Today-12/30/1899

         * Sunday-12/31/1899

         * Monday-1/1/1900

         * Tuesday-1/2/1900

         * Wednesday-1/3/1900

         * Thursday-1/4/1900

         * Friday-1/5/1900

         * Saturday-1/6/1900
     time_zone {String}:
         The time zone of the Time of Day parameter.

         * LOCAL_TIME_AT_LOCATIONS-The time of day parameter refers to the time
         zone in which the facilities or demand points are located. If the
         travel direction is facilities to demand points, this is the time zone
         of the facilities. If the travel direction is demand points to
         facilities, this is the time zone of the demand points. This is the
         default.

         * UTC-The time of day parameter refers to coordinated universal time
         (UTC). Choose this option if you want the best location for a specific
         time, such as now, but aren't certain in which time zone the
         facilities or demand points will be located.
     line_shape {String}:
         Specifies the output line shape.

         * NO_LINES-No shape will be generated for the output of the analysis.
         This is useful if you are solving a very large problem and are
         interested only in a solution table and are not interested in
         visualizing the results on a map.

         * STRAIGHT_LINES-The output line shapes will be straight lines
         connecting the solution facilities to their allocated demand points.
         This is the default.
         Regardless of the output shape type specified, the best route is
         always determined by the network impedance, never Euclidean distance.
         This means that only the route shapes are different, not the
         underlying traversal of the network.
     accumulate_attributes {String}:
         A list of cost attributes to be accumulated during analysis. These
         accumulated attributes are for reference only; the solver only uses
         the cost attribute used by the designated travel mode when solving the
         analysis.For each cost attribute that is accumulated, a
         Total_[Impedance]
         property is populated in the network analysis output features.This
         parameter is not available if the network data source is an
         ArcGIS Online service or the network data source is a service on a
         version of Portal for ArcGIS that does not support accumulation.
     ignore_invalid_locations {Boolean}:
         Specifies whether invalid input locations will be ignored. Typically,
         locations are invalid if they cannot be located on the network. When
         invalid locations are ignored, the solver will skip them and attempt
         to perform the analysis using the remaining locations.

         * SKIP-Invalid input locations will be ignored and only valid
         locations will be used. This is the default.

         * HALT-All input locations will be used. Invalid locations will cause
         the analysis to fail."""
    ...

@gptooldoc("MakeLocationAllocationLayer_na", None)
def MakeLocationAllocationLayer(
    in_network_dataset=...,
    out_network_analysis_layer=...,
    impedance_attribute=...,
    loc_alloc_from_to=...,
    loc_alloc_problem_type=...,
    number_facilities_to_find=...,
    impedance_cutoff=...,
    impedance_transformation=...,
    impedance_parameter=...,
    target_market_share=...,
    accumulate_attribute_name=...,
    UTurn_policy=...,
    restriction_attribute_name=...,
    hierarchy=...,
    output_path_shape=...,
    default_capacity=...,
    time_of_day=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """MakeLocationAllocationLayer_na(in_network_dataset, out_network_analysis_layer, impedance_attribute, {loc_alloc_from_to}, {loc_alloc_problem_type}, {number_facilities_to_find}, {impedance_cutoff}, {impedance_transformation}, {impedance_parameter}, {target_market_share}, {accumulate_attribute_name;accumulate_attribute_name...}, {UTurn_policy}, {restriction_attribute_name;restriction_attribute_name...}, {hierarchy}, {output_path_shape}, {default_capacity}, {time_of_day})

       Makes a location-allocation network analysis layer and sets its
       analysis properties. A location-allocation analysis layer is useful
       for choosing a given number of facilities from a set of potential
       locations such that a demand will be allocated to facilities in an
       optimal and efficient manner.

    INPUTS:
     in_network_dataset (Network Dataset Layer):
         The network dataset on which the location-allocation analysis will be
         performed.
     out_network_analysis_layer (String):
         Name of the location-allocation network analysis layer to create.
     impedance_attribute (String):
         The cost attribute to be used as impedance in the analysis.
     loc_alloc_from_to {String}:
         Specifies the direction of travel between facilities and demand points
         when calculating the network costs.

         * FACILITY_TO_DEMAND-Direction of travel is from facilities to demand
         points. Fire departments commonly use the this setting, since they are
         concerned with the time it takes to travel from the fire station to
         the location of the emergency.

         * DEMAND_TO_FACILITY-Direction of travel is from demand points to
         facilities. Retail stores commonly use this setting, since they are
         concerned with the time it takes the shoppers to reach the store.
         Using this option can affect the allocation of the demand points to
         the facilities on a network with one-way restrictions and different
         impedances based on direction of travel. For instance, a facility may
         be a 15-minute drive from the demand point to the facility, but only a
         10-minute trip when traveling from the facility to the demand point.
     loc_alloc_problem_type {String}:
         The problem type that will be solved. The choice of the problem type
         depends on the kind of facility being located. Different kinds of
         facilities have different priorities and constraints.

         * MINIMIZE_IMPEDANCE-This option solves the warehouse location
         problem. It selects a set of facilities such that the total sum of
         weighted impedances (demand at a location times the impedance to the
         closest facility) is minimized. This problem type is often known as
         the P-Median problem.

         * MAXIMIZE_COVERAGE-This option solves the fire station location
         problem. It chooses facilities such that all or the greatest amount of
         demand is within a specified impedance cutoff.

         * MAXIMIZE_CAPACITATED_COVERAGE-This option solves the location
         problem where facilities have a finite capacity. It chooses facilities
         such that all or the greatest amount of demand can be served without
         exceeding the capacity of any facility. In addition to honoring
         capacity, it selects facilities such that the total sum of weighted
         impedance (demand allocated to a facility multiplied by the impedance
         to or from the facility) is minimized.

         * MINIMIZE_FACILITIES-This option solves the fire station location
         problem. It chooses the minimum number of facilities needed to cover
         all or the greatest amount of demand within a specified impedance
         cutoff.

         * MAXIMIZE_ATTENDANCE-This option solves the neighborhood store
         location problem where the proportion of demand allocated to the
         nearest chosen facility falls with increasing distance. The set of
         facilities that maximize the total allocated demand is chosen. Demand
         further than the specified impedance cutoff does not affect the chosen
         set of facilities.

         * MAXIMIZE_MARKET_SHARE-This option solves the competitive facility
         location problem. It chooses facilities to maximize market share in
         the presence of competitive facilities. Gravity model concepts are
         used to determine the proportion of demand allocated to each facility.
         The set of facilities that maximizes the total allocated demand is
         chosen.

         * TARGET_MARKET_SHARE-This option solves the competitive facility
         location problem. It chooses facilities to reach a specified target
         market share in the presence of competitive facilities. Gravity model
         concepts are used to determine the proportion of demand allocated to
         each facility. The minimum number of facilities needed to reach the
         specified target market share is chosen.
     number_facilities_to_find {Long}:
         Specifies the number of facilities that the solver should locate.The
         facilities with a FacilityType value of Required are always part
         of the solution when there are more facilities to find than required
         facilities; any excess facilities to choose are picked from candidate
         facilities.Any facilities that have a FacilityType value of Chosen
         before solving
         are treated as candidate facilities at solve time.The parameter value
         is not considered for the MINIMIZE_FACILITIES
         problem type since the solver determines the minimum number of
         facilities to locate to maximize coverage.The parameter value is
         overridden for the TARGET_MARKET_SHARE problem
         type because the solver searches for the minimum number of facilities
         required to capture the specified market share.
     impedance_cutoff {Double}:
         Impedance Cutoff specifies the maximum impedance at which a demand
         point can be allocated to a facility. The maximum impedance is
         measured by the least-cost path along the network. If a demand point
         is outside the cutoff, it is left unallocated. This property might be
         used to model the maximum distance that people are willing to travel
         to visit your stores or the maximum time that is permitted for a fire
         department to reach anyone in the community.Demand points have a
         Cutoff_[Impedance] property, which, if set,
         overrides the Impedance Cutoff property of the analysis layer. You
         might find that people in rural areas are willing to travel up to 10
         miles to reach a facility, while urbanites are only willing to travel
         up to 2 miles. You can model this behavior by setting the impedance
         cutoff value of the analysis layer to 10 and setting the Cutoff_Miles
         value of the demand points in urban areas to 2.
     impedance_transformation {String}:
         This sets the equation for transforming the network cost between
         facilities and demand points. This property, coupled with the
         Impedance Parameter, specifies how severely the network impedance
         between facilities and demand points influences the solver's choice of
         facilities.

         * LINEAR-The transformed network impedance between the facility and
         the demand point is the same as the shortest-path network impedance
         between them. With this option, the impedance parameter is always set
         to one. This is the default.

         * POWER-The transformed network impedance between the facility and the
         demand point is equal to the shortest-path network impedance raised to
         the power specified by the impedance parameter. Use this option with a
         positive impedance parameter to specify higher weight to nearby
         facilities.

         * EXPONENTIAL-The transformed network impedance between the facility
         and the demand point is equal to the mathematical constant e raised to
         the power specified by the shortest-path network impedance multiplied
         with the impedance parameter. Use this option with a positive
         impedance parameter to specify a very high weight to nearby
         facilities.Exponential transformations are commonly used in
         conjunction with an impedance cutoff.
         Demand points have an ImpedanceTransformation property, which, if set,
         overrides the Impedance Transformation property of the analysis layer.
         You might determine the impedance transformation should be different
         for urban and rural residents. You can model this by setting the
         impedance transformation for the analysis layer to match that of rural
         residents and setting the impedance transformation for the demand
         points in urban areas to match that of urbanites.
     impedance_parameter {Double}:
         Provides a parameter value to the equations specified in the Impedance
         transformation parameter. The parameter value is ignored when the
         impedance transformation is of type LINEAR. For POWER and EXPONENTIAL
         impedance transformations, the value should be nonzero.Demand points
         have an ImpedanceParameter property, which, if set,
         overrides the Impedance Parameter property of the analysis layer. You
         might determine that the impedance parameter should be different for
         urban and rural residents. You can model this by setting the impedance
         transformation for the analysis layer to match that of rural residents
         and setting the impedance transformation for the demand points in
         urban areas to match that of urbanites.
     target_market_share {Double}:
         Specifies the target market share in percentage to solve for when the
         Location-Allocation Problem Type parameter is set to
         TARGET_MARKET_SHARE . It is the percentage of the total demand weight
         that you want your solution facilities to capture. The solver chooses
         the minimum number of facilities required to capture the target market
         share specified by this numeric value.
     accumulate_attribute_name {String}:
         A list of cost attributes to be accumulated during analysis. These
         accumulation attributes are for reference only; the solver only uses
         the cost attribute specified by the Impedance Attribute parameter to
         calculate the route.For each cost attribute that is accumulated, a
         Total_[Impedance]
         property is added to the routes that are output by the solver.
     UTurn_policy {String}:
         Specifies the U-turn policy that will be used at junctions. Allowing
         U-turns implies that the solver can turn around at a junction and
         double back on the same street. Given that junctions represent street
         intersections and dead ends, different vehicles may be able to turn
         around at some junctions but not at others-it depends on whether the
         junction represents an intersection or a dead end. To accommodate
         this, the U-turn policy parameter is implicitly specified by the
         number of edges that connect to the junction, which is known as
         junction valency. The acceptable values for this parameter are listed
         below; each is followed by a description of its meaning in terms of
         junction valency.

         * ALLOW_UTURNS-U-turns are permitted at junctions with any number of
         connected edges. This is the default value.

         * NO_UTURNS-U-turns are prohibited at all junctions, regardless of
         junction valency. However, U-turns are still permitted at network
         locations even when this setting is chosen, but you can set the
         individual network location's CurbApproach property to prohibit
         U-turns there as well.

         * ALLOW_DEAD_ENDS_ONLY-U-turns are prohibited at all junctions, except
         those that have only one adjacent edge (a dead end).

         * ALLOW_DEAD_ENDS_AND_INTERSECTIONS_ONLY-U-turns are prohibited at
         junctions where exactly two adjacent edges meet but are permitted at
         intersections (junctions with three or more adjacent edges) and dead
         ends (junctions with exactly one adjacent edge). Often, networks have
         extraneous junctions in the middle of road segments. This option
         prevents vehicles from making U-turns at these locations.
         If you need a more precisely defined U-turn policy, consider adding a
         global turn delay evaluator to a network cost attribute or adjusting
         its settings if one exists, and pay particular attention to the
         configuration of reverse turns. You can also set the CurbApproach
         property of your network locations.
     restriction_attribute_name {String}:
         A list of restriction attributes to be applied during the analysis.
     hierarchy {Boolean}:
         * USE_HIERARCHY-The hierarchy attribute will be used for the analysis.
         Using a hierarchy results in the solver preferring higher-order edges
         to lower-order edges. Hierarchical solves are faster, and they can be
         used to simulate the preference of a driver who chooses to travel on
         freeways rather than local roads when possible-even if that means a
         longer trip. This option is valid only if the input network dataset
         has a hierarchy attribute.

         * NO_HIERARCHY-The hierarchy attribute will not be used for the
         analysis. If hierarchy is not used, the result is an exact route for
         the network dataset.
         The parameter is not used if a hierarchy attribute is not defined on
         the network dataset used to perform the analysis.
     output_path_shape {String}:
         * NO_LINES-No shape will be generated for the output of the analysis.

         * STRAIGHT_LINES-The output line shapes will be straight lines
         connecting the solution facilities to their allocated demand points.
     default_capacity {Double}:
         Specifies the default capacity of facilities when the
         loc_alloc_problem_type parameter is set to
         MAXIMIZE_CAPACITATED_COVERAGE. This parameter is ignored for all other
         problem types.Facilities have a Capacity property, which, if set to a
         nonnull value,
         overrides the default_capacity parameter for that facility.
     time_of_day {Date}:
         Indicates the time and date of departure. The departure time can be
         from facilities or demand points, depending on whether travel is from
         demand to facility or facility to demand.If you have chosen a traffic-
         based impedance attribute, the solution
         will be generated given dynamic traffic conditions at the time of day
         specified here. A date and time can be specified as 5/14/2012 10:30
         AM. Instead of using a particular date, a day of the week can
         be
         specified using the following dates.For example, to specify that
         travel should begin at 5:00 PM on Tuesday, specify the parameter value
         as 1/2/1900 5:00 PM.

         * Today-12/30/1899

         * Sunday-12/31/1899

         * Monday-1/1/1900

         * Tuesday-1/2/1900

         * Wednesday-1/3/1900

         * Thursday-1/4/1900

         * Friday-1/5/1900

         * Saturday-1/6/1900"""
    ...

@gptooldoc("MakeODCostMatrixAnalysisLayer_na", None)
def MakeODCostMatrixAnalysisLayer(
    network_data_source=...,
    layer_name=...,
    travel_mode=...,
    cutoff=...,
    number_of_destinations_to_find=...,
    time_of_day=...,
    time_zone=...,
    line_shape=...,
    accumulate_attributes=...,
    ignore_invalid_locations=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """MakeODCostMatrixAnalysisLayer_na(network_data_source, {layer_name}, {travel_mode}, {cutoff}, {number_of_destinations_to_find}, {time_of_day}, {time_zone}, {line_shape}, {accumulate_attributes;accumulate_attributes...}, {ignore_invalid_locations})

       Makes an origin destination (OD) cost matrix network analysis layer
       and sets its analysis properties. An OD cost matrix analysis layer is
       useful for representing a matrix of costs going from a set of origin
       locations to a set of destination locations. The layer can be created
       using a local network dataset or a service hosted online or in a
       portal.

    INPUTS:
     network_data_source (Network Dataset Layer / String):
         The network dataset or service on which the network analysis will be
         performed. Use the portal URL for a service.
     layer_name {String}:
         The name of the network analysis layer to create.
     travel_mode {String}:
         The name of the travel mode to use in the analysis. The travel mode
         represents a collection of network settings, such as travel
         restrictions and U-turn policies, that determine how a pedestrian,
         car, truck, or other medium of transportation moves through the
         network. Travel modes are defined on your network data source.An
         arcpy.na.TravelMode object and a string containing the valid JSON
         representation of a travel mode can also be used as input to the
         parameter.
     cutoff {Double}:
         The impedance value at which to stop searching for destinations for a
         given origin. This value will be in the units of the impedance
         attribute used by the chosen travel mode. No destinations beyond this
         limit will be found. This cutoff value can be overridden on a per-
         origin basis by specifying individual cutoff values in the origins
         sublayer. By default, no cutoff is used for the analysis.
     number_of_destinations_to_find {Long}:
         The number of destinations to find per origin. The default can be
         overridden by specifying an individual value for the
         TargetDestinationCount property in the origins sublayer. By default,
         no limit is used, and all destinations are found.
     time_of_day {Date}:
         The departure time from origins.If you chose a traffic-based impedance
         attribute, the solution will be
         generated given dynamic traffic conditions at the time of day
         specified here. A date and time can be specified as 5/14/2012 10:30
         AM. Configure your analysis to use one of the following special
         dates to model a day of the week or the current date instead of a
         specific, static date:

         * Today-12/30/1899

         * Sunday-12/31/1899

         * Monday-1/1/1900

         * Tuesday-1/2/1900

         * Wednesday-1/3/1900

         * Thursday-1/4/1900

         * Friday-1/5/1900

         * Saturday-1/6/1900
     time_zone {String}:
         The time zone of the Time of Day parameter.

         * LOCAL_TIME_AT_LOCATIONS-The Time of Day parameter refers to the time
         zone in which the origins are located. This is the default.

         * UTC-The Time of Day parameter refers to coordinated universal time
         (UTC). Choose this option if you want to calculate the OD cost matrix
         for a specific time, such as now, but aren't certain in which time
         zone the origins will be located.
     line_shape {String}:
         Specifies the output line shape.

         * NO_LINES-No shape will be generated for the output origin-
         destination route pair. This is useful when you have a large number of
         origins and destinations and are interested only in the impedance
         costs in the OD cost matrix table, not in visualizing the OD cost
         matrix on a map.

         * STRAIGHT_LINES-The output route shape will be a single straight line
         between each of the origin-destination pairs. This is the default.
         Regardless of the output shape type specified, the best route is
         always determined by the network impedance, never Euclidean distance.
         This means that only the route shapes are different, not the
         underlying traversal of the network.
     accumulate_attributes {String}:
         A list of cost attributes to be accumulated during analysis. These
         accumulated attributes are for reference only; the solver only uses
         the cost attribute used by the designated travel mode when solving the
         analysis.For each cost attribute that is accumulated, a
         Total_[Impedance]
         property is populated in the network analysis output features.This
         parameter is not available if the network data source is an
         ArcGIS Online service or the network data source is a service on a
         version of Portal for ArcGIS that does not support accumulation.
     ignore_invalid_locations {Boolean}:
         Specifies whether invalid input locations will be ignored. Typically,
         locations are invalid if they cannot be located on the network. When
         invalid locations are ignored, the solver will skip them and attempt
         to perform the analysis using the remaining locations.

         * SKIP-Invalid input locations will be ignored and only valid
         locations will be used. This is the default.

         * HALT-All input locations will be used. Invalid locations will cause
         the analysis to fail."""
    ...

@gptooldoc("MakeODCostMatrixLayer_na", None)
def MakeODCostMatrixLayer(
    in_network_dataset=...,
    out_network_analysis_layer=...,
    impedance_attribute=...,
    default_cutoff=...,
    default_number_destinations_to_find=...,
    accumulate_attribute_name=...,
    UTurn_policy=...,
    restriction_attribute_name=...,
    hierarchy=...,
    hierarchy_settings=...,
    output_path_shape=...,
    time_of_day=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """MakeODCostMatrixLayer_na(in_network_dataset, out_network_analysis_layer, impedance_attribute, {default_cutoff}, {default_number_destinations_to_find}, {accumulate_attribute_name;accumulate_attribute_name...}, {UTurn_policy}, {restriction_attribute_name;restriction_attribute_name...}, {hierarchy}, {hierarchy_settings}, {output_path_shape}, {time_of_day})

       Makes an origin-destination (OD) cost matrix network analysis layer
       and sets its analysis properties. An OD cost matrix analysis layer is
       useful for representing a matrix of costs going from a set of origin
       locations to a set of destination locations.

    INPUTS:
     in_network_dataset (Network Dataset Layer):
         The network dataset on which the OD cost matrix analysis will be
         performed.
     out_network_analysis_layer (String):
         Name of the OD cost matrix network analysis layer to create.
     impedance_attribute (String):
         The cost attribute to be used as impedance in the analysis.
     default_cutoff {Double}:
         Default impedance value at which to cut off searching for destinations
         for a given origin. If the accumulated impedance becomes higher than
         the cutoff value, the traversal stops. The default can be overridden
         by specifying the cutoff value on the origins.
     default_number_destinations_to_find {Long}:
         Default number of destinations to find for each origin. The default
         can be overridden by specifying a value for the TargetDestinationCount
         property on the origins.
     accumulate_attribute_name {String}:
         A list of cost attributes to be accumulated during analysis. These
         accumulation attributes are for reference only; the solver only uses
         the cost attribute specified by the Impedance Attribute parameter to
         calculate the route.For each cost attribute that is accumulated, a
         Total_[Impedance]
         property is added to the routes that are output by the solver.
     UTurn_policy {String}:
         Specifies the U-turn policy that will be used at junctions. Allowing
         U-turns implies that the solver can turn around at a junction and
         double back on the same street. Given that junctions represent street
         intersections and dead ends, different vehicles may be able to turn
         around at some junctions but not at others-it depends on whether the
         junction represents an intersection or a dead end. To accommodate
         this, the U-turn policy parameter is implicitly specified by the
         number of edges that connect to the junction, which is known as
         junction valency. The acceptable values for this parameter are listed
         below; each is followed by a description of its meaning in terms of
         junction valency.

         * ALLOW_UTURNS-U-turns are permitted at junctions with any number of
         connected edges. This is the default value.

         * NO_UTURNS-U-turns are prohibited at all junctions, regardless of
         junction valency. However, U-turns are still permitted at network
         locations even when this setting is chosen, but you can set the
         individual network location's CurbApproach property to prohibit
         U-turns there as well.

         * ALLOW_DEAD_ENDS_ONLY-U-turns are prohibited at all junctions, except
         those that have only one adjacent edge (a dead end).

         * ALLOW_DEAD_ENDS_AND_INTERSECTIONS_ONLY-U-turns are prohibited at
         junctions where exactly two adjacent edges meet but are permitted at
         intersections (junctions with three or more adjacent edges) and dead
         ends (junctions with exactly one adjacent edge). Often, networks have
         extraneous junctions in the middle of road segments. This option
         prevents vehicles from making U-turns at these locations.
         If you need a more precisely defined U-turn policy, consider adding a
         global turn delay evaluator to a network cost attribute or adjusting
         its settings if one exists, and pay particular attention to the
         configuration of reverse turns. You can also set the CurbApproach
         property of your network locations.
     restriction_attribute_name {String}:
         A list of restriction attributes to be applied during the analysis.
     hierarchy {Boolean}:
         * USE_HIERARCHY-The hierarchy attribute will be used for the analysis.
         Using a hierarchy results in the solver preferring higher-order edges
         to lower-order edges. Hierarchical solves are faster, and they can be
         used to simulate the preference of a driver who chooses to travel on
         freeways rather than local roads when possible-even if that means a
         longer trip. This option is valid only if the input network dataset
         has a hierarchy attribute.

         * NO_HIERARCHY-The hierarchy attribute will not be used for the
         analysis. If hierarchy is not used, the result is an exact route for
         the network dataset.
         The parameter is not used if a hierarchy attribute is not defined on
         the network dataset used to perform the analysis.
     hierarchy_settings {Network Analyst Hierarchy Settings}:
         Prior to version 10, this parameter allowed you to change the
         hierarchy ranges for the analysis from the default hierarchy ranges
         established in the network dataset. At version 10, this parameter is
         no longer supported and should be specified as an empty string. To
         change the hierarchy ranges for the analysis, update the default
         hierarchy ranges in the network dataset.
     output_path_shape {String}:
         * NO_LINES-No shape will be generated for the output routes. This is
         useful when you have a large number of origins and destinations and
         are interested only in the OD cost matrix table (and not the output
         line shapes).

         * STRAIGHT_LINES-The output route shape will be a single straight line
         between each of the origin-destination pairs.
         Regardless of the output shape type specified, the best route is
         always determined by the network impedance, never Euclidean distance.
         This means that only the route shapes are different, not the
         underlying traversal of the network.
     time_of_day {Date}:
         Indicates the departure time from origins.If you have chosen a
         traffic-based impedance attribute, the solution
         will be generated given dynamic traffic conditions at the time of day
         specified here. A date and time can be specified as 5/14/2012 10:30
         AM. Instead of using a particular date, a day of the week can
         be
         specified using the following dates.For example, to specify that
         travel should begin at 5:00 PM on Tuesday, specify the parameter value
         as 1/2/1900 5:00 PM.

         * Today-12/30/1899

         * Sunday-12/31/1899

         * Monday-1/1/1900

         * Tuesday-1/2/1900

         * Wednesday-1/3/1900

         * Thursday-1/4/1900

         * Friday-1/5/1900

         * Saturday-1/6/1900"""
    ...

@gptooldoc("MakeRouteAnalysisLayer_na", None)
def MakeRouteAnalysisLayer(
    network_data_source=...,
    layer_name=...,
    travel_mode=...,
    sequence=...,
    time_of_day=...,
    time_zone=...,
    line_shape=...,
    accumulate_attributes=...,
    generate_directions_on_solve=...,
    time_zone_for_time_fields=...,
    ignore_invalid_locations=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """MakeRouteAnalysisLayer_na(network_data_source, {layer_name}, {travel_mode}, {sequence}, {time_of_day}, {time_zone}, {line_shape}, {accumulate_attributes;accumulate_attributes...}, {generate_directions_on_solve}, {time_zone_for_time_fields}, {ignore_invalid_locations})

       Makes a route network analysis layer and sets its analysis properties.
       A route network analysis layer is useful for determining the best
       route between a set of network locations based on a specified network
       cost. The layer can be created using a local network dataset or a
       routing service hosted online or in a portal.

    INPUTS:
     network_data_source (Network Dataset Layer / String):
         The network dataset or service on which the network analysis will be
         performed. Use the portal URL for a service.
     layer_name {String}:
         The name of the network analysis layer to create.
     travel_mode {String}:
         The name of the travel mode to use in the analysis. The travel mode
         represents a collection of network settings, such as travel
         restrictions and U-turn policies, that determine how a pedestrian,
         car, truck, or other medium of transportation moves through the
         network. Travel modes are defined on your network data source.An
         arcpy.na.TravelMode object and a string containing the valid JSON
         representation of a travel mode can also be used as input to the
         parameter.
     sequence {String}:
         Specifies whether the input stops must be visited in a particular
         order when calculating the optimal route. This option changes the
         route analysis from a shortest-path problem to a traveling salesperson
         problem (TSP).

         * USE_CURRENT_ORDER-The stops will be visited in the input order. This
         is the default.

         * FIND_BEST_ORDER-The stops will be reordered to find the optimal
         route. This option changes the route analysis from a shortest-path
         problem to a traveling salesperson problem (TSP).

         * PRESERVE_BOTH-The first and last stops will be preserved by input
         order. The rest will be reordered to find the optimal route.

         * PRESERVE_FIRST-The first stop will be preserved by input order. The
         rest will be reordered to find the optimal route.

         * PRESERVE_LAST-The last stop will be preserved by input order. The
         rest will be reordered to find the optimal route.
     time_of_day {Date}:
         The start date and time for the route. Route start time is typically
         used to find routes based on the impedance attribute that varies with
         the time of the day. For example, a start time of 7:00 a.m. can be
         used to find a route that considers rush hour traffic. The default
         value for this parameter is 8:00 a.m. A date and time can be specified
         as 10/21/05 10:30 AM. If the route spans multiple days and only the
         start time is specified, the current date is used.After the solve, the
         start and end times of the route are populated in
         the output routes. These start and end times are also used when
         directions are generated. Configure your analysis to use one of
         the following special
         dates to model a day of the week or the current date instead of a
         specific, static date:

         * Today-12/30/1899

         * Sunday-12/31/1899

         * Monday-1/1/1900

         * Tuesday-1/2/1900

         * Wednesday-1/3/1900

         * Thursday-1/4/1900

         * Friday-1/5/1900

         * Saturday-1/6/1900
     time_zone {String}:
         Specifies the time zone of the time_of_day parameter.

         * LOCAL_TIME_AT_LOCATIONS-The time_of_day parameter refers to the
         time zone in which the first stop of a route is located. This is the
         default.If you are generating many routes that start in multiple times
         zones, the start times are staggered in coordinated universal time
         (UTC). For example, a time_of_day value of 10:00 a.m., 2 January,
         means a start time of 10:00 a.m. eastern standard time (3:00 p.m. UTC)
         for routes beginning in the eastern time zone and 10:00 a.m. central
         standard time (4:00 p.m. UTC) for routes beginning in the central time
         zone. The start times are offset by one hour in UTC.The arrival and
         departure times and dates recorded in the output Stops feature class
         will refer to the local time zone of the first stop for each route.

         * UTC-The time_of_day parameter refers to coordinated universal time
         (UTC). Choose this option if you want to generate a route for a
         specific time, such as now, but aren't certain in which time zone the
         first stop will be located.If you are generating many routes spanning
         multiple times zones, the start times in UTC are simultaneous. For
         example, a time_of_day value of 10:00 a.m., 2 January, means a start
         time of 5:00 a.m. eastern standard time (10:00 a.m. UTC) for routes
         beginning in the eastern time zone and 4:00 a.m. central standard time
         (10:00 a.m. UTC) for routes beginning in the central time zone. Both
         routes start at 10:00 a.m. UTC.The arrival and departure times and
         dates recorded in the output Stops feature class will refer to UTC.
     line_shape {String}:
         Specifies the shape type that will be used for the route features that
         are output by the analysis.

         * ALONG_NETWORK-The output routes will have the exact shape of the
         underlying network sources. The output includes route measurements for
         linear referencing. The measurements increase from the first stop and
         record the cumulative impedance to reach a given position.

         * NO_LINES-No shape will be generated for the output routes.

         * STRAIGHT_LINES-The output route shape will be a single straight line
         between the stops.
         Regardless of the output shape type specified, the best route is
         always determined by the network impedance, never Euclidean distance.
         This means that only the route shapes are different, not the
         underlying traversal of the network.
     accumulate_attributes {String}:
         A list of cost attributes to be accumulated during analysis. These
         accumulated attributes are for reference only; the solver only uses
         the cost attribute used by the designated travel mode when solving the
         analysis.For each cost attribute that is accumulated, a
         Total_[Impedance]
         property is populated in the network analysis output features.This
         parameter is not available if the network data source is an
         ArcGIS Online service or the network data source is a service on a
         version of Portal for ArcGIS that does not support accumulation.
     generate_directions_on_solve {Boolean}:
         Specifies whether directions will be generated when running the
         analysis.

         * DIRECTIONS-Turn-by-turn directions will be generated on solve. This
         is the default.

         * NO_DIRECTIONS-Turn-by-turn directions will not be generated on
         solve.
         For an analysis in which generating turn-by-turn directions is not
         needed, using the NO_DIRECTIONS option will reduce the time it takes
         to solve the analysis.
     time_zone_for_time_fields {String}:
         Specifies the time zone that will be used to interpret the time fields
         included in the input tables, such as the fields used for time
         windows.

         * LOCAL_TIME_AT_LOCATIONS-The dates and times in the time fields for
         the stop will be interpreted according to the time zone in which the
         stop is located. This is the default.

         * UTC-The dates and times in the time fields for the stop refer to
         coordinated universal time (UTC).
     ignore_invalid_locations {Boolean}:
         Specifies whether invalid input locations will be ignored. Typically,
         locations are invalid if they cannot be located on the network. When
         invalid locations are ignored, the solver will skip them and attempt
         to perform the analysis using the remaining locations.

         * SKIP-Invalid input locations will be ignored and only valid
         locations will be used. This is the default.

         * HALT-All input locations will be used. Invalid locations will cause
         the analysis to fail."""
    ...

@gptooldoc("MakeRouteLayer_na", None)
def MakeRouteLayer(
    in_network_dataset=...,
    out_network_analysis_layer=...,
    impedance_attribute=...,
    find_best_order=...,
    ordering_type=...,
    time_windows=...,
    accumulate_attribute_name=...,
    UTurn_policy=...,
    restriction_attribute_name=...,
    hierarchy=...,
    hierarchy_settings=...,
    output_path_shape=...,
    start_date_time=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """MakeRouteLayer_na(in_network_dataset, out_network_analysis_layer, impedance_attribute, {find_best_order}, {ordering_type}, {time_windows}, {accumulate_attribute_name;accumulate_attribute_name...}, {UTurn_policy}, {restriction_attribute_name;restriction_attribute_name...}, {hierarchy}, {hierarchy_settings}, {output_path_shape}, {start_date_time})

       Makes a route network analysis layer and sets its analysis properties.
       A route analysis layer is useful for determining the best route
       between a set of network locations based on a specified network cost.

    INPUTS:
     in_network_dataset (Network Dataset Layer):
         The network dataset on which the route analysis will be performed.
     out_network_analysis_layer (String):
         Name of the route network analysis layer to create.
     impedance_attribute (String):
         The cost attribute to be used as impedance in the analysis.
     find_best_order {Boolean}:
         * FIND_BEST_ORDER-The stops will be reordered to find the optimal
         route. This option changes the route analysis from a shortest-path
         problem to a traveling salesperson problem (TSP).

         * USE_INPUT_ORDER-The stops will be visited in the input order. This
         is the default.
     ordering_type {String}:
         Specifies the ordering of stops when FIND_BEST_ORDER is used.

         * PRESERVE_BOTH-The first and last stops by input order will be
         preserved as the first and last stops in the route.

         * PRESERVE_FIRST-The first stop by input order will be preserved as
         the first stop in the route, but the last stop can be reordered.

         * PRESERVE_LAST-The last stop by input order will be preserved as the
         last stop in the route, but the first stop can be reordered.

         * PRESERVE_NONE-The first and last stops will not be preserved and can
         be reordered.
     time_windows {Boolean}:
         Specifies whether time windows will be used at the stops.

         * USE_TIMEWINDOWS-The route will consider time windows on the stops.
         If a stop is arrived at before its time window, there will be wait
         time until the time window starts. If a stop is arrived at after its
         time window, there will be a time window violation. Total time window
         violation is balanced against minimum impedance when computing the
         route. This is a valid option only when the impedance is in time
         units.

         * NO_TIMEWINDOWS-The route will ignore time windows on the stops. This
         is the default.
     accumulate_attribute_name {String}:
         A list of cost attributes to be accumulated during analysis. These
         accumulation attributes are for reference only; the solver only uses
         the cost attribute specified by the Impedance Attribute parameter to
         calculate the route.For each cost attribute that is accumulated, a
         Total_[Impedance]
         property is added to the routes that are output by the solver.
     UTurn_policy {String}:
         Specifies the U-turn policy that will be used at junctions. Allowing
         U-turns implies that the solver can turn around at a junction and
         double back on the same street. Given that junctions represent street
         intersections and dead ends, different vehicles may be able to turn
         around at some junctions but not at others-it depends on whether the
         junction represents an intersection or a dead end. To accommodate
         this, the U-turn policy parameter is implicitly specified by the
         number of edges that connect to the junction, which is known as
         junction valency. The acceptable values for this parameter are listed
         below; each is followed by a description of its meaning in terms of
         junction valency.

         * ALLOW_UTURNS-U-turns are permitted at junctions with any number of
         connected edges. This is the default value.

         * NO_UTURNS-U-turns are prohibited at all junctions, regardless of
         junction valency. However, U-turns are still permitted at network
         locations even when this setting is chosen, but you can set the
         individual network location's CurbApproach property to prohibit
         U-turns there as well.

         * ALLOW_DEAD_ENDS_ONLY-U-turns are prohibited at all junctions, except
         those that have only one adjacent edge (a dead end).

         * ALLOW_DEAD_ENDS_AND_INTERSECTIONS_ONLY-U-turns are prohibited at
         junctions where exactly two adjacent edges meet but are permitted at
         intersections (junctions with three or more adjacent edges) and dead
         ends (junctions with exactly one adjacent edge). Often, networks have
         extraneous junctions in the middle of road segments. This option
         prevents vehicles from making U-turns at these locations.
         If you need a more precisely defined U-turn policy, consider adding a
         global turn delay evaluator to a network cost attribute or adjusting
         its settings if one exists, and pay particular attention to the
         configuration of reverse turns. You can also set the CurbApproach
         property of your network locations.
     restriction_attribute_name {String}:
         A list of restriction attributes to be applied during the analysis.
     hierarchy {Boolean}:
         * USE_HIERARCHY-The hierarchy attribute will be used for the analysis.
         Using a hierarchy results in the solver preferring higher-order edges
         to lower-order edges. Hierarchical solves are faster, and they can be
         used to simulate the preference of a driver who chooses to travel on
         freeways rather than local roads when possible-even if that means a
         longer trip. This option is valid only if the input network dataset
         has a hierarchy attribute.

         * NO_HIERARCHY-The hierarchy attribute will not be used for the
         analysis. If hierarchy is not used, the result is an exact route for
         the network dataset.
         The parameter is not used if a hierarchy attribute is not defined on
         the network dataset used to perform the analysis.
     hierarchy_settings {Network Analyst Hierarchy Settings}:
         Prior to version 10, this parameter allowed you to change the
         hierarchy ranges for the analysis from the default hierarchy ranges
         established in the network dataset. At version 10, this parameter is
         no longer supported and should be specified as an empty string. To
         change the hierarchy ranges for the analysis, update the default
         hierarchy ranges in the network dataset.
     output_path_shape {String}:
         Specifies the shape type that will be used for the route features that
         are output by the analysis.

         * TRUE_LINES_WITH_MEASURES-The output routes will have the exact shape
         of the underlying network sources. The output includes route
         measurements for linear referencing. The measurements increase from
         the first stop and record the cumulative impedance to reach a given
         position.

         * TRUE_LINES_WITHOUT_MEASURES-The output routes will have the exact
         shape of the underlying network sources.

         * STRAIGHT_LINES-The output route shape will be a single straight line
         between the stops.

         * NO_LINES-No shape will be generated for the output routes.
         Regardless of the output shape type specified, the best route is
         always determined by the network impedance, never Euclidean distance.
         This means that only the route shapes are different, not the
         underlying traversal of the network.
     start_date_time {Date}:
         The start date and time for the route. Route start time is typically
         used to find routes based on the impedance attribute that varies with
         the time of the day. For example, a start time of 7:00 a.m. can be
         used to find a route that considers rush hour traffic. The default
         value for this parameter is 8:00 a.m. A date and time can be specified
         as 10/21/05 10:30 AM. If the route spans multiple days and only the
         start time is specified, the current date is used. Configure
         your analysis to use one of the following special
         dates to model a day of the week or the current date instead of a
         specific, static date:

         * Today-12/30/1899

         * Sunday-12/31/1899

         * Monday-1/1/1900

         * Tuesday-1/2/1900

         * Wednesday-1/3/1900

         * Thursday-1/4/1900

         * Friday-1/5/1900

         * Saturday-1/6/1900
         For example, to specify that travel should begin at 5:00 p.m. on
         Tuesday, specify the parameter value as 1/2/1900 5:00 PM.After the
         solve, the start and end times of the route are populated in
         the output routes. These start and end times are also used when
         directions are generated."""
    ...

@gptooldoc("MakeServiceAreaAnalysisLayer_na", None)
def MakeServiceAreaAnalysisLayer(
    network_data_source=...,
    layer_name=...,
    travel_mode=...,
    travel_direction=...,
    cutoffs=...,
    time_of_day=...,
    time_zone=...,
    output_type=...,
    polygon_detail=...,
    geometry_at_overlaps=...,
    geometry_at_cutoffs=...,
    polygon_trim_distance=...,
    exclude_sources_from_polygon_generation=...,
    accumulate_attributes=...,
    ignore_invalid_locations=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """MakeServiceAreaAnalysisLayer_na(network_data_source, {layer_name}, {travel_mode}, {travel_direction}, {cutoffs;cutoffs...}, {time_of_day}, {time_zone}, {output_type}, {polygon_detail}, {geometry_at_overlaps}, {geometry_at_cutoffs}, {polygon_trim_distance}, {exclude_sources_from_polygon_generation;exclude_sources_from_polygon_generation...}, {accumulate_attributes;accumulate_attributes...}, {ignore_invalid_locations})

       Makes a service area network analysis layer and sets its analysis
       properties. A service area analysis layer is useful in determining the
       area of accessibility within a given cutoff cost from a facility
       location. The layer can be created using a local network dataset or a
       routing service hosted online or in a portal.

    INPUTS:
     network_data_source (Network Dataset Layer / String):
         The network dataset or service on which the network analysis will be
         performed. Use the portal URL for a service.
     layer_name {String}:
         The name of the network analysis layer to create.
     travel_mode {String}:
         The name of the travel mode to use in the analysis. The travel mode
         represents a collection of network settings, such as travel
         restrictions and U-turn policies, that determine how a pedestrian,
         car, truck, or other medium of transportation moves through the
         network. Travel modes are defined on your network data source.An
         arcpy.na.TravelMode object and a string containing the valid JSON
         representation of a travel mode can also be used as input to the
         parameter.
     travel_direction {String}:
         Specifies the direction of travel to or from the facilities.

         * FROM_FACILITIES-The direction of travel is away from the facilities.
         This is the default.

         * TO_FACILITIES-The direction of travel is toward the facilities.
         Using this parameter can result in different service areas on a
         network with one-way restrictions and different impedances based on
         direction of travel. The service area for a pizza delivery store, for
         example, should be created away from the facility, whereas the service
         area of a hospital should be created toward the facility.
     cutoffs {Double}:
         The extent of the service area to be calculated in the units of the
         impedance attribute used by the selected travel mode. For example,
         when analyzing driving time, a cutoff value of 10 means that the
         resulting service area will represent the area reachable within a
         10-minute drive time.Multiple cutoffs can be set to create concentric
         service areas. For
         example, to find 2-, 3-, and 5-minute service areas for the same
         facility, specify 2, 3, and 5 as the values for this parameter.This
         default cutoff value can be overridden on a per-facility basis by
         specifying individual break values in the facilities sublayer.
     time_of_day {Date}:
         The time to depart from or arrive at the facilities of the
         service area layer. The interpretation of this value as a departure or
         arrival time depends on whether travel is away from or toward the
         facilities.

         * It represents the departure time if
         travel_direction='FROM_FACILITIES'.

         * It represents the arrival time if travel_direction='TO_FACILITIES'.
         The time_of_day parameter is most useful for finding the roads that
         can be reached based on a travel mode that uses an impedance attribute
         that varies with the time of the day, such as one based on dynamic
         traffic conditions. Solving the same analysis using different
         time_of_day values allows you to see how a facility's reach changes
         over time. For example, the five-minute service area around a fire
         station may start out large in the early morning, diminish during the
         morning rush hour, grow in the late morning, and so on throughout the
         day.A date and time can be specified as 10/21/2015 10:30 AM.
         Configure your analysis to use one of the following special
         dates to model a day of the week or the current date instead of a
         specific, static date:

         * Today-12/30/1899

         * Sunday-12/31/1899

         * Monday-1/1/1900

         * Tuesday-1/2/1900

         * Wednesday-1/3/1900

         * Thursday-1/4/1900

         * Friday-1/5/1900

         * Saturday-1/6/1900
     time_zone {String}:
         Specifies the time zone for the time of day parameter.

         * LOCAL_TIME_AT_LOCATIONS-The time of day parameter will use the time
         zone or zones in which the facilities are located. The start or end
         times of the service areas are staggered by time zone. This is the
         default.For example, setting time of day to 9:00 a.m. causes service
         areas to be generated for 9:00 a.m. eastern time for facilities in the
         eastern time zone, 9:00 a.m. central time for facilities in the
         central time zone, 9:00 a.m. mountain time for facilities in the
         mountain time zone, and so on. If stores in a chain that span the U.S.
         open at 9:00 a.m. local time, choose this parameter value to find
         market territories at opening time for all stores in one solve. First,
         the stores in the eastern time zone open and a polygon is generated.
         An hour later, stores open in the central time zone, and so on. Nine
         o'clock is always in local time but staggered in real time.

         * UTC-The time of day parameter will use coordinated
         universal time (UTC). All facilities are reached or departed from
         simultaneously, regardless of the time zone or zones in which they are
         located.Setting time of day to 2:00 p.m. causes service areas to be
         generated for 9:00 a.m. eastern standard time for facilities in the
         eastern time zone, 8:00 a.m. central standard time for facilities in
         the central time zone, 7:00 a.m. mountain standard time for facilities
         in the mountain time zone, and so on.One of the cases in which the UTC
         option is useful is to visualize emergency response coverage for a
         jurisdiction that is split into two time zones. The emergency vehicles
         are loaded as facilities. Time of day is set to now in UTC. (You need
         to determine what the current time and date are in terms of UTC to
         correctly use this option.) Other properties are set and the analysis
         is solved. Even though a time-zone boundary divides the vehicles, the
         results show areas that can be reached given current traffic
         conditions. This same process can be used for other times as well, not
         just for now. The scenario above assumes standard time.
         During daylight saving time,
         the eastern, central, and mountain times will each be one hour ahead
         (that is, 10:00, 9:00, and 8:00 a.m., respectively).
     output_type {String}:
         Specifies the type of output to be generated. Service area output can
         be line features representing the roads reachable before the cutoffs
         are exceeded or the polygon features encompassing these lines
         (representing the reachable area).

         * POLYGONS-The service area output will contain polygons only. This is
         the default.

         * LINES-The service area output will contain lines only.

         * POLYGONS_AND_LINES-The service area output will contain both
         polygons and lines.
         The Lines and Polygons and lines output types are not available if the
         network data source is a service on a version of Portal for ArcGIS
         that does not support line generation.
     polygon_detail {String}:
         Specifies the level of detail of the output polygons.

         * STANDARD-Polygons with a standard level of detail will be created.
         This is the default.

         * GENERALIZED-Generalized polygons will be created using the network's
         hierarchy attribute to produce results quickly. This option is not
         available if the network does not have a hierarchy attribute.

         * HIGH-Polygons with a higher level of detail will be created for
         applications in which precise results are important.
         If the analysis includes an urban area with a grid-like street
         network, the difference between generalized and standard polygons will
         be minimal. However, for mountain and rural roads, the standard and
         detailed polygons may present more accurate results than generalized
         polygons.
     geometry_at_overlaps {String}:
         Specifies the behavior of service-area output from multiple facilities
         in relation to one another.

         * OVERLAP-Individual polygons or sets of lines for each facility will
         be created. The polygons or lines can overlap each other. This is the
         default.

         * DISSOLVE-The polygons of multiple facilities that have the same
         cutoff value will be joined into a single polygon. This option does
         not apply to line output.

         * SPLIT-An area will be assigned to the closest facility so polygons
         or lines do not overlap each other.
     geometry_at_cutoffs {String}:
         Specifies the behavior of service area output for a single facility
         when multiple cutoff values are specified. This parameter does not
         apply to line output.

         * RINGS-Each polygon will include only the area between consecutive
         cutoff values. It will not include the area between the facility and
         any smaller cutoffs. For example, if you create 5- and 10-minute
         service areas, the 5-minute service area polygon will include the area
         reachable in 0 to 5 minutes, and the 10-minute service area polygon
         will include the area reachable in 5 to 10 minutes. This is the
         default.

         * DISKS-Each polygon will include the area reachable from the facility
         up to the cutoff value, including the area reachable within smaller
         cutoff values. For example, if you create 5- and 10-minute service
         areas, the 10-minute service area polygon will include the area under
         the 5-minute service area polygon.
     polygon_trim_distance {Linear Unit}:
         The service area polygon trim distance. The polygon trim distance is
         the distance the service area polygon will extend from the road when
         no other reachable roads are nearby, similar to a line buffer size.
         This is useful when the network is sparse and you don't want the
         service area to cover large areas where there are no features.This
         parameter includes a value and units for the distance. The
         default value is 100 meters.
     exclude_sources_from_polygon_generation {String}:
         The network dataset edge sources that will be excluded when generating
         service area polygons. Polygons will not be generated around the
         excluded sources, even though they are traversed in the
         analysis.Excluding a network source from service area polygons does
         not prevent
         those sources from being traversed. Excluding sources from service
         area polygons only influences the polygon shape of the service areas.
         To prevent traversal of a given network source, you must create an
         appropriate restriction when defining your network dataset.This is
         useful if you have some network sources that you don't want to
         be included in the polygon generation because they create less-
         accurate polygons or are inconsequential for the service area
         analysis. For example, while creating a walk-time service area in a
         multimodal network that includes streets and metro lines, you should
         choose to exclude the metro lines from polygon generation. Although
         the traveler can use the metro lines, they cannot stop partway along a
         metro line and enter a nearby building. Instead, they must travel the
         full length of the metro line, exit the metro system at a station,
         then use the streets to walk to the building. It would be inaccurate
         to generate a polygon feature around a metro line.This parameter is
         not available when the output geometry types do not
         include polygons, there are fewer than two edge sources in the
         network, the network data source is an ArcGIS Online service, or the
         network data source is a service on a version of Portal for ArcGIS
         that does not support excluding sources.
     accumulate_attributes {String}:
         A list of cost attributes to be accumulated during analysis. These
         accumulated attributes are for reference only; the solver only uses
         the cost attribute used by the designated travel mode when solving the
         analysis.For each cost attribute that is accumulated, a
         Total_[Impedance]
         property is populated in the network analysis output features.This
         parameter is not available if the analysis layer is not
         configured to output lines, the network data source is an ArcGIS
         Online service, or the network data source is a service on a version
         of Portal for ArcGIS that does not support accumulation.
     ignore_invalid_locations {Boolean}:
         Specifies whether invalid input locations will be ignored. Typically,
         locations are invalid if they cannot be located on the network. When
         invalid locations are ignored, the solver will skip them and attempt
         to perform the analysis using the remaining locations.

         * SKIP-Invalid input locations will be ignored and only valid
         locations will be used. This is the default.

         * HALT-All input locations will be used. Invalid locations will cause
         the analysis to fail."""
    ...

@gptooldoc("MakeServiceAreaLayer_na", None)
def MakeServiceAreaLayer(
    in_network_dataset=...,
    out_network_analysis_layer=...,
    impedance_attribute=...,
    travel_from_to=...,
    default_break_values=...,
    polygon_type=...,
    merge=...,
    nesting_type=...,
    line_type=...,
    overlap=...,
    split=...,
    excluded_source_name=...,
    accumulate_attribute_name=...,
    UTurn_policy=...,
    restriction_attribute_name=...,
    polygon_trim=...,
    poly_trim_value=...,
    lines_source_fields=...,
    hierarchy=...,
    time_of_day=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """MakeServiceAreaLayer_na(in_network_dataset, out_network_analysis_layer, impedance_attribute, {travel_from_to}, {default_break_values}, {polygon_type}, {merge}, {nesting_type}, {line_type}, {overlap}, {split}, {excluded_source_name;excluded_source_name...}, {accumulate_attribute_name;accumulate_attribute_name...}, {UTurn_policy}, {restriction_attribute_name;restriction_attribute_name...}, {polygon_trim}, {poly_trim_value}, {lines_source_fields}, {hierarchy}, {time_of_day})

       Makes a service area network analysis layer and sets its analysis
       properties. A service area analysis layer is useful in determining the
       area of accessibility within a given cutoff cost from a facility
       location.

    INPUTS:
     in_network_dataset (Network Dataset Layer):
         The network dataset on which the service area analysis will be
         performed.
     out_network_analysis_layer (String):
         Name of the service area network analysis layer to create.
     impedance_attribute (String):
         The cost attribute to be used as impedance in the analysis.
     travel_from_to {String}:
         Specifies the direction of travel to or from the facilities.

         * TRAVEL_FROM-The service area is created in the direction away from
         the facilities.

         * TRAVEL_TO-The service area is created in the direction towards the
         facilities.
         Using this option can result in different service areas on a network
         with one-way restrictions and having different impedances based on
         direction of travel. The service area for a pizza delivery store, for
         example, should be created away from the facility, whereas the service
         area of a hospital should be created toward the facility.
     default_break_values {String}:
         Default impedance values indicating the extent of the service area to
         be calculated. The default can be overridden by specifying the break
         value on the facilities.Multiple polygon breaks can be set to create
         concentric service areas.
         For instance, to find 2-, 3-, and 5-minute service areas for the same
         facility, specify "2 3 5" as the value for the Default break values
         parameter (the numbers 2, 3, and 5 should be separated by a space).
     polygon_type {String}:
         Specifies the type of polygons to be generated.

         * SIMPLE_POLYS-Creates generalized polygons, which are generated
         quickly and are fairly accurate, except on the fringes. This is the
         default.

         * DETAILED_POLYS-Creates detailed polygons, which accurately model the
         service area lines and may contain islands of unreached areas. This
         option is slower than generating generalized polygons.

         * NO_POLYS-Turns off polygon generation for the case in which only
         service area lines are desired.
         If your data is of an urban area with a gridlike network, the
         difference between generalized and detailed polygons would be minimal.
         However, for mountain and rural roads, the detailed polygons may
         present significantly more accurate results than generalized polygons.
     merge {String}:
         Specifies the options to merge polygons that share similar break
         values. This option is applicable only when generating polygons for
         multiple facilities.

         * NO_MERGE-Creates individual polygons for each facility. The polygons
         can overlap each other.

         * NO_OVERLAP-Creates individual polygons that are closest for each
         facility. The polygons do not overlap each other.

         * MERGE-Joins the polygons of multiple facilities that have the same
         break value.
     nesting_type {String}:
         Specifies the option to create concentric service area polygons as
         disks or rings. This option is applicable only when multiple break
         values are specified for the facilities.

         * RINGS-Do not include the area of the smaller breaks. This creates
         polygons going between consecutive breaks. Use this option if you want
         to find the area from one break to another.

         * DISKS-Creates the polygons going from the facility to the break.
         For instance, If you create 5- and 10-minute service areas, then the
         10-minute service area polygon will include the area under the
         5-minute service area polygon. Use this option if you want to find the
         entire area from the facility to the break for each break.
     line_type {String}:
         Specifies the type of lines to be generated based on the service area
         analysis. Selecting the TRUE_LINES or TRUE_LINES_WITH_MEASURES option
         for large service areas will increase the amount of memory consumed by
         the analysis.

         * NO_LINES-Do not generate lines. This is the default.

         * TRUE_LINES-Lines are generated without measures.

         * TRUE_LINES_WITH_MEASURES-Lines are generated with measures. The
         measure values are generated based on the impedance value on each end
         of the edge with the intermediate vertices interpolated. Do not use
         this option if faster performance is desired.
     overlap {Boolean}:
         Determines whether overlapping lines are generated when the service
         area lines are computed.

         * OVERLAP-Include a separate line feature for each facility when the
         facilities have service area lines that are coincident.

         * NON_OVERLAP-Include each service area line at most once and
         associate it with its closest (least impedance) facility.
     split {Boolean}:
         * SPLIT-Split every line between two breaks into two lines, each lying
         within its break. This is useful if you want to symbolize the service
         area lines by break. Otherwise, use the NO_SPLIT option for optimal
         performance.

         * NO_SPLIT-The lines are not split at the boundaries of the breaks.
         This is the default.
     excluded_source_name {String}:
         Specifies the list of network sources to be excluded when generating
         the polygons. The geometry of traversed elements from the excluded
         sources will be omitted from all polygons.This is useful if you have
         some network sources that you don't want to
         be included in the polygon generation because they create less
         accurate polygons or are inconsequential for the service area
         analysis. For example, while creating a drive time service area in a
         multimodal network of streets and rails, you should choose to exclude
         the rail lines from polygon generation so as to correctly model where
         a vehicle could travel.Excluding a network source from service area
         polygons does not prevent
         those sources from being traversed. Excluding sources from service
         area polygons only influences the polygon shape of the service areas.
         If you want to prevent traversal of a given network source, you must
         create an appropriate restriction when defining your network dataset.
     accumulate_attribute_name {String}:
         A list of cost attributes to be accumulated during analysis. These
         accumulation attributes are for reference only; the solver only uses
         the cost attribute specified by the Impedance Attribute parameter to
         calculate the route.For each cost attribute that is accumulated, a
         Total_[Impedance]
         property is added to the routes that are output by the solver.
     UTurn_policy {String}:
         Specifies the U-turn policy that will be used at junctions. Allowing
         U-turns implies that the solver can turn around at a junction and
         double back on the same street. Given that junctions represent street
         intersections and dead ends, different vehicles may be able to turn
         around at some junctions but not at others-it depends on whether the
         junction represents an intersection or a dead end. To accommodate
         this, the U-turn policy parameter is implicitly specified by the
         number of edges that connect to the junction, which is known as
         junction valency. The acceptable values for this parameter are listed
         below; each is followed by a description of its meaning in terms of
         junction valency.

         * ALLOW_UTURNS-U-turns are permitted at junctions with any number of
         connected edges. This is the default value.

         * NO_UTURNS-U-turns are prohibited at all junctions, regardless of
         junction valency. However, U-turns are still permitted at network
         locations even when this setting is chosen, but you can set the
         individual network location's CurbApproach property to prohibit
         U-turns there as well.

         * ALLOW_DEAD_ENDS_ONLY-U-turns are prohibited at all junctions, except
         those that have only one adjacent edge (a dead end).

         * ALLOW_DEAD_ENDS_AND_INTERSECTIONS_ONLY-U-turns are prohibited at
         junctions where exactly two adjacent edges meet but are permitted at
         intersections (junctions with three or more adjacent edges) and dead
         ends (junctions with exactly one adjacent edge). Often, networks have
         extraneous junctions in the middle of road segments. This option
         prevents vehicles from making U-turns at these locations.
         If you need a more precisely defined U-turn policy, consider adding a
         global turn delay evaluator to a network cost attribute or adjusting
         its settings if one exists, and pay particular attention to the
         configuration of reverse turns. You can also set the CurbApproach
         property of your network locations.
     restriction_attribute_name {String}:
         A list of restriction attributes to be applied during the analysis.
     polygon_trim {Boolean}:
         * TRIM_POLYS-Trims the polygons containing the edges at the periphery
         of the service area to be within the specified distance of these outer
         edges. This is useful if the network is very sparse and you don't want
         the service area to cover large areas where there are no features.

         * NO_TRIM_POLYS-Do not trim polygons.
     poly_trim_value {Linear Unit}:
         Specifies the distance within which the service area polygons are
         trimmed. The parameter includes a value and units for the distance.
         The default value is 100 meters.
     lines_source_fields {Boolean}:
         * LINES_SOURCE_FIELDS-Add the SourceID, SourceOID, FromPosition, and
         ToPosition fields to the service area lines to hold information about
         the underlying source features traversed during the analysis. This can
         be useful to join the results of the service area lines to the
         original source data.

         * NO_LINES_SOURCE_FIELDS-Do not add the source fields (SourceID,
         SourceOID, FromPosition, and ToPosition) to the service area lines.
     hierarchy {Boolean}:
         * USE_HIERARCHY-The hierarchy attribute will be used for the analysis.
         Using a hierarchy results in the solver preferring higher-order edges
         to lower-order edges. Hierarchical solves are faster, and they can be
         used to simulate the preference of a driver who chooses to travel on
         freeways rather than local roads when possible-even if that means a
         longer trip. This option is valid only if the input network dataset
         has a hierarchy attribute.

         * NO_HIERARCHY-The hierarchy attribute will not be used for the
         analysis. If hierarchy is not used, the result is a service area
         measured along all edges of the network dataset regardless of
         hierarchy level.
         The parameter is not used if a hierarchy attribute is not defined on
         the network dataset used to perform the analysis.
     time_of_day {Date}:
         The time to depart from or arrive at the facilities of the
         service area layer. The interpretation of this value as a depart or
         arrive time depends on whether travel is away from or toward the
         facilities.

         * It represents the departure time if Travel From or To Facility is
         set to TRAVEL_FROM.

         * It represents the arrival time if Travel From or To Facility is set
         to TRAVEL_TO.
         If you have chosen a traffic-based impedance attribute, the solution
         will be generated given dynamic traffic conditions at the time of day
         specified here. A date and time can be specified as 5/14/2012 10:30
         AM. Instead of using a particular date, a day of the week can
         be
         specified using the following dates.For example, to specify that
         travel should begin at 5:00 PM on Tuesday, specify the parameter value
         as 1/2/1900 5:00 PM.

         * Today-12/30/1899

         * Sunday-12/31/1899

         * Monday-1/1/1900

         * Tuesday-1/2/1900

         * Wednesday-1/3/1900

         * Thursday-1/4/1900

         * Friday-1/5/1900

         * Saturday-1/6/1900
         Repeatedly solving the same analysis, but using different Time of Day
         values, allows you to see how a facility's reach changes over time.
         For instance, the five-minute service area around a fire station may
         start out large in the early morning, diminish during the morning rush
         hour, grow in the late morning, and so on throughout the day."""
    ...

@gptooldoc("MakeVehicleRoutingProblemAnalysisLayer_na", None)
def MakeVehicleRoutingProblemAnalysisLayer(
    network_data_source=...,
    layer_name=...,
    travel_mode=...,
    time_units=...,
    distance_units=...,
    default_date=...,
    time_zone_for_time_fields=...,
    line_shape=...,
    time_window_factor=...,
    excess_transit_factor=...,
    generate_directions_on_solve=...,
    spatial_clustering=...,
    ignore_invalid_locations=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """MakeVehicleRoutingProblemAnalysisLayer_na(network_data_source, {layer_name}, {travel_mode}, {time_units}, {distance_units}, {default_date}, {time_zone_for_time_fields}, {line_shape}, {time_window_factor}, {excess_transit_factor}, {generate_directions_on_solve}, {spatial_clustering}, {ignore_invalid_locations})

       Creates a vehicle routing problem (VRP) network analysis layer and
       sets its analysis properties. A VRP analysis layer is useful for
       optimizing a set of routes using a fleet of vehicles. The layer can be
       created using a local network dataset or a service hosted online or in
       a portal.

    INPUTS:
     network_data_source (Network Dataset Layer / String):
         The network dataset or service on which the network analysis will be
         performed. Use the portal URL for a service.
     layer_name {String}:
         The name of the VRP network analysis layer to create.
     travel_mode {String}:
         The name of the travel mode to use in the analysis. The travel mode
         represents a collection of network settings, such as travel
         restrictions and U-turn policies, that determine how a pedestrian,
         car, truck, or other medium of transportation moves through the
         network. Travel modes are defined on your network data source. An
         arcpy.na.TravelMode object and a string containing the valid JSON
         representation of a travel mode can also be used as input to the
         parameter.
     time_units {String}:
         Specifies the time units to be used by the temporal fields of the
         analysis layer's sublayers and tables (network analysis classes). This
         value does not need to match the units of the time cost attribute.

         * Minutes-The time units will be minutes. This is the default.

         * Seconds-The time units will be seconds.

         * Hours-The time units will be hours.

         * Days-The time units will be days.
     distance_units {String}:
         Specifies the distance units to be used by the distance fields of the
         analysis layer's sublayers and tables (network analysis classes). This
         value does not need to match the units of the optional distance cost
         attribute.

         * Miles-The distance units will be miles. This is the default.

         * Kilometers-The distance units will be kilometers.

         * Feet-The distance units will be feet.

         * Yards-The distance units will be yards.

         * Meters-The distance units will be meters.

         * Inches-The distance units will be inches.

         * Centimeters-The distance units will be centimeters.

         * Millimeters-The distance units will be millimeters.

         * Decimeters-The distance units will be decimeters.

         * NauticalMiles-The distance units will be nautical miles.
     default_date {Date}:
         The implied date for time field values that don't have a date
         specified with the time. If a time field for an order object, such as
         TimeWindowStart, has a time-only value, the date is assumed to be the
         default date. The default date has no effect on time field values that
         already have a date. Configure your analysis to use one of the
         following special
         dates to model a day of the week or the current date instead of a
         specific, static date:

         * Today-12/30/1899

         * Sunday-12/31/1899

         * Monday-1/1/1900

         * Tuesday-1/2/1900

         * Wednesday-1/3/1900

         * Thursday-1/4/1900

         * Friday-1/5/1900

         * Saturday-1/6/1900
     time_zone_for_time_fields {String}:
         Specifies the time zone to be used for the input date-time fields
         supported by the tool.

         * LOCAL_TIME_AT_LOCATIONS-The date-time values associated with the
         orders or depots will be in the time zone in which the orders and
         depots are located. For routes, the date-time values are based on the
         time zone in which the starting depot for the route is located. If a
         route does not have a starting depot, all orders and depots across all
         the routes must be in a single time zone. For breaks, the date-time
         values are based on the time zone of the routes. This is the default.

         * UTC-The date-time values associated with the orders or depots will
         be in coordinated universal time (UTC) and are not based on the time
         zone in which the orders or depots are located.
         Specifying the date-time values in UTC is useful if you do not know
         the time zone in which the orders or depots are located or when you
         have orders and depots in multiple time zones and you want all the
         date-time values to start simultaneously. The UTC option is applicable
         only when your network dataset defines a time zone attribute.
         Otherwise, all the date-time values are treated as the time zone
         corresponding to that location.
     line_shape {String}:
         Specifies the shape type that will be used for the route features that
         are output by the analysis.

         * ALONG_NETWORK-The output routes will have the exact shape of the
         underlying network sources. The output includes route measurements for
         linear referencing. The measurements increase from the first stop and
         record the cumulative impedance to reach a given position.

         * NO_LINES-No shape will be generated for the output routes.

         * STRAIGHT_LINES-The output route shape will be a single straight line
         between the stops.This option is not available if the selected network
         data source is a service.
         Regardless of the output shape type specified, the best route is
         always determined by the network impedance, never Euclidean distance.
         This means that only the route shapes are different, not the
         underlying traversal of the network.
     time_window_factor {String}:
         Specifies the importance of honoring time windows without causing
         violations. A time window violation occurs when a route arrives at an
         order, depot, or break after a time window has closed. The violation
         is the interval between the end of the time window and the arrival
         time of a route.

         * High-The solver searches for a solution that minimizes time window
         violations at the expense of increasing the overall travel time.
         Choose this setting if arriving on time at orders is more important
         than minimizing the overall solution cost. This may be the case if you
         are meeting customers at your orders and you don't want to
         inconvenience them with late arrivals (another option is to use rigid
         time windows that cannot be violated).Given other constraints of a
         vehicle routing problem, it may be impossible to visit all the orders
         within their time windows. In this case, even a High setting may
         produce violations.

         * Medium-The solver searches for a balance between meeting time
         windows and reducing the overall solution cost. This is the default.

         * Low-The solver searches for a solution that minimizes overall travel
         time, regardless of time windows. Choose this setting if respecting
         time windows is less important than reducing the overall solution
         cost. You may want to use this setting if you have a growing backlog
         of service requests. For the purpose of servicing more orders in a day
         and reducing the backlog, you can choose this setting even though
         customers may be inconvenienced with your fleet's late arrivals.
     excess_transit_factor {String}:
         Specifies the importance of reducing excess transit time. Excess
         transit time is the amount of time exceeding the time required to
         travel directly between paired orders. The excess time results from
         breaks or travel to other orders or depots between visits to the
         paired orders. This parameter is only relevant if you're using Order
         Pairs.

         * High-The solver searches for a solution with less excess transit
         time between paired orders at the expense of increasing the overall
         travel costs. Use this setting if you are transporting people between
         paired orders and you want to shorten their ride time. This is
         characteristic of taxi services.

         * Medium-The solver searches for a balance between reducing excess
         transit time and reducing the overall solution cost. This is the
         default.

         * Low-The solver searches for a solution that minimizes overall
         solution cost, regardless of excess transit time. This setting is
         commonly used with courier services. Since couriers transport packages
         as opposed to people, ride time is not as important. Using this
         setting allows couriers to service paired orders in the proper
         sequence and minimize the overall solution cost.
     generate_directions_on_solve {Boolean}:
         Specifies whether directions will be generated.

         * DIRECTIONS-Turn-by-turn directions will be generated on solve. This
         is the default.

         * NO_DIRECTIONS-Turn-by-turn directions will not be generated on
         solve.
     spatial_clustering {Boolean}:
         Specifies whether spatial clustering will be used.

         * CLUSTER-The orders assigned to an individual route will be spatially
         clustered. Clustering orders tends to keep routes in smaller areas and
         reduce how often route lines intersect one another; however,
         clustering can increase overall travel times. This is the default.

         * NO_CLUSTER-The solver will not prioritize spatially clustering
         orders and the route lines may intersect. Use this option if route
         zones are specified.
     ignore_invalid_locations {Boolean}:
         Specifies whether invalid input locations will be ignored.

         * SKIP-Invalid input locations will be ignored so that the analysis
         will succeed using only valid locations.

         * HALT-Invalid locations will not be ignored and will cause the
         analysis to fail. This is the default."""
    ...

@gptooldoc("ShareAsRouteLayers_na", None)
def ShareAsRouteLayers(
    in_network_analysis_layer=...,
    summary=...,
    tags=...,
    route_name_prefix=...,
    portal_folder_name=...,
    share_with=...,
    groups=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """ShareAsRouteLayers_na(in_network_analysis_layer, {summary}, {tags}, {route_name_prefix}, {portal_folder_name}, {share_with}, {groups;groups...})

       Shares the results of network analyses as route layer items in a
       portal. A route layer includes all the information for a route such as
       the stops assigned to the route as well as the travel directions.

    INPUTS:
     in_network_analysis_layer (File / Network Analyst Layer):
         The network analysis layer or a .zip file containing the route data
         from which the route layer items will be created. When the input is a
         network analysis layer, it should already be solved.
     summary {String}:
         The summary that will be used by the route layer items. The summary is
         displayed as part of the item information for the route layer item. If
         a value is not specified, default summary text-Route and directions
         for <route name>-is used in which <route name> is replaced with the
         name of the route represented by the route layer.
     tags {String}:
         The tags that will be used to describe and identify the route layer
         items. Individual tags are separated with commas. The route name is
         always included as a tag even when a value is not specified.
     route_name_prefix {String}:
         A qualifier that will be added to the title of every route layer item.
         For example, a route name prefix of Monday morning deliveries can be
         used to group all route layer items created from a route analysis
         performed by deliveries that will be run on Monday morning. If no
         value is specified, the title of the route layer item will be created
         using only the route name.
     portal_folder_name {String}:
         The folder in your personal online workspace where the route layer
         items will be created. If a folder with the specified name does not
         exist, a folder will be created. If a folder with the specified name
         exists, the items will be created in the existing folder. If a value
         is not specified, the route layer items will be created in the root
         folder of your online workspace.
     share_with {String}:
         Specifies who can access the route layer items.

         * EVERYBODY-The route layer items will be public and can be accessed
         by anyone with the URL to the items.

         * MYCONTENT-The route layer items will only be shared with the owner
         of the item (the user connected to the portal when the tool is run).
         As a result, only the item owner can access the route layers. This is
         the default.

         * MYGROUPS-The route layer items will be shared with groups the
         connected user belongs to and its members. The groups are specified
         using the groups parameter.

         * MYORGANIZATION-The route layer items will be shared with all
         authenticated users in your organization.
     groups {String}:
         The list of groups with which the route layer items will be shared.
         This parameter is applicable only when the share_with parameter is set
         to MYGROUPS."""
    ...

@gptooldoc("Solve_na", None)
def Solve(
    in_network_analysis_layer=...,
    ignore_invalids=...,
    terminate_on_solve_error=...,
    simplification_tolerance=...,
    overrides=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """Solve_na(in_network_analysis_layer, {ignore_invalids}, {terminate_on_solve_error}, {simplification_tolerance}, {overrides})

       Solves the network analysis layer problem based on its network
       locations and properties.

    INPUTS:
     in_network_analysis_layer (Network Analyst Layer):
         The network analysis layer on which the analysis will be computed.
     ignore_invalids {Boolean}:
         Specifies whether invalid input locations will be ignored. Typically,
         locations are invalid if they cannot be located on the network. When
         invalid locations are ignored, the solver will skip them and attempt
         to perform the analysis using the remaining locations.

         * SKIP-Invalid input locations will be ignored and only valid
         locations will be used.

         * HALT-All input locations will be used. Any invalid locations will
         cause the solve to fail.
         The default value will match the ignoreInvalidLocations property of
         the designated in_network_analysis_layer value.
     terminate_on_solve_error {Boolean}:
         Specifies whether the tool will stop running and terminate if an error
         is encountered during the solve.

         * TERMINATE-The tool will stop running and terminate when the solver
         encounters an error. This is the default. When you use this option,
         the Result object is not created when the tool terminates due to a
         solver error. Review the geoprocessing messages from the ArcPy object.

         * CONTINUE-The tool will not fail and will continue to run when the
         solver encounters an error. All error messages returned by the solver
         will be converted to warning messages. When you use this option, the
         Result object is always created and the maxSeverity property of the
         Result object is set to 1. Use the getOutput method of the Result
         object with an index value of 1 to determine if the solve was
         successful.
     simplification_tolerance {Linear Unit}:
         The tolerance that determines the degree of simplification for the
         output geometry. If a tolerance is specified, it must be greater than
         zero. You can choose a preferred unit; the default unit is decimal
         degrees.Specifying a simplification tolerance tends to reduce the time
         it
         takes to render routes or service areas. The drawback, however, is
         that simplifying geometry removes vertices, which may lessen the
         spatial accuracy of the output at larger scales.Because a line with
         only two vertices cannot be simplified any
         further, this parameter has no effect on drawing times for single-
         segment output, such as straight-line routes, OD cost matrix lines,
         and location-allocation lines.
     overrides {String}:
         This parameter is for internal use only."""
    ...

@gptooldoc("SolveVehicleRoutingProblem_na", None)
def SolveVehicleRoutingProblem(
    orders=...,
    depots=...,
    routes=...,
    breaks=...,
    time_units=...,
    distance_units=...,
    network_dataset=...,
    output_workspace_location=...,
    output_unassigned_stops_name=...,
    output_stops_name=...,
    output_routes_name=...,
    output_directions_name=...,
    default_date=...,
    uturn_policy=...,
    time_window_factor=...,
    spatially_cluster_routes=...,
    route_zones=...,
    route_renewals=...,
    order_pairs=...,
    excess_transit_factor=...,
    point_barriers=...,
    line_barriers=...,
    polygon_barriers=...,
    time_attribute=...,
    distance_attribute=...,
    use_hierarchy_in_analysis=...,
    restrictions=...,
    attribute_parameter_values=...,
    maximum_snap_tolerance=...,
    exclude_restricted_portions_of_the_network=...,
    feature_locator_where_clause=...,
    populate_route_lines=...,
    route_line_simplification_tolerance=...,
    populate_directions=...,
    directions_language=...,
    directions_style_name=...,
    save_output_layer=...,
    service_capabilities=...,
    ignore_invalid_order_locations=...,
    travel_mode=...,
    ignore_network_location_fields=...,
    time_zone_usage_for_time_fields=...,
    overrides=...,
    save_route_data=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """SolveVehicleRoutingProblem_na(orders, depots, routes, {breaks}, time_units, distance_units, network_dataset, output_workspace_location, output_unassigned_stops_name, output_stops_name, output_routes_name, output_directions_name, {default_date}, {uturn_policy}, {time_window_factor}, {spatially_cluster_routes}, {route_zones}, {route_renewals}, {order_pairs}, {excess_transit_factor}, {point_barriers}, {line_barriers}, {polygon_barriers}, {time_attribute}, {distance_attribute}, {use_hierarchy_in_analysis}, {restrictions;restrictions...}, {attribute_parameter_values}, {maximum_snap_tolerance}, {exclude_restricted_portions_of_the_network}, {feature_locator_where_clause;feature_locator_where_clause...}, {populate_route_lines}, {route_line_simplification_tolerance}, {populate_directions}, {directions_language}, {directions_style_name}, {save_output_layer}, {service_capabilities;service_capabilities...}, {ignore_invalid_order_locations}, {travel_mode}, {ignore_network_location_fields}, {time_zone_usage_for_time_fields}, {overrides}, {save_route_data})

       Creates a vehicle routing problem (VRP) network analysis layer, sets
       the analysis properties, and solves the analysis, which is ideal for
       setting up a VRP web service. A VRP analysis layer finds the best
       routes for a fleet of vehicles.

    INPUTS:
     orders (Feature Set):
         In the case of an exchange visit, an order can have both delivery and
         pickup quantities.
     depots (Feature Set):
         A depot is a location that a vehicle departs from at the beginning of
         the workday and returns to at the end of the workday. Vehicles are
         loaded (for deliveries) or unloaded (for pickups) at depots at the
         start of the route. In some cases, a depot can also act as a renewal
         location, whereby the vehicle can unload or reload and continue
         performing deliveries and pickups. A depot has open and close times,
         as specified by a hard time window. Vehicles can't arrive at a depot
         outside of this time window.The depots feature set has an associated
         attribute table. The fields
         in the attribute table are listed and described below.ObjectID:The
         system-managed ID field.Shape:The geometry field indicating the
         geographic location of the network
         analysis object.Name:The name of the depot. The StartDepotName and
         EndDepotName fields of
         the routes record set reference the names you specify here. It is also
         referenced by the route renewals record set, when used.Depot names are
         not case sensitive and must be nonempty and
         unique.TimeWindowStart1:The beginning time of the first time window
         for the network location.
         This field can contain a null value; a null value indicates no
         beginning time.

         * Time window fields can contain a time-only value or a date and time
         value. If a time field has a time-only value (for example, 8:00 a.m.),
         the date is assumed to be the date specified by the Default Date
         parameter of the analysis layer. Using date and time values (for
         example, 7/11/2010 8:00 a.m.) allows you to set time windows that span
         multiple days.

         * The default date is ignored when any time window field includes a
         date
         with the time. To avoid an error in this situation, format all time
         windows in Depots, Routes, Orders, and Breaks to also include the date
         with the time.

         * If you're using traffic data, the time-of-day fields for the
         network
         location always reference the same time zone as the edge on which the
         network location is located.
         TimeWindowEnd1:The ending time of the first time window for the
         network location.
         This field can contain a null value; a null value indicates no ending
         time.TimeWindowStart2:The beginning time of the second time window for
         the network location.
         This field can contain a null value; a null value indicates that there
         is no second time window.If the first time window is null as specified
         by the TimeWindowStart1
         and TimeWindowEnd1 fields, the second time window must also be null.If
         both time windows are nonnull, they can't overlap. Also, the second
         time window must occur after the first.TimeWindowEnd2:The ending time
         of the second time window for the network location.
         This field can contain a null value.When TimeWindowStart2 and
         TimeWindowEnd2 are both null, there is no
         second time window.When TimeWindowStart2 is not null but
         TimeWindowEnd2 is null, there is
         a second time window that has a starting time but no ending time. This
         is valid.CurbApproach:        The CurbApproach property specifies the
         direction a vehicle
         may arrive at and depart from the network location. There are four
         choices (their coded values are shown in parentheses):

         * Either side of vehicle (0)-The vehicle can approach and depart the
         network location in either direction. U-turns are allowed. You should
         choose this setting if your vehicle can make a U-turn at the stop or
         if it can pull into a driveway or parking lot and turn around.

         * Right side of vehicle (1)-When the vehicle approaches and departs
         the network location, the curb must be on the right side of the
         vehicle. A U-turn is prohibited.

         * Left side of vehicle (2)-When the vehicle approaches and departs the
         network location, the curb must be on the left side of the vehicle. A
         U-turn is prohibited.

         * No U-Turn (3)-When the vehicle approaches the network location, the
         curb can be on either side of the vehicle; however, the vehicle must
         depart without turning around.
         Bearing:The direction in which a point is moving. The units are
         degrees and
         are measured in a clockwise fashion from true north. This field is
         used in conjunction with the BearingTol field.Bearing data is usually
         sent automatically from a mobile device that
         is equipped with a GPS receiver. Try to include bearing data if you
         are loading an order that is moving, such as a pedestrian or a
         vehicle.Using this field tends to prevent adding locations to the
         wrong edges,
         which can occur when a vehicle is near an intersection or an overpass,
         for example. Bearing also helps Network Analyst determine which side
         of the street the point is on.For more information, see Bearing and
         BearingTol.BearingTol:The bearing tolerance value creates a range of
         acceptable bearing
         values when locating moving points on an edge using the Bearing field.
         If the value from the Bearing field is within the range of acceptable
         values that are generated from the bearing tolerance on an edge, the
         point can be added as a network location there; otherwise, the closest
         point on the next-nearest edge is evaluated.The units are in degrees,
         and the default value is 30. Values must be
         greater than zero and less than 180.A value of 30 means that when
         Network Analyst attempts to add a
         network location on an edge, a range of acceptable bearing values is
         generated 15º to either side of the edge (left and right) and in both
         digitized directions of the edge.For more information, see Bearing and
         BearingTol.NavLatency:This field is only used in the solve process if
         Bearing and BearingTol
         also have values; however, entering a NavLatency value is optional,
         even when values are present in Bearing and BearingTol. NavLatency
         indicates how much time is expected to elapse from the moment GPS
         information is sent from a moving vehicle to a server and the moment
         the processed route is received by the vehicle's navigation device.
         The time units of NavLatency are the same as the units of the cost
         attribute specified by the Time Attribute parameter.
     routes (Record Set):
         The routes that are available for the given vehicle routing problem. A
         route specifies vehicle and driver characteristics; after solving, it
         also represents the path between depots and orders.A route can have
         start and end depot service times, a fixed or
         flexible starting time, time-based operating costs, distance-based
         operating costs, multiple capacities, various constraints on a
         driver's workday, and so on.The routes record set has several
         attributes. The fields in the
         attribute table are listed and described below.Name:The name of the
         route. The name must be unique.Network Analyst generates a unique name
         at solve time if the field
         value is null. Therefore, entering a value is optional in most cases.
         However, you must enter a name if your analysis includes breaks, route
         renewals, route zones, or orders that are preassigned to a route,
         because the route name is used as a foreign key in these cases. Note
         that route names are not case sensitive.StartDepotName:The name of the
         starting depot for the route. This field is a foreign
         key to the Name field in Depots.If the StartDepotName value is null,
         the route will begin from the
         first order assigned. Omitting the start depot is useful when the
         vehicle's starting location is unknown or irrelevant to your problem.
         However, when StartDepotName is null, EndDepotName cannot also be
         null.Virtual start depots are not allowed if orders or depots are in
         multiple time zones.If the route is making deliveries and
         StartDepotName is null, it is
         assumed the cargo is loaded on the vehicle at a virtual depot before
         the route begins. For a route that has no renewal visits, its delivery
         orders (those with nonzero DeliveryQuantities values in the Orders
         class) are loaded at the start depot or virtual depot. For a route
         that has renewal visits, only the delivery orders before the first
         renewal visit are loaded at the start depot or virtual
         depot.EndDepotName:The name of the ending depot for the route. This
         field is a foreign
         key to the Name field in the Depots
         parameter.StartDepotServiceTime:The service time at the starting
         depot. This can be used to model the
         time spent for loading the vehicle. This field can contain a null
         value; a null value indicates zero service time.The unit for this
         field value is specified by the Time Field Units
         parameter (time_units in Python).The service times at the start and
         end depots are fixed values (given
         by the StartDepotServiceTime and EndDepotServiceTime field values) and
         do not take into account the actual load for a route. For example, the
         time taken to load a vehicle at the starting depot may depend on the
         size of the orders. As such, the depot service times could be given
         values corresponding to a full truckload or an average truckload, or
         you could make your own time estimate.EndDepotServiceTime:The service
         time at the ending depot. This can be used to model the
         time spent for unloading the vehicle. This field can contain a null
         value; a null value indicates zero service time.The unit for this
         field value is specified by the Time Field Units
         parameter (time_units in Python).The service times at the start and
         end depots are fixed values (given
         by the StartDepotServiceTime and EndDepotServiceTime field values) and
         do not take into account the actual load for a route. For example, the
         time taken to load a vehicle at the starting depot may depend on the
         size of the orders. As such, the depot service times could be given
         values corresponding to a full truckload or an average truckload, or
         you could make your own time estimate.EarliestStartTime:The earliest
         allowable starting time for the route. This is used by
         the solver in conjunction with the time window of the starting depot
         for determining feasible route start times.This field can't contain
         null values and has a default time-only value
         of 8:00 a.m.; the default value is interpreted as 8:00 a.m. on the
         date given by the Default Date parameter (default_date in Python).The
         default date is ignored when any time window field includes a date
         with the time. To avoid an error in this situation, format all time
         windows in Depots, Routes, Orders, and Breaks to also include the date
         with the time.When using network datasets with traffic data across
         multiple time
         zones, the time zone for EarliestStartTime is the same as the time
         zone of the edge or junction on which the starting depot is
         located.LatestStartTime:The latest allowable starting time for the
         route. This field can't
         contain null values and has a default time-only value of 10:00 a.m;
         the default value is interpreted as 10:00 a.m. on the date given by
         the Default Date property of the analysis layer.When using network
         datasets with traffic data across multiple time
         zones, the time zone for LatestStartTime is the same as the time zone
         of the edge or junction on which the starting depot is
         located.ArriveDepartDelayThis field stores the amount of travel time
         needed to accelerate the
         vehicle to normal travel speeds, decelerate it to a stop, and move it
         off and on the network (for example, in and out of parking). By
         including an ArriveDepartDelay value, the VRP solver is deterred from
         sending many routes to service physically coincident orders.The cost
         for this property is incurred between visits to noncoincident
         orders, depots, and route renewals. For example, when a route starts
         from a depot and visits the first order, the total arrive/depart delay
         is added to the travel time. The same is true when traveling from the
         first order to the second order. If the second and third orders are
         coincident, the ArriveDepartDelay value is not added between them
         since the vehicle doesn't need to move. If the route travels to a
         route renewal, the value is added to the travel time again.Although a
         vehicle needs to slow down and stop for a break and
         accelerate afterward, the VRP solver cannot add the ArriveDepartDelay
         value for breaks. This means that if a route leaves an order, stops
         for a break, and continues to the next order, the arrive/depart delay
         is added only once, not twice.To illustrate, assume there are five
         coincident orders in a high-rise
         building, and they are serviced by three different routes. This means
         three arrive/depart delays would be incurred; that is, three drivers
         would need to separately find parking places and enter the same
         building. However, if the orders could be serviced by just one route
         instead, only one driver would need to park and enter the
         building-only one arrive/depart delay would be incurred. Since the VRP
         solver tries to minimize cost, it will try to limit the arrive/depart
         delays and thus choose the single-route option. (Note that multiple
         routes may need to be sent when other constraints-such as specialties,
         time windows, or capacities-require it.)The unit for this field value
         is specified by the Time Field Units
         parameter (time_units in Python).Capacities:The maximum capacity of
         the vehicle. You can specify capacity in any
         dimension, such as weight, volume, or quantity. You can even specify
         multiple dimensions, for example, weight and volume.Enter capacities
         without indicating units. For example, assume your
         vehicle can carry a maximum of 40,000 pounds; you would enter 40000.
         You need to remember for future reference that the value is in
         pounds.If you are tracking multiple dimensions, separate the numeric
         values
         with a space. For instance, if you are recording both weight and
         volume and your vehicle can carry a maximum weight of 40,000 pounds
         and a maximum volume of 2,000 cubic feet, Capacities should be entered
         as 40000 2000. Again, you need to remember the units. You also need to
         remember the sequence the values and their corresponding units are
         entered (pounds followed by cubic feet in this case).Remembering the
         units and the unit sequence is important for a couple
         of reasons: one, so you can reinterpret the information later; two, so
         you can properly enter values for the DeliveryQuantities and
         PickupQuantities fields for Orders. To elaborate on the second point,
         note that the VRP solver simultaneously refers to Capacities,
         DeliveryQuantities, and PickupQuantities to make sure that a route
         doesn't become overloaded. Since units can't be entered in the field,
         Network Analyst can't make unit conversions, so you need to enter the
         values for the three fields using the same units and the same unit
         sequence to ensure that the values are correctly interpreted. If you
         combine units or change the sequence in any of the three fields, you
         will get unwanted results without receiving a warning messages. Thus,
         it is a good idea to set up a unit and unit-sequence standard
         beforehand and continually refer to it whenever entering values for
         these three fields.An empty string or null value is equivalent to all
         values being zero.
         Capacity values can't be negative.If the Capacities string has an
         insufficient number of values in
         relation to the DeliveryQuantities or PickupQuantities field for
         orders, the remaining values are treated as zero.The VRP solver only
         performs a simple Boolean test to determine
         whether capacities are exceeded. If a route's capacity value is
         greater than or equal to the total quantity being carried, the VRP
         solver will assume the cargo fits in the vehicle. This could be
         incorrect, depending on the actual shape of the cargo and the vehicle.
         For example, the VRP solver allows you to fit a 1,000-cubic-foot
         sphere into a 1,000-cubic-foot truck that is 8 feet wide. In reality,
         however, since the sphere is 12.6 feet in diameter, it won't fit in
         the 8-foot-wide truck.FixedCost:A fixed monetary cost that is incurred
         only if the route is used in a
         solution (that is, it has orders assigned to it). This field can
         contain null values; a null value indicates zero fixed cost. This cost
         is part of the total route operating cost.CostPerUnitTime:The monetary
         cost incurred-per unit of work time-for the total route
         duration, including travel times as well as service times and wait
         times at orders, depots, and breaks. This field can't contain a null
         value and has a default value of 1.0.The unit for this field value is
         specified by the Time Field Units
         parameter (time_units in Python).CostPerUnitDistance:The monetary cost
         incurred-per unit of distance traveled-for the route
         length (total travel distance). This field can contain null values; a
         null value indicates zero cost.The unit for this field value is
         specified by the Distance Field Units
         parameter (distance_units for Python).OvertimeStartTime:The duration
         of regular work time before overtime computation begins.
         This field can contain null values; a null value indicates that
         overtime does not apply.The unit for this field value is specified by
         the Time Field Units
         parameter (time_units in Python).For example, if the driver is to be
         paid overtime when the total route
         duration extends beyond eight hours, OvertimeStartTime is specified as
         480 (8 hours * 60 minutes/hour), given the Time Field Units parameter
         is set to Minutes.CostPerUnitOvertime:The monetary cost incurred per
         time unit of overtime work. This can
         only contain a null value if OvertimeStartTime is also null. Otherwise
         it must be a positive value greater than the
         CostPerUnitTime.MaxOrderCount:The maximum allowable number of orders
         on the route. This field can't
         contain null values and has a default value of 30.MaxTotalTime:The
         maximum allowable route duration. The route duration includes
         travel times as well as service and wait times at orders, depots, and
         breaks. This field can contain null values; a null value indicates
         that there is no constraint on the route duration.The unit for this
         field value is specified by the Time Field Units
         parameter (time_units in Python).MaxTotalTravelTime:The maximum
         allowable travel time for the route. The travel time
         includes only the time spent driving on the network and does not
         include service or wait times.This field can contain null values; a
         null value indicates there is no
         constraint on the maximum allowable travel time. This field value
         can't be larger than the MaxTotalTime field value.The unit for this
         field value is specified by the Time Field Units
         parameter (time_units in Python).MaxTotalDistance:The maximum
         allowable travel distance for the route.The unit for this field value
         is specified by the Distance Field Units
         parameter (distance_units for Python).This field can contain null
         values; a null value indicates that there
         is no constraint on the maximum allowable travel
         distance.SpecialtyNames:A space-separated string containing the names
         of the specialties
         supported by the route. A null value indicates that the route does not
         support any specialties.This field is a foreign key to the
         SpecialtyNames field in the Orders
         parameter.To illustrate what specialties are and how they work, assume
         a lawn
         care and tree trimming company has a portion of its orders that
         requires a bucket truck to trim tall trees. The company would enter
         BucketTruck in the SpecialtyNames field for these orders to indicate
         their special need. SpecialtyNames would be left as null for the other
         orders. Similarly, the company would also enter BucketTruck in the
         SpecialtyNames field of routes that are driven by trucks with
         hydraulic booms. It would leave the field null for the other routes.
         At solve time, the VRP solver assigns orders without special needs to
         any route, but it only assigns orders that need bucket trucks to
         routes that have them.AssignmentRule:        This specifies whether or
         not the route can be used when
         solving the problem. This field is constrained by a domain of values,
         and the possible values are the following:

         * Include-The route is included in the solve operation. This is the
         default value.

         * Exclude-The route is excluded from the solve operation.
     breaks {Record Set}:
         The rest periods, or breaks, for the routes in a given vehicle routing
         problem. A break is associated with exactly one route, and it can be
         taken after completing an order, while en route to an order, or prior
         to servicing an order. It has a start time and a duration, for which
         the driver may or may not be paid. There are three options for
         establishing when a break begins: using a time window, a maximum
         travel time, or a maximum work time.The breaks record set has
         associated attributes. The fields in the
         attribute table are listed and described below.ObjectID:The system-
         managed ID field.RouteName:The name of the route that the break
         applies to. Although a break is
         assigned to exactly one route, many breaks can be assigned to the same
         route.This field is a foreign key to the Name field in the Routes
         class and
         can't have a null value.Precedence:Precedence values sequence the
         breaks of a given route. Breaks with a
         precedence value of 1 occur before those with a value of 2, and so
         on.All breaks must have a precedence value, regardless of whether they
         are time-window, maximum-travel-time, or maximum-work-time
         breaks.ServiceTimeThe duration of the break. This field can't contain
         null values and
         has a default value of 60.The unit for this field value is specified
         by the Time Field Units
         parameter (time_units in Python).TimeWindowStart:The starting time of
         the break's time window. Half-open time windows
         are invalid for Breaks.If this field has a value,
         MaxTravelTimeBetweenBreaks and
         MaxCumulWorkTime must be null; moreover, all other breaks in the
         analysis layer must have null values for MaxTravelTimeBetweenBreaks
         and MaxCumulWorkTime.An error will occur at solve time if a route has
         multiple breaks with
         overlapping time windows.The time window fields in breaks can contain
         a time-only value or a
         date and time value in a date field and cannot be integers
         representing milliseconds since Epoch. The time zone for time window
         fields is specified using the time_zone_usage_for_time_fields
         parameter. If a time field, such as TimeWindowStart, has a time-only
         value (for example, 12:00 p.m.), the date is assumed to be the date
         specified by the Default Date parameter (default_date in Python).
         Using date and time values (for example, 7/11/2012 12:00 p.m.) allows
         you to specify time windows that span two or more days. This is
         beneficial when a break should be taken sometime before and after
         midnight.The default date is ignored when any time window field
         includes a date
         with the time. To avoid an error in this situation, format all time
         windows in Depots, Routes, Orders, and Breaks to also include the date
         with the time.TimeWindowEnd:The ending time of the break's time
         window. Half-open time windows are
         invalid for Breaks.If this field has a value,
         MaxTravelTimeBetweenBreaks and
         MaxCumulWorkTime must be null; moreover, all other breaks in the
         analysis layer must have null values for MaxTravelTimeBetweenBreaks
         and MaxCumulWorkTime.MaxViolationTime:This field specifies the maximum
         allowable violation time for a time-
         window break. A time window is considered violated if the arrival time
         falls outside the time range.A zero value indicates the time window
         cannot be violated; that is,
         the time window is hard. A nonzero value specifies the maximum amount
         of lateness; for example, the break can begin up to 30 minutes beyond
         the end of its time window, but the lateness is penalized pursuant to
         the Time Window Violation Importance parameter (time_window_factor in
         Python).This property can be null; a null value with TimeWindowStart
         and
         TimeWindowEnd values indicates that there is no limit on the allowable
         violation time. If MaxTravelTimeBetweenBreaks or MaxCumulWorkTime has
         a value, MaxViolationTime must be null.The unit for this field value
         is specified by the Time Field Units
         parameter (time_units in Python).MaxTravelTimeBetweenBreaks:The
         maximum amount of travel time that can be accumulated before the
         break is taken. The travel time is accumulated either from the end of
         the previous break or, if a break has not yet been taken, from the
         start of the route.If this is the route's final break,
         MaxTravelTimeBetweenBreaks also
         indicates the maximum travel time that can be accumulated from the
         final break to the end depot.This field is designed to limit how long
         a person can drive until a
         break is required. For instance, if the Time Field Units parameter
         (time_units in Python) of the analysis is set to Minutes, and
         MaxTravelTimeBetweenBreaks has a value of 120, the driver will get a
         break after two hours of driving. To assign a second break after two
         more hours of driving, the second break's MaxTravelTimeBetweenBreaks
         field value should be 120.If this field has a value, TimeWindowStart,
         TimeWindowEnd,
         MaxViolationTime, and MaxCumulWorkTime must be null for an analysis to
         solve successfully.The unit for this field value is specified by the
         Time Field Units
         parameter (time_units in Python).MaxCumulWorkTime:The maximum amount
         of work time that can be accumulated before the
         break is taken. Work time is always accumulated from the beginning of
         the route.Work time is the sum of travel time and service times at
         orders,
         depots, and breaks. Note, however, that this excludes wait time, which
         is the time a route (or driver) spends waiting at an order or depot
         for a time window to begin.This field is designed to limit how long a
         person can work until a
         break is required. For instance, if the Time Field Units parameter
         (time_units in Python) is set to Minutes, MaxCumulWorkTime has a value
         of 120, and ServiceTime has a value of 15, the driver will get a
         15-minute break after two hours of work.Continuing with the last
         example, assume a second break is needed
         after three more hours of work. To specify this break, you would enter
         315 (five hours and 15 minutes) as the second break's MaxCumulWorkTime
         value. This number includes the MaxCumulWorkTime and ServiceTime
         values of the preceding break, along with the three additional hours
         of work time before granting the second break. To avoid taking
         maximum-work-time breaks prematurely, remember that they accumulate
         work time from the beginning of the route and that work time includes
         the service time at previously visited depots, orders, and breaks.If
         this field has a value, TimeWindowStart, TimeWindowEnd,
         MaxViolationTime, and MaxTravelTimeBetweenBreaks must be null for an
         analysis to solve successfully.The unit for this field value is
         specified by the Time Field Units
         parameter (time_units in Python).IsPaid:A Boolean value indicating
         whether the break is paid or unpaid. A True
         value indicates that the time spent at the break is included in"""
    ...

@gptooldoc("UpdateAnalysisLayerAttributeParameter_na", None)
def UpdateAnalysisLayerAttributeParameter(
    in_network_analysis_layer=...,
    parameterized_attribute=...,
    attribute_parameter_name=...,
    attribute_parameter_value=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """UpdateAnalysisLayerAttributeParameter_na(in_network_analysis_layer, parameterized_attribute, attribute_parameter_name, {attribute_parameter_value})

       Updates the network attribute parameter value for a network analysis
       layer. The tool should be used to update the value of an attribute
       parameter for a network analysis layer prior to solving with the Solve
       tool. This ensures that the solve operation uses the specified value
       of the attribute parameter to produce appropriate results.

    INPUTS:
     in_network_analysis_layer (Network Analyst Layer):
         Network analysis layer for which the attribute parameter value will be
         updated.
     parameterized_attribute (String):
         The network attribute whose attribute parameter will be updated.
     attribute_parameter_name (String):
         The parameter of the network attribute that will be updated. The
         parameters of type Object cannot be updated using the tool.
     attribute_parameter_value {String}:
         The value that will be set for the attribute parameter. It can be a
         string, number, date, or Boolean (True, False). If the value is not
         specified, then the attribute parameter value is set to Null.If the
         attribute parameter has a restriction usage type, the value can
         be specified as a string keyword or a numeric value. The string
         keyword or the numeric value determines whether the restriction
         attribute prohibits, avoids, or prefers the network elements it is
         associated with. Furthermore, the degree to which network elements are
         avoided or preferred can be defined by choosing HIGH, MEDIUM, or LOW
         keywords. The following keywords are supported:

         * PROHIBITED

         * AVOID_HIGH

         * AVOID_MEDIUM

         * AVOID_LOW

         * PREFER_LOW

         * PREFER_MEDIUM

         * PREFER_HIGH
         Numeric values that are greater than one cause restricted elements to
         be avoided; the larger the number, the more the elements are avoided.
         Numeric values between zero and one cause restricted elements to be
         preferred; the smaller the number, the more restricted elements are
         preferred. Negative numbers prohibit restricted elements.If the
         parameter value holds an array, separate the items in the array
         with the localized separator character. For example, in the U.S., you
         would most likely use the comma character to separate the items. So
         representing an array of three numbers might look like the following:
         "5,10,15"."""
    ...

@gptooldoc("BuildNetwork_na", None)
def BuildNetwork(
    in_network_dataset=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """BuildNetwork_na(in_network_dataset)

       Reconstructs the network connectivity and attribute information of a
       network dataset. The network dataset must be rebuilt after edits are
       made to the attributes or the features of a participating source
       feature class. After the source features are edited, the tool
       establishes the network connectivity only in the areas that have been
       edited to speed up the build process; however, when the network
       attributes are edited, the entire extent of the network dataset is
       rebuilt. This may be a slow operation on a large network dataset.

    INPUTS:
     in_network_dataset (Network Dataset Layer):
         The network dataset to be built."""
    ...

@gptooldoc("CreateNetworkDataset_na", None)
def CreateNetworkDataset(
    feature_dataset=...,
    out_name=...,
    source_feature_class_names=...,
    elevation_model=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """CreateNetworkDataset_na(feature_dataset, out_name, source_feature_class_names;source_feature_class_names..., elevation_model)

       Creates a network dataset in an existing feature dataset. The network
       dataset can be used to perform network analysis on the data in the
       feature dataset.

    INPUTS:
     feature_dataset (Feature Dataset):
         The feature dataset where the network dataset will be created. The
         feature dataset should contain the source feature classes that will
         participate in the network dataset.If the feature dataset is in an
         enterprise geodatabase, the feature
         dataset and all source feature classes cannot be versioned.
     out_name (String):
         The name of the network dataset to be created. The Target Feature
         Dataset and its parent geodatabase must not already contain a network
         dataset with this name.
     source_feature_class_names (String):
         The names of the feature classes to be included in the network dataset
         as network source features. Specify this parameter as a list of
         strings.You must choose at least one line feature class that is not a
         turn
         feature class. This line feature class will act as an edge source in
         the network dataset. You can optionally choose point feature classes
         to act as junction sources in the network dataset and turn feature
         classes to act as turn sources.All source feature classes must reside
         in the Target Feature Dataset
         and must not already participate in a geometric network, a utility
         network, or another network dataset.
     elevation_model (String):
         Specifies the model to be used to control vertical connectivity in the
         network dataset.

         * ELEVATION_FIELDS-Coincident endpoints with the same elevation field
         values are considered connected in the network dataset. This is the
         default.

         * Z_COORDINATES-The z-coordinate values in the line feature geometry
         determine vertical connectivity. Coincident points are considered
         connected only if they have matching z-coordinate values.

         * NO_ELEVATION-Network dataset connectivity is determined only by
         horizontal coincidence."""
    ...

@gptooldoc("CreateNetworkDatasetFromTemplate_na", None)
def CreateNetworkDatasetFromTemplate(
    network_dataset_template=..., output_feature_dataset=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """CreateNetworkDatasetFromTemplate_na(network_dataset_template, output_feature_dataset)

       Creates a new network dataset with the schema contained in the input
       template file (.xml). All the feature classes and input tables
       required for creating the network dataset must already exist before
       this tool is executed.

    INPUTS:
     network_dataset_template (File):
         The template file (.xml) created by the Create Template From Network
         Dataset tool containing the schema of the output network dataset to be
         created.
     output_feature_dataset (Feature Dataset):
         The feature dataset containing the feature classes that will take part
         in the network dataset being created. The network will be created in
         this dataset using the name specified in the network dataset template."""
    ...

@gptooldoc("CreateTemplateFromNetworkDataset_na", None)
def CreateTemplateFromNetworkDataset(
    network_dataset=..., output_network_dataset_template=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """CreateTemplateFromNetworkDataset_na(network_dataset, output_network_dataset_template)

       Creates a file containing the schema of an existing network dataset.
       This template file can then be used to create a new network dataset
       with the same schema.

    INPUTS:
     network_dataset (Network Dataset Layer):
         The network dataset whose schema will be written to the output
         template file.

    OUTPUTS:
     output_network_dataset_template (File):
         The output file (.xml) that will contain the schema of the input
         network dataset."""
    ...

@gptooldoc("DissolveNetwork_na", None)
def DissolveNetwork(
    in_network_dataset=..., out_workspace_location=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """DissolveNetwork_na(in_network_dataset, out_workspace_location)

       Creates a network dataset that minimizes the number of line features
       required to correctly model the input network dataset. The more
       efficient output network dataset reduces the time required to solve
       analyses, draw results, and generate driving directions. This tool
       outputs a new network dataset and source feature classes; the input
       network dataset and its source features remain unchanged.

    INPUTS:
     in_network_dataset (Network Dataset Layer):
         The network dataset to be dissolved. The input network dataset
         must be a file or personal
         geodatabase network dataset with exactly one edge source. Any number
         of junction sources and turn sources is allowed. The edge source must
         have:

         * End point connectivity policy

         * An elevation policy of either None or Elevation Fields
         The input network dataset must be built before it can be used in this
         tool.
     out_workspace_location (Workspace):
         The geodatabase workspace in which to create the dissolved network
         dataset. The workspace must be an ArcGIS 10 geodatabase or later, and
         it must be a different geodatabase than the one where the input
         network dataset resides."""
    ...

@gptooldoc("MakeNetworkDatasetLayer_na", None)
def MakeNetworkDatasetLayer(
    in_network_dataset=..., output_layer=..., draw_elements=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """MakeNetworkDatasetLayer_na(in_network_dataset, output_layer, {draw_elements;draw_elements...})

       Creates a network dataset layer from a network dataset.

    INPUTS:
     in_network_dataset (Network Dataset Layer):
         The network dataset from which to make the new layer.
     draw_elements {String}:
         This parameter is not yet supported in ArcGIS Pro.

    OUTPUTS:
     output_layer (Network Dataset Layer):
         The name of the network dataset layer to be created.The layer can be
         used as an input to any geoprocessing tool that
         accepts a network dataset layer as input.The output layer created is
         temporary and will not persist after the
         session ends. To save the layer to the disk, run the Save To Layer
         File tool."""
    ...

@gptooldoc("UpgradeNetwork_na", None)
def UpgradeNetwork(
    in_network_dataset=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """UpgradeNetwork_na(in_network_dataset)

       Upgrades the schema of the network dataset. Upgrading a network
       dataset allows it to use new functionality available in the current
       software release. This is a deprecated tool. This functionality has
       been replaced by the Upgrade Dataset tool. Upgrade Dataset can upgrade
       network datasets as well as other types of datasets, such as parcel
       fabrics, to the current ArcGIS release.

    INPUTS:
     in_network_dataset (Network Dataset Layer):
         The network dataset that will be upgraded. The network dataset must be
         a geodatabase-based network dataset."""
    ...

@gptooldoc("CreateTurnFeatureClass_na", None)
def CreateTurnFeatureClass(
    out_location=...,
    out_feature_class_name=...,
    maximum_edges=...,
    in_network_dataset=...,
    in_template_feature_class=...,
    spatial_reference=...,
    config_keyword=...,
    spatial_grid_1=...,
    spatial_grid_2=...,
    spatial_grid_3=...,
    has_z=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """CreateTurnFeatureClass_na(out_location, out_feature_class_name, {maximum_edges}, {in_network_dataset}, {in_template_feature_class}, {spatial_reference}, {config_keyword}, {spatial_grid_1}, {spatial_grid_2}, {spatial_grid_3}, {has_z})

       Creates a new turn feature class to store turn features that model
       turning movements in a network dataset.

    INPUTS:
     out_location (Workspace / Feature Dataset):
         The file, workgroup, or enterprise geodatabase, or the folder in which
         the output turn feature class will be created. The workspace must
         already exist.
     out_feature_class_name (String):
         The name of the turn feature class to be created.
     maximum_edges {Long}:
         The maximum number of edges that turns in the new turn feature class
         can model. The default value is 5. The maximum value is 50.
     in_network_dataset {Network Dataset Layer}:
         The network dataset in which the turn feature class will participate.
         The resulting turn feature class will be added as a turn source to the
         network dataset. If no network dataset is specified, the turn feature
         class will be created as not participating in a network dataset.
     in_template_feature_class {Feature Layer}:
         The feature class used as a template to define the attribute schema of
         the new turn feature class.If the template feature class has the
         following fields, they are not
         created on the output turn feature class; NODE_, NODE#, JUNCTION,
         F_EDGE, T_EDGE, F-EDGE, T-EDGE, ARC1_, ARC2_, ARC1#, ARC2#, ARC1-ID,
         ARC2-ID, AZIMUTH, ANGLE.
     spatial_reference {Spatial Reference}:
         The spatial reference to be applied to the output turn feature class.
         This parameter is ignored if the output location is a geodatabase
         feature dataset, as the output turn feature class will inherit the
         spatial reference of the feature dataset.If you want to import the
         spatial reference from an existing feature
         class, specify its path as the parameter value.
     config_keyword {String}:
         Specifies the configuration keyword that determines the storage
         parameters of the new turn feature class. This parameter is used only
         if the output location is an workgroup or enterprise geodatabase
     spatial_grid_1 {Double}:
         This parameter has been deprecated in ArcGIS Pro. Any value you enter
         is ignored.
     spatial_grid_2 {Double}:
         This parameter has been deprecated in ArcGIS Pro. Any value you enter
         is ignored.
     spatial_grid_3 {Double}:
         This parameter has been deprecated in ArcGIS Pro. Any value you enter
         is ignored.
     has_z {Boolean}:
         * ENABLED-The coordinates in the new turn feature class will have
         elevation (Z) values. This value should be used if the input network
         dataset is specified and it supports connectivity based on z
         coordinate values of the network sources.

         * DISABLED-The coordinates in the new turn feature class will not have
         elevation (Z) values."""
    ...

@gptooldoc("IncreaseMaximumEdges_na", None)
def IncreaseMaximumEdges(
    in_turn_features=..., maximum_edges=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """IncreaseMaximumEdges_na(in_turn_features, maximum_edges)

       Increases the maximum number of edges per turn in a turn feature
       class.

    INPUTS:
     in_turn_features (Feature Layer):
         The turn feature class that is having its maximum number of edges
         raised.
     maximum_edges (Long):
         The new maximum number of edges in the input turn feature class. The
         value must be at least one higher than the existing maximum number of
         edges and cannot be greater than 50."""
    ...

@gptooldoc("PopulateAlternateIDFields_na", None)
def PopulateAlternateIDFields(
    in_network_dataset=..., alternate_ID_field_name=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """PopulateAlternateIDFields_na(in_network_dataset, alternate_ID_field_name)

       Creates and populates additional fields on the turn feature classes
       that reference the edges by alternate IDs. The alternate IDs allow for
       another set of IDs that can help maintain the integrity of the turn
       features in case the source edges are being edited.

    INPUTS:
     in_network_dataset (Network Dataset Layer):
         The network dataset whose turn feature classes are to receive
         alternate ID fields. The fields will be created on all of the turn
         feature classes added as a turn source to the network dataset.
     alternate_ID_field_name (String):
         The name of the alternate ID field on the edge feature sources of the
         network dataset. All edge feature sources referenced by turns must
         have the same name for the alternate ID field."""
    ...

@gptooldoc("TurnTableToTurnFeatureClass_na", None)
def TurnTableToTurnFeatureClass(
    in_turn_table=...,
    reference_line_features=...,
    out_feature_class_name=...,
    reference_nodes_table=...,
    maximum_edges=...,
    config_keyword=...,
    spatial_grid_1=...,
    spatial_grid_2=...,
    spatial_grid_3=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """TurnTableToTurnFeatureClass_na(in_turn_table, reference_line_features, out_feature_class_name, {reference_nodes_table}, {maximum_edges}, {config_keyword}, {spatial_grid_1}, {spatial_grid_2}, {spatial_grid_3})

       Converts an ArcView turn table or ArcInfo Workstation coverage turn
       table to an ArcGIS turn feature class.

    INPUTS:
     in_turn_table (Table View):
         The .dbf file or INFO turn table from which the new turn feature class
         will be created.INFO tables do not support mixed case path names on
         Linux and Solaris.
     reference_line_features (Feature Class):
         The line feature class to which the input turn table refers. The
         feature class must be a source in a network dataset.
     out_feature_class_name (String):
         The name of the new turn feature class to create.
     reference_nodes_table {dBASE Table}:
         The nodes.dbf table in the .nws folder containing the original ArcView
         GIS network in which the input turn table participated.This parameter
         is ignored if the input turn table is an INFO table.If the input turn
         table is a .dbf table and this parameter is omitted,
         then U-turns and turns that traverse between edges connected to each
         other at both ends will not be created in the output turn feature
         class.Errors will be reported in an error file written to the
         directory
         defined by the TEMP system variable. The full path name to the error
         file is reported as a warning message.
     maximum_edges {Long}:
         The maximum number of edges per turn in the new turn feature class.
         The default value is 5. The maximum value is 50.
     config_keyword {String}:
         Specifies the configuration keyword that determines the storage
         parameters of the output turn feature class. This parameter is used
         only if the output turn feature class is created in a workgroup or
         enterprise geodatabase.
     spatial_grid_1 {Double}:
         This parameter has been deprecated in ArcGIS Pro. Any value you enter
         is ignored.
     spatial_grid_2 {Double}:
         This parameter has been deprecated in ArcGIS Pro. Any value you enter
         is ignored.
     spatial_grid_3 {Double}:
         This parameter has been deprecated in ArcGIS Pro. Any value you enter
         is ignored."""
    ...

@gptooldoc("UpdateByAlternateIDFields_na", None)
def UpdateByAlternateIDFields(
    in_network_dataset=..., alternate_ID_field_name=...
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """UpdateByAlternateIDFields_na(in_network_dataset, alternate_ID_field_name)

       Updates all the edge references in turn feature classes using an
       alternate ID field. This tool should be used after making edits to the
       input line features that are referenced by the turn features to
       synchronize the turn features based on the alternate ID fields.

    INPUTS:
     in_network_dataset (Network Dataset Layer):
         The network dataset whose turn feature classes are being updated by
         their alternate ID fields.
     alternate_ID_field_name (String):
         The name of the alternate ID field on the edge feature sources of the
         network dataset. All edge feature sources referenced by turns must
         have the same name for the alternate ID field."""
    ...

@gptooldoc("UpdateByGeometry_na", None)
def UpdateByGeometry(
    in_turn_features=...,
):  # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """UpdateByGeometry_na(in_turn_features)

       Updates all the edge references in the turn feature class using the
       geometry of the turn features. This tool is useful when the IDs listed
       for the turn can no longer find the edges participating in the turn
       due to edits to the underlying edges.

    INPUTS:
     in_turn_features (Feature Layer):
         The turn feature class to be updated."""
    ...
