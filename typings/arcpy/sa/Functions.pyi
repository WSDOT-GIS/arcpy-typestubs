"""
This type stub file was generated by pyright.
"""

__all__ = [
    "Abs",
    "ACos",
    "ACosH",
    "AddSurfaceInformation",
    "Aggregate",
    "AggregateMultidimensionalRaster",
    "AreaSolarRadiation",
    "ASin",
    "ASinH",
    "Aspect",
    "ATan",
    "ATan2",
    "ATanH",
    "BandCollectionStats",
    "Basin",
    "BitwiseAnd",
    "BitwiseLeftShift",
    "BitwiseNot",
    "BitwiseOr",
    "BitwiseRightShift",
    "BitwiseXOr",
    "BlockStatistics",
    "BooleanAnd",
    "BooleanNot",
    "BooleanOr",
    "BooleanXOr",
    "BoundaryClean",
    "CalculateKernelDensityRatio",
    "CellStatistics",
    "ClassifyRaster",
    "ClassProbability",
    "CombinatorialAnd",
    "CombinatorialOr",
    "CombinatorialXOr",
    "Combine",
    "ComputeConfusionMatrix",
    "ComputeSegmentAttributes",
    "Con",
    "Contour",
    "ContourList",
    "ContourWithBarriers",
    "Corridor",
    "Cos",
    "CosH",
    "CostAllocation",
    "CostBackLink",
    "CostConnectivity",
    "CostDistance",
    "CostPath",
    "CostPathAsPolyline",
    "CreateAccuracyAssessmentPoints",
    "CreateConstantRaster",
    "CreateNormalRaster",
    "CreateRandomRaster",
    "CreateSignatures",
    "Curvature",
    "CutFill",
    "DarcyFlow",
    "DarcyVelocity",
    "DeepLearningModelToEcd",
    "Dendrogram",
    "DeriveContinuousFlow",
    "DeriveStreamAsLine",
    "DeriveStreamAsRaster",
    "Diff",
    "DimensionalMovingStatistics",
    "DistanceAccumulation",
    "DistanceAllocation",
    "Divide",
    "EditSignatures",
    "EqualTo",
    "EqualToFrequency",
    "EucAllocation",
    "EucBackDirection",
    "EucDirection",
    "EucDistance",
    "Exp",
    "Exp10",
    "Exp2",
    "Expand",
    "ExportTrainingDataForDeepLearning",
    "ExtractByAttributes",
    "ExtractByCircle",
    "ExtractByMask",
    "ExtractByPoints",
    "ExtractByPolygon",
    "ExtractByRectangle",
    "ExtractMultiValuesToPoints",
    "ExtractValuesToPoints",
    "Fill",
    "Filter",
    "Float",
    "FlowAccumulation",
    "FlowDirection",
    "FlowDistance",
    "FlowLength",
    "FocalFlow",
    "FocalStatistics",
    "FuzzyMembership",
    "FuzzyOverlay",
    "GenerateMultidimensionalAnomaly",
    "GenerateTrainingSamplesFromSeedPoints",
    "GeomorphonLandforms",
    "GreaterThan",
    "GreaterThanEqual",
    "GreaterThanFrequency",
    "HighestPosition",
    "Hillshade",
    "Idw",
    "InList",
    "InspectTrainingSamples",
    "Int",
    "InterpolateShape",
    "IsNull",
    "IsoCluster",
    "IsoClusterUnsupervisedClassification",
    "KernelDensity",
    "Kriging",
    "LeastCostCorridor",
    "LessThan",
    "LessThanEqual",
    "LessThanFrequency",
    "LinearSpectralUnmixing",
    "LineDensity",
    "LineStatistics",
    "Ln",
    "LocateRegions",
    "Log10",
    "Log2",
    "Lookup",
    "LowestPosition",
    "MajorityFilter",
    "Minus",
    "MLClassify",
    "Mod",
    "NaturalNeighbor",
    "Negate",
    "Nibble",
    "NotEqual",
    "ObserverPoints",
    "OptimalPathAsLine",
    "OptimalPathAsRaster",
    "OptimalRegionConnections",
    "Over",
    "ParticleTrack",
    "PathAllocation",
    "PathBackLink",
    "PathDistance",
    "Pick",
    "Plus",
    "PointDensity",
    "PointsSolarRadiation",
    "PointStatistics",
    "Popularity",
    "PorousPuff",
    "Power",
    "PrincipalComponents",
    "Rank",
    "ReclassByASCIIFile",
    "ReclassByTable",
    "Reclassify",
    "RegionGroup",
    "RemoveRasterSegmentTilingArtifacts",
    "RescaleByFunction",
    "RoundDown",
    "RoundUp",
    "Sample",
    "SegmentMeanShift",
    "SetNull",
    "Shrink",
    "Sin",
    "SinH",
    "Sink",
    "Slice",
    "Slope",
    "SnapPourPoint",
    "SolarRadiationGraphics",
    "Spline",
    "SplineWithBarriers",
    "Square",
    "SquareRoot",
    "StorageCapacity",
    "StreamLink",
    "StreamOrder",
    "StreamToFeature",
    "SurfaceParameters",
    "TabulateArea",
    "Tan",
    "TanH",
    "Test",
    "Thin",
    "Times",
    "TopoToRaster",
    "TopoToRasterByFile",
    "TrainIsoClusterClassifier",
    "TrainKNearestNeighborClassifier",
    "TrainMaximumLikelihoodClassifier",
    "TrainRandomTreesClassifier",
    "TrainSupportVectorMachineClassifier",
    "Trend",
    "UpdateAccuracyAssessmentPoints",
    "Viewshed",
    "Viewshed2",
    "Visibility",
    "Watershed",
    "WeightedOverlay",
    "WeightedSum",
    "ZonalFill",
    "ZonalGeometry",
    "ZonalGeometryAsTable",
    "ZonalHistogram",
    "ZonalStatistics",
    "ZonalStatisticsAsTable",
    "ApplyEnvironment",
    "FloatDivide",
    "FloorDivide",
]

def Abs(in_raster_or_constant):
    """Abs_sa(in_raster_or_constant)

    Calculates the absolute value of the cells in a raster.

    Arguments:
    in_raster_or_constant -- The input raster for which to calculate the absolute values.

    Results:
    out_raster -- Output raster"""
    ...

def ACos(in_raster_or_constant):
    """ACos_sa(in_raster_or_constant)

    Calculates the inverse cosine of cells in a raster.

    Arguments:
    in_raster_or_constant -- The input for which to calculate the inverse cosine values.

    Results:
    out_raster -- Output raster"""
    ...

def ACosH(in_raster_or_constant):
    """ACosH_sa(in_raster_or_constant)

    Calculates the inverse hyperbolic cosine of cells in a raster.

    Arguments:
    in_raster_or_constant -- The input for which to calculate the inverse hyperbolic cosine values.

    Results:
    out_raster -- Output raster"""
    ...

def AddSurfaceInformation(
    in_feature_class,
    in_surface,
    out_property,
    method=...,
    sample_distance=...,
    z_factor=...,
    pyramid_level_resolution=...,
    noise_filtering=...,
):  # -> Any:
    """AddSurfaceInformation_sa(in_feature_class, in_surface, [out_property,...], {method}, {sample_distance}, {z_factor}, {pyramid_level_resolution}, {noise_filtering})

    Attributes input features with height-based statistical information derived from the overlapping portions of a surface.

    Arguments:
    in_feature_class -- The point, multipoint, polyline, or polygon features that define the locations for determining one or more surface properties.
    in_surface -- The LAS dataset, mosaic, raster, terrain, or TIN surface used for interpolating z-values.
    out_property -- Specifies the surface elevation properties that will be added to the attribute table of the input feature class.
    method -- Specifies the interpolation method that will be used to determine information about the surface.
    sample_distance -- The spacing at which z-values will be interpolated. By default, the raster cell size is used when the input surface is a raster, and the natural densification of the triangulated surface is used when the input is a terrain or TIN dataset.
    z_factor -- The factor by which z-values will be multiplied. This is typically used to convert z linear units to match x,y linear units. The default is 1, which leaves elevation values unchanged. This parameter is not available if the spatial reference of the input surface has a z datum with a specified linear unit.
    pyramid_level_resolution -- The z-tolerance or window-size resolution of the terrain pyramid level that will be used. The default is 0, or full resolution.
    noise_filtering -- Defines whether portions of the surface that are potentially characterized by anomalous measurements will be excluded from contributing to slope calculations. Other properties are not affected by this parameter.
    """
    ...

def Aggregate(
    in_raster, cell_factor, aggregation_type=..., extent_handling=..., ignore_nodata=...
):
    """Aggregate_sa(in_raster, cell_factor, {aggregation_type}, {extent_handling}, {ignore_nodata})

    Generates a reduced-resolution version of a raster. Each output cell contains the Sum, Minimum, Maximum, Mean, or Median of the input cells that are encompassed by the extent of that cell.

    Arguments:
    in_raster -- The input raster to aggregate.
    cell_factor -- The factor by which to multiply the cell size of the input raster to obtain the desired resolution for the output raster.
    aggregation_type -- Establishes how the value for each output cell will be determined.
    extent_handling -- Defines how to handle the boundaries of the input raster when its rows or columns are not a multiple of the cell factor.
    ignore_nodata -- Denotes whether NoData values are ignored by the aggregation calculation.

    Results:
    out_raster -- Output raster"""
    ...

def AggregateMultidimensionalRaster(
    in_multidimensional_raster,
    dimension,
    aggregation_method=...,
    variables=...,
    aggregation_def=...,
    interval_keyword=...,
    interval_value=...,
    interval_unit=...,
    interval_ranges=...,
    aggregation_function=...,
    ignore_nodata=...,
    dimensionless=...,
    percentile_value=...,
    percentile_interpolation_type=...,
):
    """AggregateMultidimensionalRaster_sa(in_multidimensional_raster, dimension, {aggregation_method}, {[variable,...]}, {aggregation_def}, {interval_keyword}, {interval_value}, {interval_unit}, {interval_ranges}, {aggregation_function}, {ignore_nodata}, {dimensionless}, {percentile_value}, {percentile_interpolation_type})

    Generates a multidimensional raster dataset by combining existing multidimensional raster variables along a dimension.

    Arguments:
    in_multidimensional_raster -- The input multidimensional raster dataset.
    dimension -- The aggregation dimension. This is the dimension along which the variables will be aggregated.
    aggregation_method -- Specifies the mathematical method that will be used to combine the aggregated slices in an interval.
    variable -- The variable or variables that will be aggregated along the given dimension. If no variable is specified, all variables with the selected dimension will be aggregated.
    aggregation_def -- Specifies the dimension interval for which the data will be aggregated.
    interval_keyword -- Specifies the keyword interval that will be used when aggregating along the dimension. This parameter is required when the Aggregation Definition parameter is set to Interval Keyword and the aggregation must be across time.
    interval_value -- The size of the interval that will be used for the aggregation. This parameter is required when the Aggregation Definition parameter is set to Interval Value.
    interval_unit -- The unit that will be used for the Value Interval parameter. This parameter is required when the Dimension parameter is a time field and the Aggregation Definition parameter is set to Interval Value.
    interval_ranges -- Interval ranges specified in a value table will be used to aggregate groups of values. The value table consists of pairs of minimum and maximum range values, with data type Double or Date.
    aggregation_function -- A custom raster function that will be used to compute the pixel values of the aggregated rasters. The input is a raster function JSON object or an .rft.xml file created from a function chain or a custom Python raster function.
    ignore_nodata -- Specifies whether NoData values will be ignored in the analysis.
    dimensionless -- Specifies whether the layer will have dimension values. This parameter is only active if a single slice is selected to create a layer.
    percentile_value -- The percentile to calculate. The default is 90, indicating the 90th percentile.
    percentile_interpolation_type -- Specifies the method of percentile interpolation that will be used when there is an even number of values from the input raster to be calculated.

    Results:
    out_multidimensional_raster -- Output Multidimensional Raster"""
    ...

def AreaSolarRadiation(
    in_surface_raster,
    latitude=...,
    sky_size=...,
    time_configuration=...,
    day_interval=...,
    hour_interval=...,
    each_interval=...,
    z_factor=...,
    slope_aspect_input_type=...,
    calculation_directions=...,
    zenith_divisions=...,
    azimuth_divisions=...,
    diffuse_model_type=...,
    diffuse_proportion=...,
    transmittivity=...,
    out_direct_radiation_raster=...,
    out_diffuse_radiation_raster=...,
    out_direct_duration_raster=...,
):
    """AreaSolarRadiation_sa(in_surface_raster, {latitude}, {sky_size}, {time_configuration}, {day_interval}, {hour_interval}, {each_interval}, {z_factor}, {slope_aspect_input_type}, {calculation_directions}, {zenith_divisions}, {azimuth_divisions}, {diffuse_model_type}, {diffuse_proportion}, {transmittivity}, {out_direct_radiation_raster}, {out_diffuse_radiation_raster}, {out_direct_duration_raster})

    Derives incoming solar radiation from a raster surface.

    Arguments:
    in_surface_raster -- The input elevation surface raster.
    latitude -- The latitude for the site area. The units are decimal degrees with positive values for the northern hemisphere and negative values for the southern hemisphere.
    sky_size -- The resolution or sky size for the viewshed, sky map, and sun map rasters. The units are cells.
    time_configuration -- Specifies the time period that will be used for the calculations.
    day_interval -- The time interval through the year (units: days) that will be used to calculate sky sectors for the sun map.
    hour_interval -- The time interval through the day (units: hours) that will be used to calculate sky sectors for the sun map.
    each_interval -- Specifies whether a single total insolation value will be calculated for all locations or multiple values will be calculated for the specified hour and day interval.
    z_factor -- The number of ground x,y units in one surface z-unit.
    slope_aspect_input_type -- Specifies how slope and aspect information will be derived for analysis.
    calculation_directions -- The number of azimuth directions that will be used when calculating the viewshed.
    zenith_divisions -- The number of zenith divisions that will be used to create sky sectors in the sky map.
    azimuth_divisions -- The number of azimuth divisions that will be used to create sky sectors in the sky map.
    diffuse_model_type -- Specifies the type of diffuse radiation model that will be used.
    diffuse_proportion -- The proportion of global normal radiation flux that is diffuse. Values range from 0 to 1.
    transmittivity -- The fraction of radiation that passes through the atmosphere (averaged overall wavelengths). Values range from 0 (no transmission) to 1 (all transmission).
    out_direct_radiation_raster -- The output raster representing the direct incoming solar radiation for each location.
    out_diffuse_radiation_raster -- The output raster representing the diffuse incoming solar radiation for each location.
    out_direct_duration_raster -- The output raster representing the duration of direct incoming solar radiation.

    Results:
    out_global_radiation_raster -- Output global radiation raster"""
    ...

def ASin(in_raster_or_constant):
    """ASin_sa(in_raster_or_constant)

    Calculates the inverse sine of cells in a raster.

    Arguments:
    in_raster_or_constant -- The input for which to calculate the inverse sine values.

    Results:
    out_raster -- Output raster"""
    ...

def ASinH(in_raster_or_constant):
    """ASinH_sa(in_raster_or_constant)

    Calculates the inverse hyperbolic sine of cells in a raster.

    Arguments:
    in_raster_or_constant -- The input for which to calculate the inverse hyperbolic sine values.

    Results:
    out_raster -- Output raster"""
    ...

def Aspect(
    in_raster,
    method=...,
    z_unit=...,
    project_geodesic_azimuths=...,
    analysis_target_device=...,
):
    """Aspect_sa(in_raster, {method}, {z_unit}, {project_geodesic_azimuths}, {analysis_target_device})

    Derives the aspect from each cell of a raster surface.

    Arguments:
    in_raster -- The input surface raster.
    method -- Specifies whether the calculation will be based on a planar (flat earth) or a geodesic (ellipsoid) method.
    z_unit -- Specifies the linear unit that will be used for vertical z-values.
    project_geodesic_azimuths -- Specifies whether geodesic azimuths will be projected to correct the angle distortion caused by the output spatial reference.
    analysis_target_device -- Specifies the device that will be used to perform the calculation.

    Results:
    out_raster -- Output raster"""
    ...

def ATan(in_raster_or_constant):
    """ATan_sa(in_raster_or_constant)

    Calculates the inverse tangent of cells in a raster.

    Arguments:
    in_raster_or_constant -- The input for which to calculate the inverse tangent values.

    Results:
    out_raster -- Output raster"""
    ...

def ATan2(in_raster_or_constant1, in_raster_or_constant2):
    """ATan2_sa(in_raster_or_constant1, in_raster_or_constant2)

    Calculates the inverse tangent (based on x,y) of cells in a raster.

    Arguments:
    in_raster_or_constant1 -- The input that specifies the numerator, or y value, to use when calculating the inverse tangent.
    in_raster_or_constant2 -- The input that specifies the denominator, or x value, to use when calculating the inverse tangent.

    Results:
    out_raster -- Output raster"""
    ...

def ATanH(in_raster_or_constant):
    """ATanH_sa(in_raster_or_constant)

    Calculates the inverse hyperbolic tangent of cells in a raster.

    Arguments:
    in_raster_or_constant -- The input for which to calculate the inverse hyperbolic tangent values.

    Results:
    out_raster -- Output raster"""
    ...

def BandCollectionStats(
    in_raster_bands, out_stat_file, compute_matrices=...
):  # -> Any:
    """BandCollectionStats_sa([in_raster_band,...], out_stat_file, {compute_matrices})

    Calculates the statistics for a set of raster bands.

    Arguments:
    in_raster_band -- The input raster bands.
    out_stat_file -- The output ASCII file containing the statistics.
    compute_matrices -- Specifies whether covariance and correlation matrices are calculated.
    """
    ...

def Basin(in_flow_direction_raster):
    """Basin_sa(in_flow_direction_raster)

    Creates a raster delineating all drainage basins.

    Arguments:
    in_flow_direction_raster -- The input raster that shows the direction of flow out of each cell.

    Results:
    out_raster -- Output raster"""
    ...

def BitwiseAnd(in_raster_or_constant1, in_raster_or_constant2):
    """BitwiseAnd_sa(in_raster_or_constant1, in_raster_or_constant2)

    Performs a Bitwise And operation on the binary values of two input rasters.

    Arguments:
    in_raster_or_constant1 -- The first input to use in this bitwise operation.
    in_raster_or_constant2 -- The second input to use in this bitwise operation.

    Results:
    out_raster -- Output raster"""
    ...

def BitwiseLeftShift(in_raster_or_constant1, in_raster_or_constant2):
    """BitwiseLeftShift_sa(in_raster_or_constant1, in_raster_or_constant2)

    Performs a Bitwise Left Shift operation on the binary values of two input rasters.

    Arguments:
    in_raster_or_constant1 -- The input on which to perform the shift.
    in_raster_or_constant2 -- The input defining the number of positions to shift the bits.

    Results:
    out_raster -- Output raster"""
    ...

def BitwiseNot(in_raster_or_constant):
    """BitwiseNot_sa(in_raster_or_constant)

    Performs a Bitwise Not (complement) operation on the binary value of an input raster.

    Arguments:
    in_raster_or_constant -- The input raster on which to perform the Bitwise Not (complement) operation.

    Results:
    out_raster -- Output raster"""
    ...

def BitwiseOr(in_raster_or_constant1, in_raster_or_constant2):
    """BitwiseOr_sa(in_raster_or_constant1, in_raster_or_constant2)

    Performs a Bitwise Or operation on the binary values of two input rasters.

    Arguments:
    in_raster_or_constant1 -- The first input to use in this bitwise operation.
    in_raster_or_constant2 -- The second input to use in this bitwise operation.

    Results:
    out_raster -- Output raster"""
    ...

def BitwiseRightShift(in_raster_or_constant1, in_raster_or_constant2):
    """BitwiseRightShift_sa(in_raster_or_constant1, in_raster_or_constant2)

    Performs a Bitwise Right Shift operation on the binary values of two input rasters.

    Arguments:
    in_raster_or_constant1 -- The input on which to perform the shift.
    in_raster_or_constant2 -- The input defining the number of positions to shift the bits.

    Results:
    out_raster -- Output raster"""
    ...

def BitwiseXOr(in_raster_or_constant1, in_raster_or_constant2):
    """BitwiseXOr_sa(in_raster_or_constant1, in_raster_or_constant2)

    Performs a Bitwise eXclusive Or operation on the binary values of two input rasters.

    Arguments:
    in_raster_or_constant1 -- The first input to use in this bitwise operation.
    in_raster_or_constant2 -- The second input to use in this bitwise operation.

    Results:
    out_raster -- Output raster"""
    ...

def BlockStatistics(
    in_raster, neighborhood=..., statistics_type=..., ignore_nodata=...
):
    """BlockStatistics_sa(in_raster, {neighborhood}, {statistics_type}, {ignore_nodata})

    Partitions the input into non-overlapping blocks and calculates the statistic of the values within each block. The value is assigned to all of the cells in each block in the output.

    Arguments:
    in_raster -- The raster for which the block statistics will be calculated.
    neighborhood -- The cells of the processing block that will be used in the statistic calculation. There are several predefined neighborhood types to choose from, or a custom kernel can be defined.
    statistics_type -- Specifies the statistic type to be calculated.
    ignore_nodata -- Specifies whether NoData values will be ignored by the statistic calculation.

    Results:
    out_raster -- Output raster"""
    ...

def BooleanAnd(in_raster_or_constant1, in_raster_or_constant2):
    """BooleanAnd_sa(in_raster_or_constant1, in_raster_or_constant2)

    Performs a Boolean And operation on the cell values of two input rasters.

    Arguments:
    in_raster_or_constant1 -- The first input to use in this Boolean operation.
    in_raster_or_constant2 -- The second input to use in this Boolean operation.

    Results:
    out_raster -- Output raster"""
    ...

def BooleanNot(in_raster_or_constant):
    """BooleanNot_sa(in_raster_or_constant)

    Performs a Boolean Not (complement) operation on the cell values of the input raster.

    Arguments:
    in_raster_or_constant -- The input to use in this Boolean operation.

    Results:
    out_raster -- Output raster"""
    ...

def BooleanOr(in_raster_or_constant1, in_raster_or_constant2):
    """BooleanOr_sa(in_raster_or_constant1, in_raster_or_constant2)

    Performs a Boolean Or operation on the cell values of two input rasters.

    Arguments:
    in_raster_or_constant1 -- The first input to use in this Boolean operation.
    in_raster_or_constant2 -- The second input to use in this Boolean operation.

    Results:
    out_raster -- Output raster"""
    ...

def BooleanXOr(in_raster_or_constant1, in_raster_or_constant2):
    """BooleanXOr_sa(in_raster_or_constant1, in_raster_or_constant2)

    Performs a Boolean eXclusive Or operation on the cell values of two input rasters.

    Arguments:
    in_raster_or_constant1 -- The first input to use in this Boolean operation.
    in_raster_or_constant2 -- The second input to use in this Boolean operation.

    Results:
    out_raster -- Output raster"""
    ...

def BoundaryClean(in_raster, sort_type=..., number_of_runs=...):
    """BoundaryClean_sa(in_raster, {sort_type}, {number_of_runs})

    Smooths the boundary between zones in a raster.

    Arguments:
    in_raster -- The input raster for which the boundary between zones will be smoothed.
    sort_type -- Specifies the type of sorting to use in the smoothing process. The sorting determines the priority by which cells can expand into their neighbors.
    number_of_runs -- Specifies the number of times the smoothing process will occur, twice or once.

    Results:
    out_raster -- Output raster"""
    ...

def CalculateKernelDensityRatio(
    in_features_numerator,
    in_features_denominator,
    population_field_numerator,
    population_field_denominator,
    cell_size=...,
    search_radius_numerator=...,
    search_radius_denominator=...,
    out_cell_values=...,
    method=...,
    in_barriers_numerator=...,
    in_barriers_denominator=...,
):
    """CalculateKernelDensityRatio_sa(in_features_numerator, in_features_denominator, population_field_numerator, population_field_denominator, {cell_size}, {search_radius_numerator}, {search_radius_denominator}, {out_cell_values}, {method}, {in_barriers_numerator}, {in_barriers_denominator})

    Calculates a spatial relative risk surface using two input feature datasets. The numerator in the ratio represents cases, such as number of crimes or number of patients, and the denominator represents the control, such as the total population.

    Arguments:
    in_features_numerator -- The input features (point or line) of the cases for which density will be calculated.
    in_features_denominator -- The input features (point or line) of the control for which density will be calculated.
    population_field_numerator -- The field denoting population values for each feature. The population field is the count or quantity to be spread across the landscape to create a continuous surface.
    population_field_denominator -- The field denoting population values for each feature. The population field is the count or quantity to be spread across the landscape to create a continuous surface.
    cell_size -- The cell size of the output raster that will be created.
    search_radius_numerator -- The search radius within which density will be calculated. Units are based on the linear unit of the projection of the output spatial reference.
    search_radius_denominator -- The search radius within which density will be calculated. Units are based on the linear unit of the projection of the output spatial reference.
    out_cell_values -- Specifies what the values in the output raster represent.
    method -- Specifies whether the flat earth (planar) or the shortest path on a spheroid (geodesic) distance will be used.
    in_barriers_numerator -- The dataset that defines the barriers.
    in_barriers_denominator -- The dataset that defines the barriers.

    Results:
    out_raster -- Output raster"""
    ...

def CellStatistics(
    in_rasters_or_constants,
    statistics_type=...,
    ignore_nodata=...,
    process_as_multiband=...,
    percentile_value=...,
    percentile_interpolation_type=...,
):
    """CellStatistics_sa([in_rasters_or_constant,...], {statistics_type}, {ignore_nodata}, {process_as_multiband}, {percentile_value}, {percentile_interpolation_type})

    Calculates a per-cell statistic from multiple rasters.

    Arguments:
    in_rasters_or_constant -- A list of input rasters for which a statistical operation will be calculated for each cell in the analysis window.
    statistics_type -- Specifies the statistic type to be calculated.
    ignore_nodata -- Specifies whether NoData values will be ignored by the statistic calculation.
    process_as_multiband -- Specifies how the input multiband raster bands will be processed.
    percentile_value -- The percentile value that will be calculated. The default is 90, indicating the 90th percentile.
    percentile_interpolation_type -- Specifies the method of interpolation that will be used when the specified percentile value is between two input cell values.

    Results:
    out_raster -- Output raster"""
    ...

def ClassifyRaster(in_raster, in_classifier_definition, in_additional_raster=...):
    """ClassifyRaster_sa(in_raster, in_classifier_definition, {in_additional_raster})

    Classifies a raster dataset based on an Esri classifier definition file (.ecd) and raster dataset inputs.

    Arguments:
    in_raster -- The raster dataset to classify.
    in_classifier_definition -- The input Esri classifier definition file (.ecd) containing the statistics for the chosen attributes for the classifier.
    in_additional_raster -- Ancillary raster datasets, such as a multispectral image or a DEM, will be incorporated to generate attributes and other required information for the classifier. This raster is necessary when calculating attributes such as mean or standard deviation. This parameter is optional.

    Results:
    out_raster_dataset -- Output Classified Raster"""
    ...

def ClassProbability(
    in_raster_bands,
    in_signature_file,
    maximum_output_value=...,
    a_priori_probabilities=...,
    in_a_priori_file=...,
):
    """ClassProbability_sa([in_raster_band,...], in_signature_file, {maximum_output_value}, {a_priori_probabilities}, {in_a_priori_file})

    Creates a multiband raster of probability bands, with one band being created for each class represented in the input signature file.

    Arguments:
    in_raster_band -- The input raster bands.
    in_signature_file -- Input signature file whose class signatures are used to generate the a priori probability bands.
    maximum_output_value -- Factor for scaling the range of values in the output probability bands.
    a_priori_probabilities -- Specifies how a priori probabilities will be determined.
    in_a_priori_file -- A text file containing a priori probabilities for the input signature classes.

    Results:
    out_multiband_raster -- Output multiband raster"""
    ...

def CombinatorialAnd(in_raster_or_constant1, in_raster_or_constant2):
    """CombinatorialAnd_sa(in_raster_or_constant1, in_raster_or_constant2)

    Performs a Combinatorial And operation on the cell values of two input rasters.

    Arguments:
    in_raster_or_constant1 -- The first input to use in this combinatorial operation.
    in_raster_or_constant2 -- The second input to use in this combinatorial operation.

    Results:
    out_raster -- Output raster"""
    ...

def CombinatorialOr(in_raster_or_constant1, in_raster_or_constant2):
    """CombinatorialOr_sa(in_raster_or_constant1, in_raster_or_constant2)

    Performs a Combinatorial Or operation on the cell values of two input rasters.

    Arguments:
    in_raster_or_constant1 -- The first input to use in this combinatorial operation.
    in_raster_or_constant2 -- The second input to use in this combinatorial operation.

    Results:
    out_raster -- Output raster"""
    ...

def CombinatorialXOr(in_raster_or_constant1, in_raster_or_constant2):
    """CombinatorialXOr_sa(in_raster_or_constant1, in_raster_or_constant2)

    Performs a Combinatorial eXclusive Or operation on the cell values of two input rasters.

    Arguments:
    in_raster_or_constant1 -- The first input to use in this combinatorial operation.
    in_raster_or_constant2 -- The second input to use in this combinatorial operation.

    Results:
    out_raster -- Output raster"""
    ...

def Combine(in_rasters):
    """Combine_sa([in_raster,...])

    Combines multiple rasters so that a unique output value is assigned to each unique combination of input values.

    Arguments:
    in_raster -- The list of input rasters to be combined.

    Results:
    out_raster -- Output raster"""
    ...

def ComputeConfusionMatrix(
    in_accuracy_assessment_points, out_confusion_matrix
):  # -> Any:
    """ComputeConfusionMatrix_sa(in_accuracy_assessment_points, out_confusion_matrix)

    Computes a confusion matrix with errors of omission and commission and derives a kappa index of agreement, Intersection over Union (IoU),  and an overall accuracy between the classified map and the reference data.

    Arguments:
    in_accuracy_assessment_points -- The accuracy assessment point feature class created from the Create Accuracy Assessment Points tool, containing the Classified and GrndTruth fields. The Classified and GrndTruth fields are both long integer field types.
    out_confusion_matrix -- The output file name of the confusion matrix in table format.
    """
    ...

def ComputeSegmentAttributes(
    in_segmented_raster, in_additional_raster=..., used_attributes=...
):
    """ComputeSegmentAttributes_sa(in_segmented_raster, {in_additional_raster}, {[used_attribute,...]})

    Computes a set of attributes associated with the segmented image. The input raster can be a single-band or 3-band, 8-bit segmented image.

    Arguments:
    in_segmented_raster -- The input segmented raster dataset, where all the pixels belonging to a segment have the same converged RGB color. Usually, it is an 8-bit, 3-band RGB raster, but it can also be a 1-band grayscale raster.
    in_additional_raster -- Ancillary raster datasets, such as a multispectral image or a DEM, will be incorporated to generate attributes and other required information for the classifier. This raster is necessary when calculating attributes such as mean or standard deviation. This parameter is optional.
    used_attribute -- Specifies the attributes that will be included in the attribute table associated with the output raster.

    Results:
    out_index_raster_dataset -- Output Segment Index Raster"""
    ...

def Con(
    in_conditional_raster,
    in_true_raster_or_constant,
    in_false_raster_or_constant=...,
    where_clause=...,
):
    """Con_sa(in_conditional_raster, in_true_raster_or_constant, {in_false_raster_or_constant}, {where_clause})

    Performs a conditional if/else evaluation on each of the input cells of an input raster.

    Arguments:
    in_conditional_raster -- The input raster representing the true or false result of the desired condition.
    in_true_raster_or_constant -- The input whose values will be used as the output cell values if the condition is true.
    in_false_raster_or_constant -- The input whose values will be used as the output cell values if the condition is false.
    where_clause -- A logical expression that determines which of the input cells are to be true or false.

    Results:
    out_raster -- Output raster"""
    ...

def Contour(
    in_raster,
    out_polyline_features,
    contour_interval,
    base_contour=...,
    z_factor=...,
    contour_type=...,
    max_vertices_per_feature=...,
):  # -> Any:
    """Contour_sa(in_raster, out_polyline_features, contour_interval, {base_contour}, {z_factor}, {contour_type}, {max_vertices_per_feature})

    Creates a feature class of contours from a raster surface.

    Arguments:
    in_raster -- The input surface raster.
    out_polyline_features -- The output contour features.
    contour_interval -- The interval, or distance, between contour lines.
    base_contour -- The base contour value.
    z_factor -- The unit conversion factor used when generating contours. The default value is 1.
    contour_type -- Specifies the type of output. The output can represent the contours as either lines or polygons. There are several options for polygons.
    max_vertices_per_feature -- The vertex limit when subdividing a feature. This should only be used when output features contain a very large number of vertices (many millions).
    """
    ...

def ContourList(in_raster, out_polyline_features, contour_values):  # -> Any:
    """ContourList_sa(in_raster, out_polyline_features, [contour_value,...])

    Creates a feature class of selected contour values from a raster surface.

    Arguments:
    in_raster -- The input surface raster.
    out_polyline_features -- The output contour polyline features.
    contour_value -- List of z-values for which to create contours."""
    ...

def ContourWithBarriers(
    in_raster,
    out_contour_feature_class,
    in_barrier_features=...,
    in_contour_type=...,
    in_contour_values_file=...,
    explicit_only=...,
    in_base_contour=...,
    in_contour_interval=...,
    in_indexed_contour_interval=...,
    in_explicit_contours=...,
    in_z_factor=...,
):  # -> Any:
    """ContourWithBarriers_sa(in_raster, out_contour_feature_class, {in_barrier_features}, {in_contour_type}, {in_contour_values_file}, {explicit_only}, {in_base_contour}, {in_contour_interval}, {in_indexed_contour_interval}, {[in_explicit_contour,...]}, {in_z_factor})

    Creates contours from a raster surface. The inclusion of barrier features allows you to independently generate contours on either side of a barrier.

    Arguments:
    in_raster -- The input surface raster.
    out_contour_feature_class -- The output contour features.
    in_barrier_features -- The input barrier features.
    in_contour_type -- The type of contour to create.
    in_contour_values_file -- The base contour, contour interval, indexed contour interval, and explicit contour values can also be specified via a text file.
    explicit_only -- Only explicit contour values are used. Base contour, contour interval, and indexed contour intervals are not specified.
    in_base_contour -- The base contour value.
    in_contour_interval -- The interval, or distance, between contour lines.
    in_indexed_contour_interval -- Contours will also be generated for this interval and will be flagged accordingly in the output feature class.
    in_explicit_contour -- Explicit values at which to create contours.
    in_z_factor -- The unit conversion factor used when generating contours. The default value is 1.
    """
    ...

def Corridor(in_distance_raster1, in_distance_raster2):
    """Corridor_sa(in_distance_raster1, in_distance_raster2)

    Calculates the sum of accumulative costs for two input accumulative cost rasters.

    Arguments:
    in_distance_raster1 -- The first input distance raster.
    in_distance_raster2 -- The second input distance raster.

    Results:
    out_raster -- Output raster"""
    ...

def Cos(in_raster_or_constant):
    """Cos_sa(in_raster_or_constant)

    Calculates the cosine of cells in a raster.

    Arguments:
    in_raster_or_constant -- The input for which to calculate the cosine values.

    Results:
    out_raster -- Output raster"""
    ...

def CosH(in_raster_or_constant):
    """CosH_sa(in_raster_or_constant)

    Calculates the hyperbolic cosine of cells in a raster.

    Arguments:
    in_raster_or_constant -- The input for which to calculate the hyperbolic cosine values.

    Results:
    out_raster -- Output raster"""
    ...

def CostAllocation(
    in_source_data,
    in_cost_raster,
    maximum_distance=...,
    in_value_raster=...,
    source_field=...,
    out_distance_raster=...,
    out_backlink_raster=...,
    source_cost_multiplier=...,
    source_start_cost=...,
    source_resistance_rate=...,
    source_capacity=...,
    source_direction=...,
):
    """CostAllocation_sa(in_source_data, in_cost_raster, {maximum_distance}, {in_value_raster}, {source_field}, {out_distance_raster}, {out_backlink_raster}, {source_cost_multiplier}, {source_start_cost}, {source_resistance_rate}, {source_capacity}, {source_direction})

    Calculates, for each cell, its least-cost source based on the least accumulative cost over a cost surface.

    Arguments:
    in_source_data -- The input source locations.
    in_cost_raster -- A raster defining the impedance or cost to move planimetrically through each cell.
    maximum_distance -- The threshold that the accumulative cost values cannot exceed.
    in_value_raster -- The input integer raster that identifies the zone values that will be used for each input source location.
    source_field -- The field used to assign values to the source locations. It must be of integer type.
    out_distance_raster -- The output cost distance raster.
    out_backlink_raster -- The output cost backlink raster.
    source_cost_multiplier -- The multiplier that will be applied to the cost values.
    source_start_cost -- The starting cost that will be used to begin the cost calculations.
    source_resistance_rate -- This parameter simulates the increase in the effort to overcome costs as the accumulative cost increases. It is used to model fatigue of the traveler. The growing accumulative cost to reach a cell is multiplied by the resistance rate and added to the cost to move into the subsequent cell.
    source_capacity -- The cost capacity for the traveler for a source.
    source_direction -- Specifies the direction of the traveler when applying the source resistance rate and the source starting cost.

    Results:
    out_allocation_raster -- Output allocation raster"""
    ...

def CostBackLink(
    in_source_data,
    in_cost_raster,
    maximum_distance=...,
    out_distance_raster=...,
    source_cost_multiplier=...,
    source_start_cost=...,
    source_resistance_rate=...,
    source_capacity=...,
    source_direction=...,
):
    """CostBackLink_sa(in_source_data, in_cost_raster, {maximum_distance}, {out_distance_raster}, {source_cost_multiplier}, {source_start_cost}, {source_resistance_rate}, {source_capacity}, {source_direction})

    Defines the neighbor that is the next cell on the least accumulative cost path to the least-cost source.

    Arguments:
    in_source_data -- The input source locations.
    in_cost_raster -- A raster defining the impedance or cost to move planimetrically through each cell.
    maximum_distance -- The threshold that the accumulative cost values cannot exceed.
    out_distance_raster -- The output cost distance raster.
    source_cost_multiplier -- The multiplier that will be applied to the cost values.
    source_start_cost -- The starting cost that will be used to begin the cost calculations.
    source_resistance_rate -- This parameter simulates the increase in the effort to overcome costs as the accumulative cost increases. It is used to model fatigue of the traveler. The growing accumulative cost to reach a cell is multiplied by the resistance rate and added to the cost to move into the subsequent cell.
    source_capacity -- The cost capacity for the traveler for a source.
    source_direction -- Specifies the direction of the traveler when applying the source resistance rate and the source starting cost.

    Results:
    out_backlink_raster -- Output backlink raster"""
    ...

def CostConnectivity(
    in_regions, in_cost_raster, out_feature_class, out_neighbor_paths=...
):  # -> Any:
    """CostConnectivity_sa(in_regions, in_cost_raster, out_feature_class, {out_neighbor_paths})

    Produces the least-cost connectivity network between two or more input regions.

    Arguments:
    in_regions -- The input regions that are to be connected by the least-cost network.
    in_cost_raster -- A raster defining the impedance or cost to move planimetrically through each cell.
    out_feature_class -- The output polyline feature class of the optimum (least-cost) network of paths necessary to connect each of the input regions.
    out_neighbor_paths -- The output polyline feature class identifying all paths from each region to each of its closest-cost neighbors.
    """
    ...

def CostDistance(
    in_source_data,
    in_cost_raster,
    maximum_distance=...,
    out_backlink_raster=...,
    source_cost_multiplier=...,
    source_start_cost=...,
    source_resistance_rate=...,
    source_capacity=...,
    source_direction=...,
):
    """CostDistance_sa(in_source_data, in_cost_raster, {maximum_distance}, {out_backlink_raster}, {source_cost_multiplier}, {source_start_cost}, {source_resistance_rate}, {source_capacity}, {source_direction})

    Calculates the least accumulative cost distance for each cell from or to the least-cost source over a cost surface.

    Arguments:
    in_source_data -- The input source locations.
    in_cost_raster -- A raster defining the impedance or cost to move planimetrically through each cell.
    maximum_distance -- The threshold that the accumulative cost values cannot exceed.
    out_backlink_raster -- The output cost backlink raster.
    source_cost_multiplier -- The multiplier that will be applied to the cost values.
    source_start_cost -- The starting cost that will be used to begin the cost calculations.
    source_resistance_rate -- This parameter simulates the increase in the effort to overcome costs as the accumulative cost increases. It is used to model fatigue of the traveler. The growing accumulative cost to reach a cell is multiplied by the resistance rate and added to the cost to move into the subsequent cell.
    source_capacity -- The cost capacity for the traveler for a source.
    source_direction -- Specifies the direction of the traveler when applying the source resistance rate and the source starting cost.

    Results:
    out_distance_raster -- Output distance raster"""
    ...

def CostPath(
    in_destination_data,
    in_cost_distance_raster,
    in_cost_backlink_raster,
    path_type=...,
    destination_field=...,
    force_flow_direction_convention=...,
):
    """CostPath_sa(in_destination_data, in_cost_distance_raster, in_cost_backlink_raster, {path_type}, {destination_field}, {force_flow_direction_convention})

    Calculates the least-cost path from a source to a destination.

    Arguments:
    in_destination_data -- A raster or feature dataset that identifies those cells from which the least-cost path is determined to the least costly source.
    in_cost_distance_raster -- The name of a cost distance raster to be used to determine the least-cost path from the destination locations to a source.
    in_cost_backlink_raster -- The name of a cost back link raster used to determine the path to return to a source via the least-cost path.
    path_type -- A keyword defining the manner in which the values and zones on the input destination data will be interpreted in the cost path calculations.
    destination_field -- The field used to obtain values for the destination locations.
    force_flow_direction_convention -- Specifies whether the input backlink raster will be treated as a flow direction raster. Flow direction rasters can have integer values that range from 0-255.

    Results:
    out_raster -- Output raster"""
    ...

def CostPathAsPolyline(
    in_destination_data,
    in_cost_distance_raster,
    in_cost_backlink_raster,
    out_polyline_features,
    path_type=...,
    destination_field=...,
    force_flow_direction_convention=...,
):  # -> Any:
    """CostPathAsPolyline_sa(in_destination_data, in_cost_distance_raster, in_cost_backlink_raster, out_polyline_features, {path_type}, {destination_field}, {force_flow_direction_convention})

    Calculates the least-cost path from a source to a destination as a line feature.

    Arguments:
    in_destination_data -- A raster or feature dataset that identifies those cells from which the least-cost path is determined to the least costly source.
    in_cost_distance_raster -- The cost distance raster to be used to determine the least-cost path from the sources to the destinations.
    in_cost_backlink_raster -- The cost backlink raster to be used to determine the path to return to a source via the least-cost path, or the shortest path.
    out_polyline_features -- The output feature class that will hold the least cost path.
    path_type -- Specifies a keyword defining the manner in which the values and zones on the input destination data will be interpreted in the cost path calculations.
    destination_field -- The field to be used to obtain values for the destination locations.
    force_flow_direction_convention -- Specifies whether the input backlink raster will be treated as a flow direction raster. Flow direction rasters can have integer values that range from 0-255.
    """
    ...

def CreateAccuracyAssessmentPoints(
    in_class_data,
    out_points,
    target_field=...,
    num_random_points=...,
    sampling=...,
    polygon_dimension_field=...,
):  # -> Any:
    """CreateAccuracyAssessmentPoints_sa(in_class_data, out_points, {target_field}, {num_random_points}, {sampling}, {polygon_dimension_field})

    Creates randomly sampled points for post-classification accuracy assessment.

    Arguments:
    in_class_data -- The input classification image or other thematic GIS reference data. The input can be a raster or feature class.
    out_points -- The output point shapefile or feature class that contains the random points to be used for accuracy assessment.
    target_field -- Specifies whether the input data is a classified image or ground truth data.
    num_random_points -- The total number of random points that will be generated.
    sampling -- Specifies the sampling scheme that will be used.
    polygon_dimension_field -- A field that defines the dimension (time) of the features. This parameter is used only if the classification result is multidimensional raster and you want to generate assessment points from a feature class, such as land classification polygons for multiple years.
    """
    ...

def CreateConstantRaster(constant_value, data_type=..., cell_size=..., extent=...):
    """CreateConstantRaster_sa(constant_value, {data_type}, {cell_size}, {extent})

    Creates a raster of a constant value within the extent and cell size of the analysis window.

    Arguments:
    constant_value -- The constant value with which to populate all the cells in the output raster.
    data_type -- Data type of the output raster dataset.
    cell_size -- The cell size of the output raster that will be created.
    extent -- The extent for the output raster dataset.

    Results:
    out_raster -- Output raster"""
    ...

def CreateNormalRaster(cell_size=..., extent=...):
    """CreateNormalRaster_sa({cell_size}, {extent})

    Creates a raster of random values with a normal (Gaussian) distribution within the extent and cell size of the analysis window.

    Arguments:
    cell_size -- The cell size of the output raster that will be created.
    extent -- The extent for the output raster dataset.

    Results:
    out_raster -- Output raster"""
    ...

def CreateRandomRaster(seed_value=..., cell_size=..., extent=...):
    """CreateRandomRaster_sa({seed_value}, {cell_size}, {extent})

    Creates a raster of random floating-point values between 0.0 and 1.0 within the extent and cell size of the analysis window.

    Arguments:
    seed_value -- A value to be used to reseed the random number generator.
    cell_size -- The cell size of the output raster that will be created.
    extent -- The extent for the output raster dataset.

    Results:
    out_raster -- Output raster"""
    ...

def CreateSignatures(
    in_raster_bands,
    in_sample_data,
    out_signature_file,
    compute_covariance=...,
    sample_field=...,
):  # -> Any:
    """CreateSignatures_sa([in_raster_band,...], in_sample_data, out_signature_file, {compute_covariance}, {sample_field})

    Creates an ASCII signature file of classes defined by input sample data and a set of raster bands.

    Arguments:
    in_raster_band -- The input raster bands for which to create the signatures.
    in_sample_data -- The input delineating the set of class samples.
    out_signature_file -- The output signature file.
    compute_covariance -- Specifies whether covariance matrices in addition to the means are calculated.
    sample_field -- Field of the input raster or feature sample data to assign values to the sampled locations (classes).
    """
    ...

def Curvature(
    in_raster, z_factor=..., out_profile_curve_raster=..., out_plan_curve_raster=...
):
    """Curvature_sa(in_raster, {z_factor}, {out_profile_curve_raster}, {out_plan_curve_raster})

    Calculates the curvature of a raster surface, optionally including profile and plan curvature.

    Arguments:
    in_raster -- The input surface raster.
    z_factor -- The number of ground x,y units in one surface z-unit.
    out_profile_curve_raster -- Output profile curve raster dataset.
    out_plan_curve_raster -- Output plan curve raster dataset.

    Results:
    out_curvature_raster -- Output curvature raster"""
    ...

def CutFill(in_before_surface, in_after_surface, z_factor=...):
    """CutFill_sa(in_before_surface, in_after_surface, {z_factor})

    Calculates the volume change between two surfaces. This is typically used for cut and fill operations.

    Arguments:
    in_before_surface -- The input representing the surface before the cut or fill operation.
    in_after_surface -- The input representing the surface after the cut or fill operation.
    z_factor -- The number of ground x,y units in one surface z-unit.

    Results:
    out_raster -- Output raster"""
    ...

def DarcyFlow(
    in_head_raster,
    in_porosity_raster,
    in_thickness_raster,
    in_transmissivity_raster,
    out_direction_raster=...,
    out_magnitude_raster=...,
):
    """DarcyFlow_sa(in_head_raster, in_porosity_raster, in_thickness_raster, in_transmissivity_raster, {out_direction_raster}, {out_magnitude_raster})

    Calculates the groundwater volume balance residual and other outputs for steady flow in an aquifer.

    Arguments:
    in_head_raster -- The input raster where each cell value represents the groundwater head elevation at that location.
    in_porosity_raster -- The input raster where each cell value represents the effective formation porosity at that location.
    in_thickness_raster -- The input raster where each cell value represents the saturated thickness at that location.
    in_transmissivity_raster -- The input raster where each cell value represents the formation transmissivity at that location.
    out_direction_raster -- The output flow direction raster.
    out_magnitude_raster -- An optional output raster where each cell value represents the magnitude of the seepage velocity vector (average linear velocity) at the center of the cell, calculated as the average value of the seepage velocity through the four faces of the cell.

    Results:
    out_volume_raster -- Output groundwater volume balance residual raster"""
    ...

def DarcyVelocity(
    in_head_raster,
    in_porosity_raster,
    in_thickness_raster,
    in_transmissivity_raster,
    out_magnitude_raster,
):
    """DarcyVelocity_sa(in_head_raster, in_porosity_raster, in_thickness_raster, in_transmissivity_raster, out_magnitude_raster)

    Calculates the groundwater seepage velocity vector (direction and magnitude) for steady flow in an aquifer.

    Arguments:
    in_head_raster -- The input raster where each cell value represents the groundwater head elevation at that location.
    in_porosity_raster -- The input raster where each cell value represents the effective formation porosity at that location.
    in_thickness_raster -- The input raster where each cell value represents the saturated thickness at that location.
    in_transmissivity_raster -- The input raster where each cell value represents the formation transmissivity at that location.
    out_magnitude_raster -- The output flow direction raster.

    Results:
    out_direction_raster -- Output direction raster"""
    ...

def DeepLearningModelToEcd(
    in_deep_learning_model, in_classification_info_json, out_classifier_definition
):  # -> Any:
    """DeepLearningModelToEcd_sa(in_deep_learning_model, in_classification_info_json, out_classifier_definition)

    Converts a deep learning model to an Esri classifier definition file (.ecd).

    Arguments:
    in_deep_learning_model -- The binary model file generated by a deep learning package such as Google TensorFlow, Microsoft CNTK, or similar application.
    in_classification_info_json -- The class information JSON file. See the JSON file example above.
    out_classifier_definition -- The .ecd file that can be used in the Classify function and Classify Raster tool.
    """
    ...

def Dendrogram(
    in_signature_file, out_dendrogram_file, distance_calculation=..., line_width=...
):  # -> Any:
    """Dendrogram_sa(in_signature_file, out_dendrogram_file, {distance_calculation}, {line_width})

    Constructs a tree diagram (dendrogram) showing attribute distances between sequentially merged classes in a signature file.

    Arguments:
    in_signature_file -- Input signature file whose class signatures are used to produce a dendrogram.
    out_dendrogram_file -- The output dendrogram ASCII file.
    distance_calculation -- Specifies the manner in which the distances between classes in multidimensional attribute space are defined.
    line_width -- Sets the width of the dendrogram in number of characters on a line."""
    ...

def DeriveContinuousFlow(
    in_surface_raster,
    in_depressions_data=...,
    in_weight_raster=...,
    out_flow_direction_raster=...,
    flow_direction_type=...,
    force_flow=...,
):
    """DeriveContinuousFlow_sa(in_surface_raster, {in_depressions_data}, {in_weight_raster}, {out_flow_direction_raster}, {flow_direction_type}, {force_flow})

    Generates a raster of accumulated flow into each cell from an input surface raster with no prior sink or depression filling required.

    Arguments:
    in_surface_raster -- The input raster representing a continuous surface.
    in_depressions_data -- An optional dataset that defines real depressions.
    in_weight_raster -- An optional input raster dataset that defines the fraction of flow that contributes to flow accumulation at each cell.
    out_flow_direction_raster -- The output raster that shows the direction of flow at each cell using the D8 or Multiple Flow Direction (MFD) method.
    flow_direction_type -- Specifies the type of flow method that will be used when computing flow directions.
    force_flow -- Specifies whether edge cells will always flow outward or follow normal flow rules.

    Results:
    out_accumulation_raster -- Output flow accumulation raster"""
    ...

def DeriveStreamAsLine(
    in_surface_raster,
    out_stream_features,
    in_depressions_data=...,
    in_weight_raster=...,
    accumulation_threshold=...,
    stream_designation_method=...,
    simplify=...,
):  # -> Any:
    """DeriveStreamAsLine_sa(in_surface_raster, out_stream_features, {in_depressions_data}, {in_weight_raster}, {accumulation_threshold}, {stream_designation_method}, {simplify})

    Generates stream line features from an input surface raster with no prior sink or depression filling required.

    Arguments:
    in_surface_raster -- The input surface raster.
    out_stream_features -- The output feature class that will contain the identified streams.
    in_depressions_data -- An optional dataset that defines real depressions.
    in_weight_raster -- An optional input raster dataset that defines the fraction of flow that contributes to flow accumulation at each cell.
    accumulation_threshold -- The threshold for determining whether a given cell is part of a stream in terms of the total area that flows into such cell.
    stream_designation_method -- Specifies the unique value or order of the streams in the output attribute table.
    simplify -- Specifies whether the output stream lines will be smoothed into simpler shapes.
    """
    ...

def DeriveStreamAsRaster(
    in_surface_raster,
    in_depressions_data=...,
    in_weight_raster=...,
    accumulation_threshold=...,
    stream_designation_method=...,
    force_flow=...,
):
    """DeriveStreamAsRaster_sa(in_surface_raster, {in_depressions_data}, {in_weight_raster}, {accumulation_threshold}, {stream_designation_method}, {force_flow})

    Generates a stream raster from an input surface raster with no prior sink or depression filling required.

    Arguments:
    in_surface_raster -- The input surface raster.
    in_depressions_data -- An optional dataset that defines real depressions.
    in_weight_raster -- An optional input raster dataset that defines the fraction of flow that contributes to flow accumulation at each cell.
    accumulation_threshold -- The threshold for determining whether a given cell is part of a stream in terms of the total area that flows into such cell.
    stream_designation_method -- Specifies the unique or order of the streams in the output.
    force_flow -- Specifies whether edge cells will always flow outward or follow normal flow rules.

    Results:
    out_stream_raster -- Output stream raster"""
    ...

def Diff(in_raster_or_constant1, in_raster_or_constant2):
    """Diff_sa(in_raster_or_constant1, in_raster_or_constant2)

    Determines which values from the first input are logically different from the values of the second input on a cell-by-cell basis.

    Arguments:
    in_raster_or_constant1 -- The input to which the second input will be compared.
    in_raster_or_constant2 -- The input to which the first input will be compared.

    Results:
    out_raster -- Output raster"""
    ...

def DimensionalMovingStatistics(
    in_raster,
    dimension=...,
    backward_window=...,
    forward_window=...,
    nodata_handling=...,
    statistics_type=...,
    percentile_value=...,
    percentile_interpolation_type=...,
    circular_wrap_value=...,
):
    """DimensionalMovingStatistics_sa(in_raster, {dimension}, {backward_window}, {forward_window}, {nodata_handling}, {statistics_type}, {percentile_value}, {percentile_interpolation_type}, {circular_wrap_value})

    Calculates statistics over a moving window on multidimensional data along a specified dimension.

    Arguments:
    in_raster -- The input raster can only be a multidimensional raster in Cloud Raster Format (.crf file).
    dimension -- The name of the dimension along which the window will move.
    backward_window -- The value of how many slices before or above to be included in the defined window. The value must be a positive integer from 1 to 100. The default value is 1.
    forward_window -- The value of how many slices after or below to be included in the defined window. The value must be a positive integer from 1 to 100. The default value is 1.
    nodata_handling -- Specifies how NoData values will be handled by the statistic calculation.
    statistics_type -- Specifies the statistic type to be calculated.
    percentile_value -- The percentile value that will be calculated. The default is 90, for the 90th percentile.
    percentile_interpolation_type -- Specifies the method of interpolation that will be used when the percentile value falls between two cell values.
    circular_wrap_value -- The value that will be used to convert a linear value to the range of a given circular mean. Its value must be positive. The default value is 360 degrees.

    Results:
    out_raster -- Output Multidimensional Raster"""
    ...

def DistanceAccumulation(
    in_source_data,
    in_barrier_data=...,
    in_surface_raster=...,
    in_cost_raster=...,
    in_vertical_raster=...,
    vertical_factor=...,
    in_horizontal_raster=...,
    horizontal_factor=...,
    out_back_direction_raster=...,
    out_source_direction_raster=...,
    out_source_location_raster=...,
    source_initial_accumulation=...,
    source_maximum_accumulation=...,
    source_cost_multiplier=...,
    source_direction=...,
    distance_method=...,
):
    """DistanceAccumulation_sa(in_source_data, {in_barrier_data}, {in_surface_raster}, {in_cost_raster}, {in_vertical_raster}, {vertical_factor}, {in_horizontal_raster}, {horizontal_factor}, {out_back_direction_raster}, {out_source_direction_raster}, {out_source_location_raster}, {source_initial_accumulation}, {source_maximum_accumulation}, {source_cost_multiplier}, {source_direction}, {distance_method})

    Calculates accumulated distance for each cell to sources, allowing for straight-line distance, cost distance, and true surface distance, as well as vertical and horizontal cost factors.

    Arguments:
    in_source_data -- The input source locations.
    in_barrier_data -- The dataset that defines the barriers.
    in_surface_raster -- A raster defining the elevation values at each cell location.
    in_cost_raster -- A raster defining the impedance or cost to move planimetrically through each cell.
    in_vertical_raster -- A raster defining the z-values for each cell location.
    vertical_factor -- Specifies the relationship between the vertical cost factor and the vertical relative moving angle (VRMA).
    in_horizontal_raster -- A raster defining the horizontal direction at each cell.
    horizontal_factor -- Specifies the relationship between the horizontal cost factor and the horizontal relative moving angle (HRMA).
    out_back_direction_raster -- The back direction raster contains the calculated direction in degrees. The direction identifies the next cell along the shortest path back to the closest source while avoiding barriers.
    out_source_direction_raster -- The source direction raster identifies the direction of the least accumulated cost source cell as an azimuth in degrees.
    out_source_location_raster -- The source location raster is a multiband output. The first band contains a row index, and the second band contains a column index. These indexes identify the location of the source cell that is the least accumulated cost distance away.
    source_initial_accumulation -- The initial accumulative cost that will be used to begin the cost calculation.
    source_maximum_accumulation -- The maximum accumulation for the traveler for a source.
    source_cost_multiplier -- The multiplier that will be applied to the cost values.
    source_direction -- Specifies the direction of the traveler when applying horizontal and vertical factors.
    distance_method -- Specifies whether the distance will be calculated using a planar (flat earth) or a geodesic (ellipsoid) method.

    Results:
    out_distance_accumulation_raster -- Output distance accumulation raster"""
    ...

def DistanceAllocation(
    in_source_data,
    in_barrier_data=...,
    in_surface_raster=...,
    in_cost_raster=...,
    in_vertical_raster=...,
    vertical_factor=...,
    in_horizontal_raster=...,
    horizontal_factor=...,
    out_distance_accumulation_raster=...,
    out_back_direction_raster=...,
    out_source_direction_raster=...,
    out_source_location_raster=...,
    source_field=...,
    source_initial_accumulation=...,
    source_maximum_accumulation=...,
    source_cost_multiplier=...,
    source_direction=...,
    distance_method=...,
):
    """DistanceAllocation_sa(in_source_data, {in_barrier_data}, {in_surface_raster}, {in_cost_raster}, {in_vertical_raster}, {vertical_factor}, {in_horizontal_raster}, {horizontal_factor}, {out_distance_accumulation_raster}, {out_back_direction_raster}, {out_source_direction_raster}, {out_source_location_raster}, {source_field}, {source_initial_accumulation}, {source_maximum_accumulation}, {source_cost_multiplier}, {source_direction}, {distance_method})

    Calculates distance allocation for each cell to the provided sources based on straight-line distance, cost distance, and true surface distance, as well as vertical and horizontal cost factors.

    Arguments:
    in_source_data -- The input source locations.
    in_barrier_data -- The dataset that defines the barriers.
    in_surface_raster -- A raster defining the elevation values at each cell location.
    in_cost_raster -- A raster defining the impedance or cost to move planimetrically through each cell.
    in_vertical_raster -- A raster defining the z-values for each cell location.
    vertical_factor -- Specifies the relationship between the vertical cost factor and the vertical relative moving angle (VRMA).
    in_horizontal_raster -- A raster defining the horizontal direction at each cell.
    horizontal_factor -- Specifies the relationship between the horizontal cost factor and the horizontal relative moving angle (HRMA).
    out_distance_accumulation_raster -- The output distance raster.
    out_back_direction_raster -- The back direction raster contains the calculated direction in degrees. The direction identifies the next cell along the shortest path back to the closest source while avoiding barriers.
    out_source_direction_raster -- The source direction raster identifies the direction of the least accumulated cost source cell as an azimuth in degrees.
    out_source_location_raster -- The source location raster is a multiband output. The first band contains a row index, and the second band contains a column index. These indexes identify the location of the source cell that is the least accumulated cost distance away.
    source_field -- The field used to assign values to the source locations. It must be of integer type.
    source_initial_accumulation -- The initial accumulative cost that will be used to begin the cost calculation.
    source_maximum_accumulation -- The maximum accumulation for the traveler for a source.
    source_cost_multiplier -- The multiplier that will be applied to the cost values.
    source_direction -- Specifies the direction of the traveler when applying horizontal and vertical factors.
    distance_method -- Specifies whether the distance will be calculated using a planar (flat earth) or a geodesic (ellipsoid) method.

    Results:
    out_distance_allocation_raster -- Output distance allocation raster"""
    ...

def Divide(in_raster_or_constant1, in_raster_or_constant2):
    """Divide_sa(in_raster_or_constant1, in_raster_or_constant2)

    Divides the values of two rasters on a cell-by-cell basis.

    Arguments:
    in_raster_or_constant1 -- The input whose values will be divided by the second input.
    in_raster_or_constant2 -- The input whose values the first input are to be divided by.

    Results:
    out_raster -- Output raster"""
    ...

def EditSignatures(
    in_raster_bands,
    in_signature_file,
    in_signature_remap_file,
    out_signature_file,
    sample_interval=...,
):  # -> Any:
    """EditSignatures_sa([in_raster_band,...], in_signature_file, in_signature_remap_file, out_signature_file, {sample_interval})

    Edits and updates a signature file by merging, renumbering, and deleting class signatures.

    Arguments:
    in_raster_band -- The input raster bands for which to edit the signatures.
    in_signature_file -- Input signature file whose class signatures are to be edited.
    in_signature_remap_file -- Input ASCII remap table containing the class IDs to be merged, renumbered, or deleted.
    out_signature_file -- The output signature file.
    sample_interval -- The interval to be used for sampling."""
    ...

def EqualTo(in_raster_or_constant1, in_raster_or_constant2):
    """EqualTo_sa(in_raster_or_constant1, in_raster_or_constant2)

    Performs a Relational equal-to operation on two inputs on a cell-by-cell basis.

    Arguments:
    in_raster_or_constant1 -- The input that will be compared to for equality by the second input.
    in_raster_or_constant2 -- The input that will be compared from for equality by the first input.

    Results:
    out_raster -- Output raster"""
    ...

def EqualToFrequency(in_value_raster, in_rasters, process_as_multiband=...):
    """EqualToFrequency_sa(in_value_raster, [in_raster,...], {process_as_multiband})

    Evaluates on a cell-by-cell basis the number of times the values in a set of rasters are equal to another raster.

    Arguments:
    in_value_raster -- For each cell location in the input value raster, the number of occurrences (frequency) where a raster in the input list has an equal value is counted.
    in_raster -- The list of rasters that will be compared to the value raster.
    process_as_multiband -- Specifies how the input multiband raster bands will be processed.

    Results:
    out_raster -- Output raster"""
    ...

def EucAllocation(
    in_source_data,
    maximum_distance=...,
    in_value_raster=...,
    cell_size=...,
    source_field=...,
    out_distance_raster=...,
    out_direction_raster=...,
    distance_method=...,
    in_barrier_data=...,
    out_back_direction_raster=...,
):
    """EucAllocation_sa(in_source_data, {maximum_distance}, {in_value_raster}, {cell_size}, {source_field}, {out_distance_raster}, {out_direction_raster}, {distance_method}, {in_barrier_data}, {out_back_direction_raster})

    Calculates, for each cell, the nearest source based on Euclidean distance.

    Arguments:
    in_source_data -- The input source locations.
    maximum_distance -- The threshold that the accumulative distance values cannot exceed.
    in_value_raster -- The input integer raster that identifies the zone values that will be used for each input source location.
    cell_size -- The cell size of the output raster that will be created.
    source_field -- The field used to assign values to the source locations. It must be of integer type.
    out_distance_raster -- The output Euclidean distance raster.
    out_direction_raster -- The output Euclidean direction raster.
    distance_method -- Specifies whether the distance will be calculated using a planar (flat earth) or a geodesic (ellipsoid) method.
    in_barrier_data -- The dataset that defines the barriers.
    out_back_direction_raster -- The output Euclidean back direction raster.

    Results:
    out_allocation_raster -- Output allocation raster"""
    ...

def EucBackDirection(
    in_source_data,
    in_barrier_data=...,
    maximum_distance=...,
    cell_size=...,
    distance_method=...,
):
    """EucBackDirection_sa(in_source_data, {in_barrier_data}, {maximum_distance}, {cell_size}, {distance_method})

    Calculates, for each cell, the direction, in degrees, to the neighboring cell along the shortest path back to the closest source while avoiding barriers.

    Arguments:
    in_source_data -- The input source locations.
    in_barrier_data -- The dataset that defines the barriers.
    maximum_distance -- The threshold that the accumulative distance values cannot exceed.
    cell_size -- The cell size of the output raster that will be created.
    distance_method -- Specifies whether the distance will be calculated using a planar (flat earth) or a geodesic (ellipsoid) method.

    Results:
    out_back_direction_raster -- Output back direction raster"""
    ...

def EucDirection(
    in_source_data,
    maximum_distance=...,
    cell_size=...,
    out_distance_raster=...,
    distance_method=...,
    in_barrier_data=...,
    out_back_direction_raster=...,
):
    """EucDirection_sa(in_source_data, {maximum_distance}, {cell_size}, {out_distance_raster}, {distance_method}, {in_barrier_data}, {out_back_direction_raster})

    Calculates, for each cell, the direction, in degrees, to the nearest source.

    Arguments:
    in_source_data -- The input source locations.
    maximum_distance -- The threshold that the accumulative distance values cannot exceed.
    cell_size -- The cell size of the output raster that will be created.
    out_distance_raster -- The output Euclidean distance raster.
    distance_method -- Specifies whether the distance will be calculated using a planar (flat earth) or a geodesic (ellipsoid) method.
    in_barrier_data -- The dataset that defines the barriers.
    out_back_direction_raster -- The output Euclidean back direction raster.

    Results:
    out_direction_raster -- Output direction raster"""
    ...

def EucDistance(
    in_source_data,
    maximum_distance=...,
    cell_size=...,
    out_direction_raster=...,
    distance_method=...,
    in_barrier_data=...,
    out_back_direction_raster=...,
):
    """EucDistance_sa(in_source_data, {maximum_distance}, {cell_size}, {out_direction_raster}, {distance_method}, {in_barrier_data}, {out_back_direction_raster})

    Calculates, for each cell, the Euclidean distance to the closest source.

    Arguments:
    in_source_data -- The input source locations.
    maximum_distance -- The threshold that the accumulative distance values cannot exceed.
    cell_size -- The cell size of the output raster that will be created.
    out_direction_raster -- The output Euclidean direction raster.
    distance_method -- Specifies whether the distance will be calculated using a planar (flat earth) or a geodesic (ellipsoid) method.
    in_barrier_data -- The dataset that defines the barriers.
    out_back_direction_raster -- The output Euclidean back direction raster.

    Results:
    out_distance_raster -- Output distance raster"""
    ...

def Exp(in_raster_or_constant):
    """Exp_sa(in_raster_or_constant)

    Calculates the base e exponential of the cells in a raster.

    Arguments:
    in_raster_or_constant -- The input values for which to find the base e exponential.

    Results:
    out_raster -- Output raster"""
    ...

def Exp10(in_raster_or_constant):
    """Exp10_sa(in_raster_or_constant)

    Calculates the base 10 exponential of the cells in a raster.

    Arguments:
    in_raster_or_constant -- The input values for which to find the base 10 exponential.

    Results:
    out_raster -- Output raster"""
    ...

def Exp2(in_raster_or_constant):
    """Exp2_sa(in_raster_or_constant)

    Calculates the base 2 exponential of the cells in a raster.

    Arguments:
    in_raster_or_constant -- The input values for which to find the base 2 exponential.

    Results:
    out_raster -- Output raster"""
    ...

def Expand(in_raster, number_cells, zone_values, expand_method=...):
    """Expand_sa(in_raster, number_cells, [zone_value,...], {expand_method})

    Expands specified zones of a raster by a specified number of cells.

    Arguments:
    in_raster -- The input raster for which the identified zones are to be expanded
    number_cells -- The number of cells to expand each specified zone by.
    zone_value -- The list of zone values to expand.
    expand_method -- The method used to expand the selected zones.

    Results:
    out_raster -- Output raster"""
    ...

def ExportTrainingDataForDeepLearning(
    in_raster,
    out_folder,
    in_class_data=...,
    image_chip_format=...,
    tile_size_x=...,
    tile_size_y=...,
    stride_x=...,
    stride_y=...,
    output_nofeature_tiles=...,
    metadata_format=...,
    start_index=...,
    class_value_field=...,
    buffer_radius=...,
    in_mask_polygons=...,
    rotation_angle=...,
    reference_system=...,
    processing_mode=...,
    blacken_around_feature=...,
    crop_mode=...,
    in_raster2=...,
    in_instance_data=...,
    instance_class_value_field=...,
    min_polygon_overlap_ratio=...,
):  # -> Any:
    """ExportTrainingDataForDeepLearning_sa(in_raster, out_folder, {in_class_data}, {image_chip_format}, {tile_size_x}, {tile_size_y}, {stride_x}, {stride_y}, {output_nofeature_tiles}, {metadata_format}, {start_index}, {class_value_field}, {buffer_radius}, {in_mask_polygons}, {rotation_angle}, {reference_system}, {processing_mode}, {blacken_around_feature}, {crop_mode}, {in_raster2}, {in_instance_data}, {instance_class_value_field}, {min_polygon_overlap_ratio})

    Converts labeled vector or raster data into deep learning training datasets using a remote sensing image. The output will be a folder of image chips and a folder of metadata files in the specified format.

    Arguments:
    in_raster -- The input source imagery, typically multispectral imagery.
    out_folder -- The folder where the output image chips and metadata will be stored.
    in_class_data -- The training sample data in either vector or raster form. Vector inputs should follow the training sample format generated using the Training Samples Manager pane. Raster inputs should follow a classified raster format generated by the Classify Raster tool.
    image_chip_format -- Specifies the raster format that will be used for the image chip outputs.
    tile_size_x -- The size of the image chips for the x dimension.
    tile_size_y -- The size of the image chips for the y dimension.
    stride_x -- The distance to move in the x direction when creating the next image chips.
    stride_y -- The distance to move in the y direction when creating the next image chips.
    output_nofeature_tiles -- Specifies whether image chips that do not capture training samples will be exported.
    metadata_format -- Specifies the format that will be used for the output metadata labels.
    start_index -- This parameter has been deprecated.
    class_value_field -- The field that contains the class values. If no field is specified, the system searches for a value or classvalue field. If the feature does not contain a class field, the system determines that all records belong to one class.
    buffer_radius -- The radius of a buffer around each training sample that will be used to delineate a training sample area. This allows you to create circular polygon training samples from points.
    in_mask_polygons -- A polygon feature class that delineates the area where image chips will be created.
    rotation_angle -- The rotation angle that will be used to generate additional image chips.
    reference_system -- Specifies the type of reference system that will be used to interpret the input image. The reference system specified must match the reference system used to train the deep learning model.
    processing_mode -- Specifies how all raster items in a mosaic dataset or an image service will be processed. This parameter is applied when the input raster is a mosaic dataset or an image service.
    blacken_around_feature -- Specifies whether the pixels around each object or feature in each image tile will be masked out.
    crop_mode -- Specifies whether the exported tiles will be cropped so that they are all the same size.
    in_raster2 -- An additional input imagery source that will be used for image translation methods.
    in_instance_data -- The training sample data collected that contains classes for instance segmentation.
    instance_class_value_field -- The field that contains the class values for instance segmentation. If no field is specified, the tool will use a value or class value field, if one is present. If the feature does not contain a class field, the tool will determine that all records belong to one class.
    min_polygon_overlap_ratio -- The minimum overlap percentage for a feature to be included in the training data. If the percentage overlap is less than the value specified, the feature will be excluded from the training chip, and will not be added to the label file.
    """
    ...

def ExtractByAttributes(in_raster, where_clause):
    """ExtractByAttributes_sa(in_raster, where_clause)

    Extracts the cells of a raster based on a logical query.

    Arguments:
    in_raster -- The input raster from which cells will be extracted.
    where_clause -- A logical expression that selects a subset of raster cells.

    Results:
    out_raster -- Output raster"""
    ...

def ExtractByCircle(in_raster, center_point, radius, extraction_area=...):
    """ExtractByCircle_sa(in_raster, center_point, radius, {extraction_area})

    Extracts the cells of a raster based on a circle by specifying the circle's center and radius.

    Arguments:
    in_raster -- The input raster from which cells will be extracted.
    center_point -- The center coordinate (x,y) of the circle defining the area to be extracted.
    radius -- The radius of the circle defining the area to be extracted.
    extraction_area -- Specifies whether cells inside or outside the input circle will be selected and written to the output raster.

    Results:
    out_raster -- Output raster"""
    ...

def ExtractByMask(in_raster, in_mask_data, extraction_area=..., analysis_extent=...):
    """ExtractByMask_sa(in_raster, in_mask_data, {extraction_area}, {analysis_extent})

    Extracts the cells of a raster that correspond to the areas defined by a mask.

    Arguments:
    in_raster -- The input raster from which cells will be extracted.
    in_mask_data -- The input mask data defining the cell locations to extract.
    extraction_area -- Specifies whether cells inside or outside the locations defined by the input mask will be selected and written to the output raster.
    analysis_extent -- The extent that defines the area to be extracted.

    Results:
    out_raster -- Output raster"""
    ...

def ExtractByPoints(in_raster, points, extraction_area=...):
    """ExtractByPoints_sa(in_raster, [point,...], {extraction_area})

    Extracts the cells of a raster based on a set of coordinate points.

    Arguments:
    in_raster -- The input raster from which cells will be extracted.
    point -- The points where values will be extracted from the raster.
    extraction_area -- Identifies whether to extract cells based on the specified point locations (inside) or outside the point locations (outside) .

    Results:
    out_raster -- Output raster"""
    ...

def ExtractByPolygon(in_raster, polygons, extraction_area=...):
    """ExtractByPolygon_sa(in_raster, [polygon,...], {extraction_area})

    Extracts the cells of a raster based on a polygon by specifying the polygon's vertices.

    Arguments:
    in_raster -- The input raster from which cells will be extracted.
    polygon -- A polygon (or polygons) defined by a series of vertices (x,y point coordinates) that identify the area of the input raster to be extracted. The last coordinate of a polygon part should be the same as the first in order to close a polygon.
    extraction_area -- Identifies whether to extract cells inside or outside the input polygon.

    Results:
    out_raster -- Output raster"""
    ...

def ExtractByRectangle(in_raster, extent, extraction_area=...):
    """ExtractByRectangle_sa(in_raster, extent, {extraction_area})

    Extracts the cells of a raster based on a rectangle by specifying the rectangle's extent.

    Arguments:
    in_raster -- The input raster from which cells will be extracted.
    extent -- A rectangle that defines the area to be extracted.
    extraction_area -- Specifies whether cells inside or outside the input rectangle will be selected and written to the output raster.

    Results:
    out_raster -- Output raster"""
    ...

def ExtractMultiValuesToPoints(
    in_point_features, in_rasters, bilinear_interpolate_values=...
):  # -> Any:
    """ExtractMultiValuesToPoints_sa(in_point_features, in_rasters, {bilinear_interpolate_values})

    Extracts cell values at locations specified in a point feature class from one or more rasters and records the values to the attribute table of the point feature class.

    Arguments:
    in_point_features -- The input point features to which raster values will be added.
    in_rasters -- The input raster (or rasters) values that will be extracted based on the input point feature location.
    bilinear_interpolate_values -- Specifies whether interpolation will be used."""
    ...

def ExtractValuesToPoints(
    in_point_features,
    in_raster,
    out_point_features,
    interpolate_values=...,
    add_attributes=...,
):  # -> Any:
    """ExtractValuesToPoints_sa(in_point_features, in_raster, out_point_features, {interpolate_values}, {add_attributes})

    Extracts the cell values of a raster based on a set of point features and records the values in the attribute table of an output feature class.

    Arguments:
    in_point_features -- The input point features defining the locations from which you want to extract the raster cell values.
    in_raster -- The raster dataset whose values will be extracted.
    out_point_features -- The output point feature dataset containing the extracted raster values.
    interpolate_values -- Specifies whether interpolation will be used.
    add_attributes -- Determines if the raster attributes are written to the output point feature dataset.
    """
    ...

def Fill(in_surface_raster, z_limit=...):
    """Fill_sa(in_surface_raster, {z_limit})

    Fills sinks in a surface raster to remove small imperfections in the data.

    Arguments:
    in_surface_raster -- The input raster representing a continuous surface.
    z_limit -- Maximum elevation difference between a sink and its pour point to be filled.

    Results:
    out_surface_raster -- Output surface raster"""
    ...

def Filter(in_raster, filter_type=..., ignore_nodata=...):
    """Filter_sa(in_raster, {filter_type}, {ignore_nodata})

    Performs either a smoothing (Low pass) or edge-enhancing (High pass) filter on a raster.

    Arguments:
    in_raster -- The input raster on which to perform the filter operation.
    filter_type -- The type of filter operation to perform.
    ignore_nodata -- Denotes whether NoData values are ignored by the filter calculation.

    Results:
    out_raster -- Output raster"""
    ...

def Float(in_raster_or_constant):
    """Float_sa(in_raster_or_constant)

    Converts each cell value of a raster into a floating-point representation.

    Arguments:
    in_raster_or_constant -- The input raster to be converted to floating point.

    Results:
    out_raster -- Output raster"""
    ...

def FlowAccumulation(
    in_flow_direction_raster,
    in_weight_raster=...,
    data_type=...,
    flow_direction_type=...,
):
    """FlowAccumulation_sa(in_flow_direction_raster, {in_weight_raster}, {data_type}, {flow_direction_type})

    Creates a raster of accumulated flow into each cell. A weight factor can optionally be applied.

    Arguments:
    in_flow_direction_raster -- The input raster that shows the direction of flow out of each cell.
    in_weight_raster -- An optional input raster for applying a weight to each cell.
    data_type -- The output accumulation raster can be integer, floating point, or double type.
    flow_direction_type -- Specifies the input flow direction raster type.

    Results:
    out_accumulation_raster -- Output accumulation raster"""
    ...

def FlowDirection(
    in_surface_raster, force_flow=..., out_drop_raster=..., flow_direction_type=...
):
    """FlowDirection_sa(in_surface_raster, {force_flow}, {out_drop_raster}, {flow_direction_type})

    Creates a raster of flow direction from each cell to its downslope neighbor, or neighbors, using the D8, Multiple Flow Direction (MFD), or D-Infinity (DINF) method.

    Arguments:
    in_surface_raster -- The input raster representing a continuous surface.
    force_flow -- Specifies whether edge cells will always flow outward or follow normal flow rules.
    out_drop_raster -- An optional output drop raster.
    flow_direction_type -- Specifies the type of flow method that will be used when computing flow directions.

    Results:
    out_flow_direction_raster -- Output flow direction raster"""
    ...

def FlowDistance(
    in_stream_raster,
    in_surface_raster,
    in_flow_direction_raster=...,
    distance_type=...,
    flow_direction_type=...,
    statistics_type=...,
):
    """FlowDistance_sa(in_stream_raster, in_surface_raster, {in_flow_direction_raster}, {distance_type}, {flow_direction_type}, {statistics_type})

    Computes, for each cell, the horizontal or vertical component of downslope distance, following the flow paths, to cells on a stream into which they flow. In case of multiple flow paths, minimum, weighted mean, or maximum flow distance can be computed.

    Arguments:
    in_stream_raster -- An input stream raster that represents a linear stream network.
    in_surface_raster -- The input raster representing a continuous surface.
    in_flow_direction_raster -- The input raster that shows the direction of flow out of each cell.
    distance_type -- Determines if the vertical or horizontal component of flow distance is calculated.
    flow_direction_type -- Specifies the input flow direction raster type.
    statistics_type -- Determines the statistics type used to compute flow distance over multiple flow paths. If there is only a single flow path from each cell to a cell on the stream, all statistics types produce the same result.

    Results:
    out_raster -- Output raster"""
    ...

def FlowLength(
    in_flow_direction_raster, direction_measurement=..., in_weight_raster=...
):
    """FlowLength_sa(in_flow_direction_raster, {direction_measurement}, {in_weight_raster})

    Calculates the upstream or downstream distance, or weighted distance, along the flow path for each cell.

    Arguments:
    in_flow_direction_raster -- The input raster that shows the direction of flow out of each cell.
    direction_measurement -- The direction of measurement along the flow path.
    in_weight_raster -- An optional input raster for applying a weight to each cell.

    Results:
    out_raster -- Output raster"""
    ...

def FocalFlow(in_surface_raster, threshold_value=...):
    """FocalFlow_sa(in_surface_raster, {threshold_value})

    Determines the flow of the values in the input raster within each cell's immediate neighborhood.

    Arguments:
    in_surface_raster -- The input surface raster for which to calculate the focal flow.
    threshold_value -- Defines a value that constitutes the threshold, which must be equaled or exceeded before flow can occur.

    Results:
    out_raster -- Output raster"""
    ...

def FocalStatistics(
    in_raster,
    neighborhood=...,
    statistics_type=...,
    ignore_nodata=...,
    percentile_value=...,
):
    """FocalStatistics_sa(in_raster, {neighborhood}, {statistics_type}, {ignore_nodata}, {percentile_value})

    Calculates for each input cell location a statistic of the values within a specified neighborhood around it.

    Arguments:
    in_raster -- The raster for which the focal statistics for each input cell will be calculated.
    neighborhood -- The cells surrounding a processing cell that will be used in the statistic calculation. There are several predefined neighborhood types to choose from, or a custom kernel can be defined.
    statistics_type -- Specifies the statistic type to be calculated.
    ignore_nodata -- Specifies whether NoData values will be ignored by the statistic calculation.
    percentile_value -- The percentile value that will be calculated. The default is 90, for the 90th percentile.

    Results:
    out_raster -- Output raster"""
    ...

def FuzzyMembership(in_raster, fuzzy_function=..., hedge=...):
    """FuzzyMembership_sa(in_raster, {fuzzy_function}, {hedge})

    Transforms  the input raster   into a 0 to 1 scale, indicating the strength of a membership in a set, based on a specified fuzzification algorithm.

    Arguments:
    in_raster -- The input raster whose values will be scaled from 0 to 1.
    fuzzy_function -- Specifies the algorithm used in fuzzification of the input raster.
    hedge -- Defining a hedge increases or decreases the fuzzy membership values which modify the meaning of a fuzzy set. Hedges are useful to help in controlling the criteria or important attributes.

    Results:
    out_raster -- Output raster"""
    ...

def FuzzyOverlay(in_rasters, overlay_type=..., gamma=...):
    """FuzzyOverlay_sa([in_raster,...], {overlay_type}, {gamma})

    Combine fuzzy membership rasters data together, based on selected overlay type.

    Arguments:
    in_raster -- A list of input membership rasters to be combined in the overlay.
    overlay_type -- Specifies the method used to combine two or more membership data.
    gamma -- The gamma value to be used. This is only available when the Overlay type is set to Gamma.

    Results:
    out_raster -- Output raster"""
    ...

def GenerateMultidimensionalAnomaly(
    in_multidimensional_raster,
    variables=...,
    method=...,
    calculation_interval=...,
    ignore_nodata=...,
    reference_mean_raster=...,
):
    """GenerateMultidimensionalAnomaly_sa(in_multidimensional_raster, {[variable,...]}, {method}, {calculation_interval}, {ignore_nodata}, {reference_mean_raster})

    Computes the anomaly for each slice in an existing multidimensional raster to generate a new multidimensional raster.

    Arguments:
    in_multidimensional_raster -- The input multidimensional raster dataset.
    variable -- The variable or variables for which anomalies will be calculated. If no variable is specified, all variables with a time dimension will be analyzed.
    method -- Specifies the method that will be used to calculate the anomaly.
    calculation_interval -- Specifies the temporal interval that will be used to calculate the mean.
    ignore_nodata -- Specifies whether NoData values will be ignored in the analysis.
    reference_mean_raster -- The reference raster dataset that contains a previously calculated mean for each pixel. The anomalies will be calculated in comparison to this mean.

    Results:
    out_multidimensional_raster -- Output Multidimensional Raster"""
    ...

def GenerateTrainingSamplesFromSeedPoints(
    in_class_data,
    in_seed_points,
    out_training_feature_class,
    min_sample_area=...,
    max_sample_radius=...,
):  # -> Any:
    """GenerateTrainingSamplesFromSeedPoints_sa(in_class_data, in_seed_points, out_training_feature_class, {min_sample_area}, {max_sample_radius})

    Generates training samples from seed points, such as accuracy assessment points or training sample points. A typical use case is generating training samples from an existing source, such as a thematic raster or a feature class.

    Arguments:
    in_class_data -- The data source that labels the training samples.
    in_seed_points -- A point shapefile or feature class to provide the centers of training sample polygons.
    out_training_feature_class -- The output training sample feature class in the format that can be used in training tools, including shapefiles. The output feature class can be either a polygon feature class or a point feature class.
    min_sample_area -- The minimum area needed for each training sample, in square meters. The minimum value must be greater than or equal to 0.
    max_sample_radius -- The longest distance (in meters) from any point within the training sample to its center seed point. If set to 0, the output training sample will be points instead of polygons. The minimum value must be greater than or equal to 0.
    """
    ...

def GeomorphonLandforms(
    in_surface_raster,
    out_geomorphons_raster=...,
    angle_threshold=...,
    distance_units=...,
    search_distance=...,
    skip_distance=...,
    z_unit=...,
):
    """GeomorphonLandforms_sa(in_surface_raster, {out_geomorphons_raster}, {angle_threshold}, {distance_units}, {search_distance}, {skip_distance}, {z_unit})

    Calculates the geomorphon pattern of each cell of an input surface raster and classifies calculated geomorphons into common landform types.

    Arguments:
    in_surface_raster -- The input surface raster.
    out_geomorphons_raster -- Each geomorphon pattern will be assigned a unique identifier, which is stored for each cell in the output geomorphons raster.
    angle_threshold -- The angle threshold (in degrees) below which the target cell will be classified as flat.
    distance_units -- Specifies the distance unit that will be used for the Search distance and Skip distance parameters.
    search_distance -- The distance away from the target cell that defines the radius of the area that will be used to identify the geomorphon pattern.
    skip_distance -- The distance away from the target cell where the analysis area starts. Neighboring cells that fall within this distance will be skipped and won't contribute to identification of the geomorphon pattern.
    z_unit -- Specifies the linear unit that will be used for vertical z-values.

    Results:
    out_landforms_raster -- Output landforms raster"""
    ...

def GreaterThan(in_raster_or_constant1, in_raster_or_constant2):
    """GreaterThan_sa(in_raster_or_constant1, in_raster_or_constant2)

    Performs a Relational greater-than operation on two inputs on a cell-by-cell basis.

    Arguments:
    in_raster_or_constant1 -- The input being tested to determine if it is greater than the second input.
    in_raster_or_constant2 -- The input against which the first input is tested to be greater than.

    Results:
    out_raster -- Output raster"""
    ...

def GreaterThanEqual(in_raster_or_constant1, in_raster_or_constant2):
    """GreaterThanEqual_sa(in_raster_or_constant1, in_raster_or_constant2)

    Performs a Relational greater-than-or-equal-to operation on two inputs on a cell-by-cell basis.

    Arguments:
    in_raster_or_constant1 -- The input being tested to determine if it is greater than or equal to the second input.
    in_raster_or_constant2 -- The input against which the first input is tested to be greater than or equal to.

    Results:
    out_raster -- Output raster"""
    ...

def GreaterThanFrequency(in_value_raster, in_rasters, process_as_multiband=...):
    """GreaterThanFrequency_sa(in_value_raster, [in_raster,...], {process_as_multiband})

    Evaluates on a cell-by-cell basis the number of times a set of rasters is greater than another raster.

    Arguments:
    in_value_raster -- For each cell location in the input value raster, the number of occurrences (frequency) where a raster in the input list has a greater value is counted.
    in_raster -- The list of rasters that will be compared to the value raster.
    process_as_multiband -- Specifies how the input multiband raster bands will be processed.

    Results:
    out_raster -- Output raster"""
    ...

def HighestPosition(in_rasters_or_constants):
    """HighestPosition_sa([in_rasters_or_constant,...])

    Determines on a cell-by-cell basis the position of the raster with the maximum value in a set of rasters.

    Arguments:
    in_rasters_or_constant -- The list of input rasters for which the position of the input with the highest value will be determined.

    Results:
    out_raster -- Output raster"""
    ...

def Hillshade(in_raster, azimuth=..., altitude=..., model_shadows=..., z_factor=...):
    """Hillshade_sa(in_raster, {azimuth}, {altitude}, {model_shadows}, {z_factor})

    Creates a shaded relief from a surface raster by considering the illumination source angle and shadows.

    Arguments:
    in_raster -- The input surface raster.
    azimuth -- Azimuth angle of the light source.
    altitude -- Altitude angle of the light source above the horizon.
    model_shadows -- Type of shaded relief to be generated.
    z_factor -- The number of ground x,y units in one surface z-unit.

    Results:
    out_raster -- Output raster"""
    ...

def Idw(
    in_point_features,
    z_field,
    cell_size=...,
    power=...,
    search_radius=...,
    in_barrier_polyline_features=...,
):
    """Idw_sa(in_point_features, z_field, {cell_size}, {power}, {search_radius}, {in_barrier_polyline_features})

    Interpolates a raster surface from points using an inverse distance weighted (IDW) technique.

    Arguments:
    in_point_features -- The input point features containing the z-values to be interpolated into a surface raster.
    z_field -- The field that holds a height or magnitude value for each point.
    cell_size -- The cell size of the output raster that will be created.
    power -- The exponent of distance.
    search_radius -- Defines which of the input points will be used to interpolate the value for each cell in the output raster.
    in_barrier_polyline_features -- Polyline features to be used as a break or limit in searching for the input sample points.

    Results:
    out_raster -- Output raster"""
    ...

def InList(in_raster_or_constant, in_raster_or_constants, process_as_multiband=...):
    """InList_sa(in_raster_or_constant, [in_raster_or_constant,...], {process_as_multiband})

    Determines which values from the first input are contained in a set of other inputs, on a cell-by-cell basis.

    Arguments:
    in_raster_or_constant -- The input that defines the value that will be looked for in a list of rasters on a cell-by-cell basis.
    in_raster_or_constant -- A list of input rasters that the first input will be evaluated against. For each location, if the cell value from the first input exists in any of the other rasters, that value will be assigned to the output raster. If the value does not exist in any of the other rasters, the output value at that location will be NoData.
    process_as_multiband -- Specifies how the input multiband raster bands will be processed.

    Results:
    out_raster -- Output raster"""
    ...

def InspectTrainingSamples(
    in_raster,
    in_training_features,
    in_classifier_definition,
    out_training_feature_class,
    in_additional_raster=...,
):
    """InspectTrainingSamples_sa(in_raster, in_training_features, in_classifier_definition, out_training_feature_class, {in_additional_raster})

    Estimates the accuracy of individual training samples. The cross validation accuracy is computed using the previously generated classification training result in an .ecd file and the training samples. Outputs include a raster dataset containing the misclassified class values and a training sample dataset with the accuracy score for each training sample.

    Arguments:
    in_raster -- The input raster to be classified.
    in_training_features -- A training sample feature class created in the Training Samples Manager pane.
    in_classifier_definition -- The .ecd output classifier file from any of the train classifier tools. The .ecd file is a JSON file that contains attribute information, statistics, or other information needed for the classifier.
    out_training_feature_class -- The output individual training samples saved as a feature class. The associated attribute table contains an addition field listing the accuracy score.
    in_additional_raster -- Ancillary raster datasets, such as a multispectral image or a DEM, will be incorporated to generate attributes and other required information for the classifier. This raster is necessary when calculating attributes such as mean or standard deviation. This parameter is optional.

    Results:
    out_misclassified_raster -- Output Misclassified Raster"""
    ...

def Int(in_raster_or_constant):
    """Int_sa(in_raster_or_constant)

    Converts each cell value of a raster to an integer by truncation.

    Arguments:
    in_raster_or_constant -- The input raster to be converted to integer.

    Results:
    out_raster -- Output raster"""
    ...

def InterpolateShape(
    in_surface,
    in_feature_class,
    out_feature_class,
    sample_distance=...,
    z_factor=...,
    method=...,
    vertices_only=...,
    pyramid_level_resolution=...,
    preserve_features=...,
):  # -> Any:
    """InterpolateShape_sa(in_surface, in_feature_class, out_feature_class, {sample_distance}, {z_factor}, {method}, {vertices_only}, {pyramid_level_resolution}, {preserve_features})

    Creates 3D features by interpolating z-values from a surface.

    Arguments:
    in_surface -- The surface that will be used for interpolating z-values.
    in_feature_class -- The input features to process.
    out_feature_class -- The feature class that will be produced.
    sample_distance -- The spacing at which z-values will be interpolated. By default, this is a raster dataset's cell size or a triangulated surface's natural densification.
    z_factor -- The factor by which z-values will be multiplied. This is typically used to convert z linear units to match x,y linear units. The default is 1, which leaves elevation values unchanged. This parameter is not available if the spatial reference of the input surface has a z datum with a specified linear unit.
    method -- Specifies the interpolation method that will be used to determine elevation values for the output features. The available options depend on the surface type.
    vertices_only -- Specifies whether the interpolation will only occur along the vertices of an input feature, ignoring the sample distance option. When the input surface is a raster and the nearest neighbor interpolation method is selected, the z-values can only be interpolated at the feature vertices.
    pyramid_level_resolution -- The z-tolerance or window-size resolution of the terrain pyramid level that will be used. The default is 0, or full resolution.
    preserve_features -- Specifies whether features with one or more vertices that fall outside the raster's data area will be retained in the output. This parameter is only available when the input surface is a raster and the nearest neighbor interpolation method is used.
    """
    ...

def IsNull(in_raster):
    """IsNull_sa(in_raster)

    Determines which values from the input raster are NoData on a cell-by-cell basis.

    Arguments:
    in_raster -- The input raster being tested to identify the cells that are NoData (null).

    Results:
    out_raster -- Output raster"""
    ...

def IsoCluster(
    in_raster_bands,
    out_signature_file,
    number_classes,
    number_iterations=...,
    min_class_size=...,
    sample_interval=...,
):  # -> Any:
    """IsoCluster_sa([in_raster_band,...], out_signature_file, number_classes, {number_iterations}, {min_class_size}, {sample_interval})

    Uses an isodata clustering algorithm to determine the characteristics of the natural groupings of cells in multidimensional attribute space and stores the results in an output ASCII signature file.

    Arguments:
    in_raster_band -- The input raster bands.
    out_signature_file -- The output signature file.
    number_classes -- Number of classes into which to group the cells.
    number_iterations -- Number of iterations of the clustering process to run.
    min_class_size -- Minimum number of cells in a valid class.
    sample_interval -- The interval to be used for sampling."""
    ...

def IsoClusterUnsupervisedClassification(
    in_raster_bands,
    Number_of_classes,
    Minimum_class_size=...,
    Sample_interval=...,
    out_signature_file=...,
):
    """IsoClusterUnsupervisedClassification_sa([in_raster_band,...], Number_of_classes, {Minimum_class_size}, {Sample_interval}, {out_signature_file})

    Performs unsupervised classification on a series of input raster bands using the Iso Cluster and Maximum Likelihood Classification tools.

    Arguments:
    in_raster_band -- The input raster bands.
    Number_of_classes -- Number of classes into which to group the cells.
    Minimum_class_size -- Minimum number of cells in a valid class.
    Sample_interval -- The interval to be used for sampling.
    out_signature_file -- The output signature file.

    Results:
    Output_classified_raster -- Output classified raster"""
    ...

def KernelDensity(
    in_features,
    population_field,
    cell_size=...,
    search_radius=...,
    area_unit_scale_factor=...,
    out_cell_values=...,
    method=...,
    in_barriers=...,
):
    """KernelDensity_sa(in_features, population_field, {cell_size}, {search_radius}, {area_unit_scale_factor}, {out_cell_values}, {method}, {in_barriers})

    Calculates a magnitude-per-unit area from point or polyline features using a kernel function to fit a smoothly tapered surface to each point or polyline. A barrier can be used to alter the influence of a feature while calculating kernel density.

    Arguments:
    in_features -- The input features (point or line) for which to calculate the density.
    population_field -- The field denoting population values for each feature. The population field is the count or quantity to be spread across the landscape to create a continuous surface.
    cell_size -- The cell size of the output raster that will be created.
    search_radius -- The search radius within which density will be calculated. Units are based on the linear unit of the projection of the output spatial reference.
    area_unit_scale_factor -- The area units of the output density values.
    out_cell_values -- Specifies what the values in the output raster represent.
    method -- Specifies whether the flat earth (planar) or the shortest path on a spheroid (geodesic) method will be used.
    in_barriers -- The dataset that defines the barriers.

    Results:
    out_raster -- Output raster"""
    ...

def Kriging(
    in_point_features,
    z_field,
    kriging_model,
    cell_size=...,
    search_radius=...,
    out_variance_prediction_raster=...,
):
    """Kriging_sa(in_point_features, z_field, kriging_model, {cell_size}, {search_radius}, {out_variance_prediction_raster})

    Interpolates a raster surface from points using kriging.

    Arguments:
    in_point_features -- The input point features containing the z-values to be interpolated into a surface raster.
    z_field -- The field that holds a height or magnitude value for each point.
    kriging_model -- The Semivariogram model to be used. There are two methods for kriging: Ordinary and Universal.
    cell_size -- The cell size of the output raster that will be created.
    search_radius -- Defines which of the input points will be used to interpolate the value for each cell in the output raster.
    out_variance_prediction_raster -- Optional output raster where each cell contains the predicted variance values for that location.

    Results:
    out_surface_raster -- Output surface raster"""
    ...

def LeastCostCorridor(
    in_accumulative_cost_distance_raster1,
    in_back_direction_raster1,
    in_accumulative_cost_distance_raster2,
    in_back_direction_raster2,
    threshold_method=...,
    threshold=...,
):
    """LeastCostCorridor_sa(in_accumulative_cost_distance_raster1, in_back_direction_raster1, in_accumulative_cost_distance_raster2, in_back_direction_raster2, {threshold_method}, {threshold})

    Calculates the sum of two accumulative cost distance rasters with the option to apply a threshold based on percentage or accumulative cost.

    Arguments:
    in_accumulative_cost_distance_raster1 -- The input raster representing accumulative cost distance from the first source.
    in_back_direction_raster1 -- The input back direction raster from the first source. The units are degrees identifying the next cell along the least-cost path back to the first source.
    in_accumulative_cost_distance_raster2 -- The input raster representing accumulative cost distance from the second source.
    in_back_direction_raster2 -- The input back direction raster from the second source. The units are degrees identifying the next cell along the least-cost path back to the second source.
    threshold_method -- Specifies how the threshold will be defined.
    threshold -- A percent or accumulative cost threshold that will determine whether a given cell will be included in the output corridor raster.

    Results:
    out_raster -- Output raster"""
    ...

def LessThan(in_raster_or_constant1, in_raster_or_constant2):
    """LessThan_sa(in_raster_or_constant1, in_raster_or_constant2)

    Performs a Relational less-than operation on two inputs on a cell-by-cell basis.

    Arguments:
    in_raster_or_constant1 -- The input being tested to determine if it is less than the second input.
    in_raster_or_constant2 -- The input against which the first input is tested to be less than.

    Results:
    out_raster -- Output raster"""
    ...

def LessThanEqual(in_raster_or_constant1, in_raster_or_constant2):
    """LessThanEqual_sa(in_raster_or_constant1, in_raster_or_constant2)

    Performs a Relational less-than-or-equal-to operation on two inputs on a cell-by-cell basis.

    Arguments:
    in_raster_or_constant1 -- The input being tested to determine if it is less than or equal to the second input.
    in_raster_or_constant2 -- The input against which the first input is tested to be less than or equal to.

    Results:
    out_raster -- Output raster"""
    ...

def LessThanFrequency(in_value_raster, in_rasters, process_as_multiband=...):
    """LessThanFrequency_sa(in_value_raster, [in_raster,...], {process_as_multiband})

    Evaluates on a cell-by-cell basis the number of times a set of rasters is less than another raster.

    Arguments:
    in_value_raster -- For each cell location in the input value raster, the number of occurrences (frequency) where a raster in the input list has a lesser value is counted.
    in_raster -- The list of rasters that will be compared to the value raster.
    process_as_multiband -- Specifies how the input multiband raster bands will be processed.

    Results:
    out_raster -- Output raster"""
    ...

def LinearSpectralUnmixing(in_raster, in_spectral_profile_file, value_option=...):
    """LinearSpectralUnmixing_sa(in_raster, in_spectral_profile_file, {[value_option,...]})

    Performs subpixel classification and calculates the fractional abundance of different land-cover types for individual pixels.

    Arguments:
    in_raster -- The input raster dataset.
    in_spectral_profile_file -- The spectral information for the different land-cover classes.
    value_option -- Specifies how the output pixel values will be defined.

    Results:
    out_raster -- Output Raster"""
    ...

def LineDensity(
    in_polyline_features,
    population_field,
    cell_size=...,
    search_radius=...,
    area_unit_scale_factor=...,
):
    """LineDensity_sa(in_polyline_features, population_field, {cell_size}, {search_radius}, {area_unit_scale_factor})

    Calculates a magnitude-per-unit area from polyline features that fall within a radius around each cell.

    Arguments:
    in_polyline_features -- The input line features for which to calculate the density.
    population_field -- Numeric field denoting population values (the number of times the line should be counted) for each polyline.
    cell_size -- The cell size of the output raster that will be created.
    search_radius -- The search radius within which density will be calculated. Units are based on the linear unit of the projection of the output spatial reference.
    area_unit_scale_factor -- The area units of the output density values.

    Results:
    out_raster -- Output raster"""
    ...

def LineStatistics(
    in_polyline_features, field, cell_size=..., search_radius=..., statistics_type=...
):
    """LineStatistics_sa(in_polyline_features, field, {cell_size}, {search_radius}, {statistics_type})

    Calculates a statistic on the attributes of lines in a circular neighborhood around each output cell.

    Arguments:
    in_polyline_features -- The input lines to use in the neighborhood operation.
    field -- The field for which the specified statistic will be calculated. It can be any numeric field of the input line features.
    cell_size -- The cell size of the output raster that will be created.
    search_radius -- The search radius that will be used to calculate the statistic within, in map units.
    statistics_type -- Specifies the statistic type to be calculated.

    Results:
    out_raster -- Output raster"""
    ...

def Ln(in_raster_or_constant):
    """Ln_sa(in_raster_or_constant)

    Calculates the natural logarithm (base e) of cells in a raster.

    Arguments:
    in_raster_or_constant -- Input values for which to find the natural logarithm (Ln).

    Results:
    out_raster -- Output raster"""
    ...

def LocateRegions(
    in_raster,
    total_area=...,
    area_units=...,
    number_of_regions=...,
    region_shape=...,
    region_orientation=...,
    shape_tradeoff=...,
    evaluation_method=...,
    minimum_area=...,
    maximum_area=...,
    minimum_distance=...,
    maximum_distance=...,
    distance_units=...,
    in_existing_regions=...,
    number_of_neighbors=...,
    no_islands=...,
    region_seeds=...,
    region_resolution=...,
    selection_method=...,
):
    """LocateRegions_sa(in_raster, {total_area}, {area_units}, {number_of_regions}, {region_shape}, {region_orientation}, {shape_tradeoff}, {evaluation_method}, {minimum_area}, {maximum_area}, {minimum_distance}, {maximum_distance}, {distance_units}, {in_existing_regions}, {number_of_neighbors}, {no_islands}, {region_seeds}, {region_resolution}, {selection_method})

    Identifies the best regions, or groups of contiguous cells, from an input utility (suitability) raster that satisfy a specified evaluation criterion and that meet identified shape, size, number, and interregion distance constraints.

    Arguments:
    in_raster -- The input utility raster from which the regions will be derived.
    total_area -- The total amount of area for all regions.
    area_units -- Defines the area units used for the Total area, Region minimum area, and Region maximum area parameters.
    number_of_regions -- Determines how many regions the Total area will be distributed across.
    region_shape -- Defines the shape characteristics for the output regions.
    region_orientation -- Defines the orientation of the defined shape. Regions are grown out from the seed locations with preference given to the cells that maintain the desired orientation of the region shapes.
    shape_tradeoff -- Identifies the weight for the cells when growing the candidate regions in the parameterized region-growing algorithm. The weighting is a tradeoff between a cell's contribution for maintaining the region shape relative to the utility contribution of the cell's attribute value.
    evaluation_method -- The evaluation criteria to be used for determining which of the candidate regions identified in the parameterized region-growing algorithm are most preferred. The preference can be specified based on a particular statistic of the utility values, or spatial arrangement of the cells within the regions.
    minimum_area -- Define the minimum area allowed for each region.
    maximum_area -- Define the maximum area allowed for each region.
    minimum_distance -- Define the minimum distance allowed between regions. No two regions can be within this distance.
    maximum_distance -- Define the maximum distance allowed between regions. No region can be farther apart than this distance from at least one other region.
    distance_units -- Defines the distance units that will be used for the Minimum distance between regions and Maximum distance between regions parameters.
    in_existing_regions -- A dataset identifying where regions already exist.
    number_of_neighbors -- Defines which neighboring cells to use in the growth of the regions.
    no_islands -- Defines whether or not islands will be allowed within the potential regions.
    region_seeds -- Defines the number of seeds from which to grow the potential regions.
    region_resolution -- Sets the resolution at which region growth occurs.
    selection_method -- Identifies how the regions will be selected.

    Results:
    out_raster -- Output raster"""
    ...

def Log10(in_raster_or_constant):
    """Log10_sa(in_raster_or_constant)

    Calculates the base 10 logarithm of cells in a raster.

    Arguments:
    in_raster_or_constant -- Input values for which to find the base 10 logarithm.

    Results:
    out_raster -- Output raster"""
    ...

def Log2(in_raster_or_constant):
    """Log2_sa(in_raster_or_constant)

    Calculates the base 2 logarithm of cells in a raster.

    Arguments:
    in_raster_or_constant -- Input values for which to find the base 2 logarithm.

    Results:
    out_raster -- Output raster"""
    ...

def Lookup(in_raster, lookup_field):
    """Lookup_sa(in_raster, lookup_field)

    Creates a raster by looking up values in another field in the table of the input raster.

    Arguments:
    in_raster -- The input raster that contains a field from which to create a new raster.
    lookup_field -- Field containing the desired values for the new raster.

    Results:
    out_raster -- Output raster"""
    ...

def LowestPosition(in_rasters_or_constants):
    """LowestPosition_sa([in_rasters_or_constant,...])

    Determines on a cell-by-cell basis the position of the raster with the minimum value in a set of rasters.

    Arguments:
    in_rasters_or_constant -- The list of input rasters for which the position of the input with the lowest value will be determined.

    Results:
    out_raster -- Output raster"""
    ...

def MajorityFilter(in_raster, number_neighbors=..., majority_definition=...):
    """MajorityFilter_sa(in_raster, {number_neighbors}, {majority_definition})

    Replaces cells in a raster based on the majority of their contiguous neighboring cells.

    Arguments:
    in_raster -- The input raster to be filtered based on the majority of contiguous neighboring cells.
    number_neighbors -- Determines the number of neighboring cells to use in the kernel of the filter.
    majority_definition -- Specifies the number of contiguous (spatially connected) cells that must be of the same value before a replacement will occur.

    Results:
    out_raster -- Output raster"""
    ...

def Minus(in_raster_or_constant1, in_raster_or_constant2):
    """Minus_sa(in_raster_or_constant1, in_raster_or_constant2)

    Subtracts the value of the second input raster from the value of the first input raster on a cell-by-cell basis.

    Arguments:
    in_raster_or_constant1 -- The input from which to subtract the values in the second input.
    in_raster_or_constant2 -- The input values to subtract from the values in the first input.

    Results:
    out_raster -- Output raster"""
    ...

def MLClassify(
    in_raster_bands,
    in_signature_file,
    reject_fraction=...,
    a_priori_probabilities=...,
    in_a_priori_file=...,
    out_confidence_raster=...,
):
    """MLClassify_sa([in_raster_band,...], in_signature_file, {reject_fraction}, {a_priori_probabilities}, {in_a_priori_file}, {out_confidence_raster})

    Performs a maximum likelihood classification on a set of raster bands and creates a classified raster as output.

    Arguments:
    in_raster_band -- The input raster bands.
    in_signature_file -- The input signature file whose class signatures are used by the maximum likelihood classifier.
    reject_fraction -- Select a reject fraction, which determines whether a cell will be classified based on its likelihood of being correctly assigned to one of the classes. Cells whose likelihood of being correctly assigned to any of the classes is lower than the reject fraction will be given a value of NoData in the output classified raster.
    a_priori_probabilities -- Specifies how a priori probabilities will be determined.
    in_a_priori_file -- A text file containing a priori probabilities for the input signature classes.
    out_confidence_raster -- The output confidence raster dataset shows the certainty of the classification in 14 levels of confidence, with the lowest values representing the highest reliability. If there are no cells classified at a particular confidence level, that confidence level will not be present in the output confidence raster.

    Results:
    out_classified_raster -- Output classified raster"""
    ...

def Mod(in_raster_or_constant1, in_raster_or_constant2):
    """Mod_sa(in_raster_or_constant1, in_raster_or_constant2)

    Finds the remainder (modulo) of the first raster when divided by the second raster on a cell-by-cell basis.

    Arguments:
    in_raster_or_constant1 -- The numerator input.
    in_raster_or_constant2 -- The denominator input.

    Results:
    out_raster -- Output raster"""
    ...

def NaturalNeighbor(in_point_features, z_field, cell_size=...):
    """NaturalNeighbor_sa(in_point_features, z_field, {cell_size})

    Interpolates a raster surface from points using a natural neighbor technique.

    Arguments:
    in_point_features -- The input point features containing the z-values to be interpolated into a surface raster.
    z_field -- The field that holds a height or magnitude value for each point.
    cell_size -- The cell size of the output raster that will be created.

    Results:
    out_raster -- Output raster"""
    ...

def Negate(in_raster_or_constant):
    """Negate_sa(in_raster_or_constant)

    Changes the sign (multiplies by -1) of the cell values of the input raster on a cell-by-cell basis.

    Arguments:
    in_raster_or_constant -- The input raster to be negated (multiplied by -1).

    Results:
    out_raster -- Output raster"""
    ...

def Nibble(
    in_raster, in_mask_raster, nibble_values=..., nibble_nodata=..., in_zone_raster=...
):
    """Nibble_sa(in_raster, in_mask_raster, {nibble_values}, {nibble_nodata}, {in_zone_raster})

    Replaces cells of a raster corresponding to a mask with the values of the nearest neighbors.

    Arguments:
    in_raster -- The input raster that will be nibbled.
    in_mask_raster -- The raster used as the mask.
    nibble_values -- Specifies whether NoData cells in the input raster are allowed to nibble into the area defined by the mask raster.
    nibble_nodata -- Specifies whether NoData cells in the input raster that are within the mask will remain NoData in the output raster.
    in_zone_raster -- The input zone raster. For each zone, input cells that are within the mask will be replaced only by the nearest cell values within that same zone.

    Results:
    out_raster -- Output raster"""
    ...

def NotEqual(in_raster_or_constant1, in_raster_or_constant2):
    """NotEqual_sa(in_raster_or_constant1, in_raster_or_constant2)

    Performs a Relational not-equal-to operation on two inputs on a cell-by-cell basis.

    Arguments:
    in_raster_or_constant1 -- The input that will be compared to for inequality by the second input.
    in_raster_or_constant2 -- The input that will be compared from for inequality by the first input.

    Results:
    out_raster -- Output raster"""
    ...

def ObserverPoints(
    in_raster,
    in_observer_point_features,
    z_factor=...,
    curvature_correction=...,
    refractivity_coefficient=...,
    out_agl_raster=...,
):
    """ObserverPoints_sa(in_raster, in_observer_point_features, {z_factor}, {curvature_correction}, {refractivity_coefficient}, {out_agl_raster})

    Identifies which observer points are visible from each raster surface location.

    Arguments:
    in_raster -- The input surface raster.
    in_observer_point_features -- The point feature class that identifies the observer locations.
    z_factor -- The number of ground x,y units in one surface z-unit.
    curvature_correction -- Specifies whether correction for the earth's curvature will be applied.
    refractivity_coefficient -- The coefficient of the refraction of visible light in air.
    out_agl_raster -- The output above ground level (AGL) raster.

    Results:
    out_raster -- Output raster"""
    ...

def OptimalPathAsLine(
    in_destination_data,
    in_distance_accumulation_raster,
    in_back_direction_raster,
    out_polyline_features,
    destination_field=...,
    path_type=...,
    create_network_paths=...,
):  # -> Any:
    """OptimalPathAsLine_sa(in_destination_data, in_distance_accumulation_raster, in_back_direction_raster, out_polyline_features, {destination_field}, {path_type}, {create_network_paths})

    Calculates the optimal path from a source to a destination as a line.

    Arguments:
    in_destination_data -- An integer raster or feature (point, line, or polygon) that identifies locations from which the optimal path will be determined to the least costly source.
    in_distance_accumulation_raster -- The distance accumulation raster that will be used to determine the optimal path from the sources to the destinations.
    in_back_direction_raster -- The back direction raster contains calculated directions in degrees. The direction identifies the next cell along the optimal path back to the least accumulative cost source while avoiding barriers.
    out_polyline_features -- The output feature class that is the optimal path or paths.
    destination_field -- An integer field that will be used to obtain values for the destination locations.
    path_type -- Specifies a keyword defining the manner in which the values and zones on the input destination data will be interpreted in the cost path calculations.
    create_network_paths -- Specifies whether complete, and possibly overlapping, paths from the destinations to the sources are calculated or if nonoverlapping network paths are created.
    """
    ...

def OptimalPathAsRaster(
    in_destination_data,
    in_distance_accumulation_raster,
    in_back_direction_raster,
    destination_field=...,
    path_type=...,
):
    """OptimalPathAsRaster_sa(in_destination_data, in_distance_accumulation_raster, in_back_direction_raster, {destination_field}, {path_type})

    Calculates the optimal path from a source to a destination as a raster.

    Arguments:
    in_destination_data -- An integer raster or feature (point, line, or polygon) that identifies locations from which the optimal path will be determined to the least costly source.
    in_distance_accumulation_raster -- The distance accumulation raster that will be used to determine the optimal path from the sources to the destinations.
    in_back_direction_raster -- The back direction raster contains calculated directions in degrees. The direction identifies the next cell along the optimal path back to the least accumulative cost source while avoiding barriers.
    destination_field -- The field that will be used to obtain values for the destination locations.
    path_type -- Specifies a keyword defining the manner in which the values and zones on the input destination data will be interpreted in the cost path calculations.

    Results:
    out_path_accumulation_raster -- Output optimal accumulation path"""
    ...

def OptimalRegionConnections(
    in_regions,
    out_feature_class,
    in_barrier_data=...,
    in_cost_raster=...,
    out_neighbor_paths=...,
    distance_method=...,
    connections_within_regions=...,
):  # -> Any:
    """OptimalRegionConnections_sa(in_regions, out_feature_class, {in_barrier_data}, {in_cost_raster}, {out_neighbor_paths}, {distance_method}, {connections_within_regions})

    Calculates the optimal connectivity network between two or more input regions.

    Arguments:
    in_regions -- The input regions to be connected by the optimal network.
    out_feature_class -- The output polyline feature class of the optimal network of paths that connect each of the input regions.
    in_barrier_data -- The dataset that defines the barriers.
    in_cost_raster -- A raster defining the impedance or cost to move planimetrically through each cell.
    out_neighbor_paths -- The output polyline feature class identifying all paths from each region to each of its closest or cost neighbors.
    distance_method -- Specifies whether the distance will be calculated using a planar (flat earth) or a geodesic (ellipsoid) method.
    connections_within_regions -- Specifies whether the paths will continue and connect within the input regions.
    """
    ...

def Over(in_raster_or_constant1, in_raster_or_constant2):
    """Over_sa(in_raster_or_constant1, in_raster_or_constant2)

    For the cell values in the first input that are not 0, the output value will be that of the first input. Where the cell values are 0, the output will be that of the second input raster.

    Arguments:
    in_raster_or_constant1 -- The input for which cell values of 0 will be replaced with the value from the second input.
    in_raster_or_constant2 -- The input whose value will be assigned to the output raster cells where the first input value is 0.

    Results:
    out_raster -- Output raster"""
    ...

def ParticleTrack(
    in_direction_raster,
    in_magnitude_raster,
    source_point,
    out_track_file,
    step_length=...,
    tracking_time=...,
    out_track_polyline_features=...,
):  # -> Any:
    """ParticleTrack_sa(in_direction_raster, in_magnitude_raster, source_point, out_track_file, {step_length}, {tracking_time}, {out_track_polyline_features})

    Calculates the path of a particle through a velocity field, returning an ASCII file of particle tracking data and, optionally, a feature class of track information.

    Arguments:
    in_direction_raster -- An input raster where each cell value represents the direction of the seepage velocity vector (average linear velocity) at the center of the cell.
    in_magnitude_raster -- An input raster where each cell value represents the magnitude of the seepage velocity vector (average linear velocity) at the center of the cell.
    source_point -- The location of the source point from which to begin the particle tracking.
    out_track_file -- The output ASCII text file that contains the particle tracking data.
    step_length -- The step length to be used for calculating the particle track.
    tracking_time -- Maximum elapsed time for particle tracking.
    out_track_polyline_features -- The optional output line feature class containing the particle track.
    """
    ...

def PathAllocation(
    in_source_data,
    in_cost_raster=...,
    in_surface_raster=...,
    in_horizontal_raster=...,
    horizontal_factor=...,
    in_vertical_raster=...,
    vertical_factor=...,
    maximum_distance=...,
    in_value_raster=...,
    source_field=...,
    out_distance_raster=...,
    out_backlink_raster=...,
    source_cost_multiplier=...,
    source_start_cost=...,
    source_resistance_rate=...,
    source_capacity=...,
    source_direction=...,
):
    """PathAllocation_sa(in_source_data, {in_cost_raster}, {in_surface_raster}, {in_horizontal_raster}, {horizontal_factor}, {in_vertical_raster}, {vertical_factor}, {maximum_distance}, {in_value_raster}, {source_field}, {out_distance_raster}, {out_backlink_raster}, {source_cost_multiplier}, {source_start_cost}, {source_resistance_rate}, {source_capacity}, {source_direction})

    Calculates the least-cost source for each cell based on the least accumulative cost over a cost surface, while accounting for surface distance along with horizontal and vertical cost factors.

    Arguments:
    in_source_data -- The input source locations.
    in_cost_raster -- A raster defining the impedance or cost to move planimetrically through each cell.
    in_surface_raster -- A raster defining the elevation values at each cell location.
    in_horizontal_raster -- A raster defining the horizontal direction at each cell.
    horizontal_factor -- Specifies the relationship between the horizontal cost factor and the horizontal relative moving angle (HRMA).
    in_vertical_raster -- A raster defining the z-values for each cell location.
    vertical_factor -- Specifies the relationship between the vertical cost factor and the vertical relative moving angle (VRMA).
    maximum_distance -- The threshold that the accumulative cost values cannot exceed.
    in_value_raster -- The input integer raster that identifies the zone values that will be used for each input source location.
    source_field -- The field used to assign values to the source locations. It must be of integer type.
    out_distance_raster -- The output path distance raster.
    out_backlink_raster -- The output cost backlink raster.
    source_cost_multiplier -- The multiplier that will be applied to the cost values.
    source_start_cost -- The starting cost that will be used to begin the cost calculations.
    source_resistance_rate -- This parameter simulates the increase in the effort to overcome costs as the accumulative cost increases. It is used to model fatigue of the traveler. The growing accumulative cost to reach a cell is multiplied by the resistance rate and added to the cost to move into the subsequent cell.
    source_capacity -- The cost capacity for the traveler for a source.
    source_direction -- Specifies the direction of the traveler when applying horizontal and vertical factors and the source resistance rate.

    Results:
    out_allocation_raster -- Output allocation raster"""
    ...

def PathBackLink(
    in_source_data,
    in_cost_raster=...,
    in_surface_raster=...,
    in_horizontal_raster=...,
    horizontal_factor=...,
    in_vertical_raster=...,
    vertical_factor=...,
    maximum_distance=...,
    out_distance_raster=...,
    source_cost_multiplier=...,
    source_start_cost=...,
    source_resistance_rate=...,
    source_capacity=...,
    source_direction=...,
):
    """PathBackLink_sa(in_source_data, {in_cost_raster}, {in_surface_raster}, {in_horizontal_raster}, {horizontal_factor}, {in_vertical_raster}, {vertical_factor}, {maximum_distance}, {out_distance_raster}, {source_cost_multiplier}, {source_start_cost}, {source_resistance_rate}, {source_capacity}, {source_direction})

    Defines the neighbor that is the next cell on the least accumulative cost path to the least-cost source, while accounting for surface distance along with horizontal and vertical cost factors.

    Arguments:
    in_source_data -- The input source locations.
    in_cost_raster -- A raster defining the impedance or cost to move planimetrically through each cell.
    in_surface_raster -- A raster defining the elevation values at each cell location.
    in_horizontal_raster -- A raster defining the horizontal direction at each cell.
    horizontal_factor -- Specifies the relationship between the horizontal cost factor and the horizontal relative moving angle (HRMA).
    in_vertical_raster -- A raster defining the z-values for each cell location.
    vertical_factor -- Specifies the relationship between the vertical cost factor and the vertical relative moving angle (VRMA).
    maximum_distance -- The threshold that the accumulative cost values cannot exceed.
    out_distance_raster -- The output path distance raster.
    source_cost_multiplier -- The multiplier that will be applied to the cost values.
    source_start_cost -- The starting cost that will be used to begin the cost calculations.
    source_resistance_rate -- This parameter simulates the increase in the effort to overcome costs as the accumulative cost increases. It is used to model fatigue of the traveler. The growing accumulative cost to reach a cell is multiplied by the resistance rate and added to the cost to move into the subsequent cell.
    source_capacity -- The cost capacity for the traveler for a source.
    source_direction -- Specifies the direction of the traveler when applying horizontal and vertical factors and the source resistance rate.

    Results:
    out_backlink_raster -- Output backlink raster"""
    ...

def PathDistance(
    in_source_data,
    in_cost_raster=...,
    in_surface_raster=...,
    in_horizontal_raster=...,
    horizontal_factor=...,
    in_vertical_raster=...,
    vertical_factor=...,
    maximum_distance=...,
    out_backlink_raster=...,
    source_cost_multiplier=...,
    source_start_cost=...,
    source_resistance_rate=...,
    source_capacity=...,
    source_direction=...,
):
    """PathDistance_sa(in_source_data, {in_cost_raster}, {in_surface_raster}, {in_horizontal_raster}, {horizontal_factor}, {in_vertical_raster}, {vertical_factor}, {maximum_distance}, {out_backlink_raster}, {source_cost_multiplier}, {source_start_cost}, {source_resistance_rate}, {source_capacity}, {source_direction})

    Calculates, for each cell, the least accumulative cost distance from or to the least-cost source, while accounting for surface distance along with horizontal and vertical cost factors.

    Arguments:
    in_source_data -- The input source locations.
    in_cost_raster -- A raster defining the impedance or cost to move planimetrically through each cell.
    in_surface_raster -- A raster defining the elevation values at each cell location.
    in_horizontal_raster -- A raster defining the horizontal direction at each cell.
    horizontal_factor -- Specifies the relationship between the horizontal cost factor and the horizontal relative moving angle (HRMA).
    in_vertical_raster -- A raster defining the z-values for each cell location.
    vertical_factor -- Specifies the relationship between the vertical cost factor and the vertical relative moving angle (VRMA).
    maximum_distance -- The threshold that the accumulative cost values cannot exceed.
    out_backlink_raster -- The output cost backlink raster.
    source_cost_multiplier -- The multiplier that will be applied to the cost values.
    source_start_cost -- The starting cost that will be used to begin the cost calculations.
    source_resistance_rate -- This parameter simulates the increase in the effort to overcome costs as the accumulative cost increases. It is used to model fatigue of the traveler. The growing accumulative cost to reach a cell is multiplied by the resistance rate and added to the cost to move into the subsequent cell.
    source_capacity -- The cost capacity for the traveler for a source.
    source_direction -- Specifies the direction of the traveler when applying horizontal and vertical factors and the source resistance rate.

    Results:
    out_distance_raster -- Output distance raster"""
    ...

def Pick(in_position_raster, in_rasters_or_constants, process_as_multiband=...):
    """Pick_sa(in_position_raster, [in_rasters_or_constant,...], {process_as_multiband})

    The value from a position raster is used to determine from which raster in a list of input rasters the output cell value will be obtained.

    Arguments:
    in_position_raster -- The input raster defining the position of the raster to use for the output value.
    in_rasters_or_constant -- The list of inputs from which the output value will be selected.
    process_as_multiband -- Specifies how the input multiband raster bands will be processed.

    Results:
    out_raster -- Output raster"""
    ...

def Plus(in_raster_or_constant1, in_raster_or_constant2):
    """Plus_sa(in_raster_or_constant1, in_raster_or_constant2)

    Adds (sums) the values of two rasters on a cell-by-cell basis.

    Arguments:
    in_raster_or_constant1 -- The input whose values will be added to.
    in_raster_or_constant2 -- The input whose values will be added to the first input.

    Results:
    out_raster -- Output raster"""
    ...

def PointDensity(
    in_point_features,
    population_field,
    cell_size=...,
    neighborhood=...,
    area_unit_scale_factor=...,
):
    """PointDensity_sa(in_point_features, population_field, {cell_size}, {neighborhood}, {area_unit_scale_factor})

    Calculates a magnitude-per-unit area from point features that fall within a neighborhood around each cell.

    Arguments:
    in_point_features -- The input point features for which to calculate the density.
    population_field -- Field denoting population values for each point. The population field is the count or quantity to be used in the calculation of a continuous surface.
    cell_size -- The cell size of the output raster that will be created.
    neighborhood -- Dictates the shape of the area around each cell that is used to calculate the density value.
    area_unit_scale_factor -- The area units of the output density values.

    Results:
    out_raster -- Output raster"""
    ...

def PointsSolarRadiation(
    in_surface_raster,
    in_points_feature_or_table,
    out_global_radiation_features,
    height_offset=...,
    latitude=...,
    sky_size=...,
    time_configuration=...,
    day_interval=...,
    hour_interval=...,
    each_interval=...,
    z_factor=...,
    slope_aspect_input_type=...,
    calculation_directions=...,
    zenith_divisions=...,
    azimuth_divisions=...,
    diffuse_model_type=...,
    diffuse_proportion=...,
    transmittivity=...,
    out_direct_radiation_features=...,
    out_diffuse_radiation_features=...,
    out_direct_duration_features=...,
):  # -> Any:
    """PointsSolarRadiation_sa(in_surface_raster, in_points_feature_or_table, out_global_radiation_features, {height_offset}, {latitude}, {sky_size}, {time_configuration}, {day_interval}, {hour_interval}, {each_interval}, {z_factor}, {slope_aspect_input_type}, {calculation_directions}, {zenith_divisions}, {azimuth_divisions}, {diffuse_model_type}, {diffuse_proportion}, {transmittivity}, {out_direct_radiation_features}, {out_diffuse_radiation_features}, {out_direct_duration_features})

    Derives incoming solar radiation for specific locations in a point feature class or location table.

    Arguments:
    in_surface_raster -- The input elevation surface raster.
    in_points_feature_or_table -- The input point feature class or table specifying the locations to analyze solar radiation.
    out_global_radiation_features -- The output feature class representing the global radiation or amount of incoming solar insolation (direct + diffuse) calculated for each location.
    height_offset -- The height (in meters) above the DEM surface for which calculations will be performed.
    latitude -- The latitude for the site area. The units are decimal degrees with positive values for the northern hemisphere and negative values for the southern hemisphere.
    sky_size -- The resolution or sky size for the viewshed, sky map, and sun map rasters. The units are cells.
    time_configuration -- Specifies the time period that will be used for the calculations.
    day_interval -- The time interval through the year (units: days) that will be used to calculate sky sectors for the sun map.
    hour_interval -- The time interval through the day (units: hours) that will be used to calculate sky sectors for the sun map.
    each_interval -- Specifies whether a single total insolation value will be calculated for all locations or multiple values will be calculated for the specified hour and day interval.
    z_factor -- The number of ground x,y units in one surface z-unit.
    slope_aspect_input_type -- Specifies how slope and aspect information will be derived for analysis.
    calculation_directions -- The number of azimuth directions that will be used when calculating the viewshed.
    zenith_divisions -- The number of zenith divisions that will be used to create sky sectors in the sky map.
    azimuth_divisions -- The number of azimuth divisions that will be used to create sky sectors in the sky map.
    diffuse_model_type -- Specifies the type of diffuse radiation model that will be used.
    diffuse_proportion -- The proportion of global normal radiation flux that is diffuse. Values range from 0 to 1.
    transmittivity -- The fraction of radiation that passes through the atmosphere (averaged overall wavelengths). Values range from 0 (no transmission) to 1 (all transmission).
    out_direct_radiation_features -- The output feature class representing the direct incoming solar radiation for each location.
    out_diffuse_radiation_features -- The output feature class representing the incoming solar radiation for each location that is diffuse.
    out_direct_duration_features -- The output feature class representing the duration of direct incoming solar radiation.
    """
    ...

def PointStatistics(
    in_point_features, field, cell_size=..., neighborhood=..., statistics_type=...
):
    """PointStatistics_sa(in_point_features, field, {cell_size}, {neighborhood}, {statistics_type})

    Calculates a statistic on the points in a neighborhood around each output cell.

    Arguments:
    in_point_features -- The input points to use in the neighborhood operation.
    field -- The field for which the specified statistic will be calculated. It can be any numeric field of the input point features.
    cell_size -- The cell size of the output raster that will be created.
    neighborhood -- The area around each processing cell within which any input points found will be used in the statistics calculation. There are several predefined neighborhood types to choose from.
    statistics_type -- Specifies the statistic type to be calculated.

    Results:
    out_raster -- Output raster"""
    ...

def Popularity(in_popularity_raster_or_constant, in_rasters, process_as_multiband=...):
    """Popularity_sa(in_popularity_raster_or_constant, [in_raster,...], {process_as_multiband})

    Determines the value in an argument list that is at a certain level of popularity on a cell-by-cell basis. The particular level of popularity (the number of occurrences of each value) is specified by the first argument.

    Arguments:
    in_popularity_raster_or_constant -- The input raster that defines the popularity position to be returned.
    in_raster -- The list of input rasters used to evaluate the popularity of the values for each cell location.
    process_as_multiband -- Specifies how the input multiband raster bands will be processed.

    Results:
    out_raster -- Output raster"""
    ...

def PorousPuff(
    in_track_file,
    in_porosity_raster,
    in_thickness_raster,
    mass,
    dispersion_time=...,
    longitudinal_dispersivity=...,
    dispersivity_ratio=...,
    retardation_factor=...,
    decay_coefficient=...,
):
    """PorousPuff_sa(in_track_file, in_porosity_raster, in_thickness_raster, mass, {dispersion_time}, {longitudinal_dispersivity}, {dispersivity_ratio}, {retardation_factor}, {decay_coefficient})

    Calculates the time-dependent, two-dimensional concentration distribution in mass per volume of a solute introduced instantaneously and at a discrete point into a vertically mixed aquifer.

    Arguments:
    in_track_file -- The input particle track path file.
    in_porosity_raster -- The input raster where each cell value represents the effective formation porosity at that location.
    in_thickness_raster -- The input raster where each cell value represents the saturated thickness at that location.
    mass -- A value for the amount of mass released instantaneously at the source point, in units of mass.
    dispersion_time -- A value representing the time horizon for dispersion of the solute, in units of time.
    longitudinal_dispersivity -- A value representing the dispersivity parallel to the flow direction.
    dispersivity_ratio -- A value representing the ratio of longitudinal dispersivity over transverse dispersivity.
    retardation_factor -- A dimensionless value representing the retardation of the solute in the aquifer.
    decay_coefficient -- Decay coefficient for solutes undergoing first-order exponential decay (for example, radionuclides) in units of inverse time.

    Results:
    out_raster -- Output raster"""
    ...

def Power(in_raster_or_constant1, in_raster_or_constant2):
    """Power_sa(in_raster_or_constant1, in_raster_or_constant2)

    Raises the cell values in a raster to the power of the values found in another raster.

    Arguments:
    in_raster_or_constant1 -- The input values to be raised to the power defined by the second input.
    in_raster_or_constant2 -- The input that determines the power the values in the first input will be raised to.

    Results:
    out_raster -- Output raster"""
    ...

def PrincipalComponents(in_raster_bands, number_components=..., out_data_file=...):
    """PrincipalComponents_sa([in_raster_band,...], {number_components}, {out_data_file})

    Performs Principal Component Analysis (PCA) on a set of raster bands and generates a single multiband raster as output.

    Arguments:
    in_raster_band -- The input raster bands.
    number_components -- Number of principal components.
    out_data_file -- Output ASCII data file storing principal component parameters.

    Results:
    out_multiband_raster -- Output multiband raster"""
    ...

def Rank(in_rank_raster_or_constant, in_rasters, process_as_multiband=...):
    """Rank_sa(in_rank_raster_or_constant, [in_raster,...], {process_as_multiband})

    Ranks on a cell-by-cell basis the values from a set of input rasters and determines which values are returned based on the value of the rank input raster.

    Arguments:
    in_rank_raster_or_constant -- The input raster that defines the rank position to be returned.
    in_raster -- The list of input rasters from which the cell value of the raster at the specified rank position will be obtained.
    process_as_multiband -- Specifies how the input multiband raster bands will be processed.

    Results:
    out_raster -- Output raster"""
    ...

def ReclassByASCIIFile(in_raster, in_remap_file, missing_values=...):
    """ReclassByASCIIFile_sa(in_raster, in_remap_file, {missing_values})

    Reclassifies (or changes) the values of the input cells of a raster using an ASCII remap file.

    Arguments:
    in_raster -- The input raster to be reclassified.
    in_remap_file -- ASCII remap file defining the single values or ranges to be reclassified and the values they will become.
    missing_values -- Denotes whether missing values in the reclass file retain their value or get mapped to NoData.

    Results:
    out_raster -- Output raster"""
    ...

def ReclassByTable(
    in_raster,
    in_remap_table,
    from_value_field,
    to_value_field,
    output_value_field,
    missing_values=...,
):
    """ReclassByTable_sa(in_raster, in_remap_table, from_value_field, to_value_field, output_value_field, {missing_values})

    Reclassifies (or changes) the values of the input cells of a raster using a remap table.

    Arguments:
    in_raster -- The input raster to be reclassified.
    in_remap_table -- Table holding fields defining value ranges to be reclassified and the values they will become.
    from_value_field -- Field holding the beginning value for each value range to be reclassified.
    to_value_field -- Field holding the ending value for each value range to be reclassified.
    output_value_field -- Field holding the integer values to which each range should be changed.
    missing_values -- Denotes whether missing values in the reclass table retain their value or get mapped to NoData.

    Results:
    out_raster -- Output raster"""
    ...

def Reclassify(in_raster, reclass_field, remap, missing_values=...):
    """Reclassify_sa(in_raster, reclass_field, remap, {missing_values})

    Reclassifies (or changes) the values in a raster.

    Arguments:
    in_raster -- The input raster to be reclassified.
    reclass_field -- Field denoting the values that will be reclassified.
    remap -- A remap table that defines how the values will be reclassified. Working with the table and it options are as follows:
    missing_values -- Denotes whether missing values in the reclass table retain their value or get mapped to NoData.

    Results:
    out_raster -- Output raster"""
    ...

def RegionGroup(
    in_raster,
    number_neighbors=...,
    zone_connectivity=...,
    add_link=...,
    excluded_value=...,
):
    """RegionGroup_sa(in_raster, {number_neighbors}, {zone_connectivity}, {add_link}, {excluded_value})

    For each cell in the output, the identity of the connected region to which that cell belongs is recorded. A unique number is assigned to each region.

    Arguments:
    in_raster -- The input raster for which unique connected regions of cells will be identified.
    number_neighbors -- Specifies the number of neighboring cells to use when evaluating connectivity between cells that define a region.
    zone_connectivity -- Defines which cell values should be considered when testing for connectivity.
    add_link -- Specifies whether a link field will be added to the table of the output when the Zone grouping method parameter is set to Within. It is ignored if that parameter is set to Cross.
    excluded_value -- A value that excludes all cells of that zone from the connectivity evaluation. If a cell location contains the value, no spatial connectivity will be evaluated, regardless of how the number of neighbors is specified.

    Results:
    out_raster -- Output raster"""
    ...

def RemoveRasterSegmentTilingArtifacts(
    in_segmented_raster, tileSizeX=..., tileSizeY=...
):
    """RemoveRasterSegmentTilingArtifacts_sa(in_segmented_raster, {tileSizeX}, {tileSizeY})

    Corrects segments or objects cut by tile boundaries during the segmentation process performed as a raster function. This tool is helpful for some regional processes, such as image segmentation, that have inconsistencies near image tile boundaries.

    Arguments:
    in_segmented_raster -- Select the segmented raster with the tiling artifacts that you want to remove.
    tileSizeX -- Specify the tile width from Segment Mean Shift. If left blank, the default is 512 pixels.
    tileSizeY -- Specify the tile height from Segment Mean Shift. If left blank, the default is 512 pixels.

    Results:
    out_raster_dataset -- Output Segmented Raster"""
    ...

def RescaleByFunction(
    in_raster, transformation_function=..., from_scale=..., to_scale=...
):
    """RescaleByFunction_sa(in_raster, {transformation_function}, {from_scale}, {to_scale})

    Rescales the input raster values by applying a selected transformation function and transforming the resulting values onto a specified continuous evaluation scale.

    Arguments:
    in_raster -- The input raster to rescale.
    transformation_function -- Specifies the continuous function to transform the values from the input raster.
    from_scale -- The starting value of the output evaluation scale.
    to_scale -- The ending value of the output evaluation scale.

    Results:
    out_raster -- Output raster"""
    ...

def RoundDown(in_raster_or_constant):
    """RoundDown_sa(in_raster_or_constant)

    Returns the next lower integer value, just represented as a floating point, for each cell in a raster.

    Arguments:
    in_raster_or_constant -- The input values to be rounded down.

    Results:
    out_raster -- Output raster"""
    ...

def RoundUp(in_raster_or_constant):
    """RoundUp_sa(in_raster_or_constant)

    Returns the next higher integer value, just represented as a floating point, for each cell in a raster.

    Arguments:
    in_raster_or_constant -- The input values to be rounded up.

    Results:
    out_raster -- Output raster"""
    ...

def Sample(
    in_rasters,
    in_location_data,
    out_table,
    resampling_type=...,
    unique_id_field=...,
    process_as_multidimensional=...,
    acquisition_definition=...,
    statistics_type=...,
    percentile_value=...,
    buffer_distance=...,
    layout=...,
    generate_feature_class=...,
):  # -> Any:
    """Sample_sa([in_raster,...], in_location_data, out_table, {resampling_type}, {unique_id_field}, {process_as_multidimensional}, {acquisition_definition}, {statistics_type}, {percentile_value}, {buffer_distance}, {layout}, {generate_feature_class})

    Creates a table or a point feature class that shows the values of cells from a raster, or a set of rasters, for defined locations. The locations are defined by raster cells, points, polylines, or polygons.

    Arguments:
    in_raster -- The rasters with values that will be sampled based on the input location data.
    in_location_data -- The data identifying positions where a sample will be taken.
    out_table -- The output table or feature class containing the sampled cell values.
    resampling_type -- The resampling algorithm that will be used to sample a raster to determine how the values will be obtained from the raster.
    unique_id_field -- A field containing a different value for every location or feature in the input location raster or features.
    process_as_multidimensional -- Specifies how the input rasters will be processed.
    acquisition_definition -- Specifies the time, depth, or other acquisition data associated with the location features.
    statistics_type -- Specifies the statistic type to be calculated.
    percentile_value -- This value can range from 0 to 100. The default is 90.
    buffer_distance -- The distance around the location data features. The buffer distance is specified in the linear unit of the location feature's spatial reference. If the feature uses a geographic reference, the unit will be degrees.
    layout -- Specifies whether sampled values will appear in rows or columns in the output table.
    generate_feature_class -- Specifies whether a point feature class with sampled values in its attribute table or a table with sampled values will be generated.
    """
    ...

def SegmentMeanShift(
    in_raster,
    spectral_detail=...,
    spatial_detail=...,
    min_segment_size=...,
    band_indexes=...,
    max_segment_size=...,
):
    """SegmentMeanShift_sa(in_raster, {spectral_detail}, {spatial_detail}, {min_segment_size}, {band_indexes}, {max_segment_size})

    Groups into segments adjacent pixels that have similar spectral characteristics.

    Arguments:
    in_raster -- The raster dataset to segment. This can be a multispectral or grayscale image.
    spectral_detail -- The level of importance given to the spectral differences of features in the imagery.
    spatial_detail -- The level of importance given to the proximity between features in the imagery.
    min_segment_size -- The minimum size of a segment. Merge segments smaller than this size with their best fitting neighbor segment. This is related to the minimum mapping unit for your project.
    band_indexes -- The bands that will be used to segment the imagery, separated by a space. If no band indexes are specified, they are determined by the following criteria:
    max_segment_size -- The maximum size of a segment. Segments that are larger than the specified size will be divided. Use this parameter to prevent artifacts in the output raster resulting from large segments.

    Results:
    out_raster_dataset -- Output Raster Dataset"""
    ...

def SetNull(in_conditional_raster, in_false_raster_or_constant, where_clause=...):
    """SetNull_sa(in_conditional_raster, in_false_raster_or_constant, {where_clause})

    Set Null sets identified cell locations to NoData based on a specified criteria. It returns NoData if a conditional evaluation is true, and returns the value specified by another raster if it is false.

    Arguments:
    in_conditional_raster -- The input raster representing the true or false result of the desired condition.
    in_false_raster_or_constant -- The input whose values will be used as the output cell values if the condition is false.
    where_clause -- A logical expression that determines which of the input cells are to be true or false.

    Results:
    out_raster -- Output raster"""
    ...

def Shrink(in_raster, number_cells, zone_values, shrink_method=...):
    """Shrink_sa(in_raster, number_cells, [zone_value,...], {shrink_method})

    Shrinks the selected zones by a specified number of cells by replacing them with the value of the cell that is most frequent in its neighborhood.

    Arguments:
    in_raster -- The input raster for which the identified zones are to be shrunk.
    number_cells -- The number of cells by which to shrink each specified zone.
    zone_value -- The list of zone values to shrink.
    shrink_method -- The method to use to shrink the selected zones.

    Results:
    out_raster -- Output raster"""
    ...

def Sin(in_raster_or_constant):
    """Sin_sa(in_raster_or_constant)

    Calculates the sine of cells in a raster.

    Arguments:
    in_raster_or_constant -- The input for which to calculate the sine values.

    Results:
    out_raster -- Output raster"""
    ...

def SinH(in_raster_or_constant):
    """SinH_sa(in_raster_or_constant)

    Calculates the hyperbolic sine of cells in a raster.

    Arguments:
    in_raster_or_constant -- The input for which to calculate the hyperbolic sine values.

    Results:
    out_raster -- Output raster"""
    ...

def Sink(in_flow_direction_raster):
    """Sink_sa(in_flow_direction_raster)

    Creates a raster identifying all sinks or areas of internal drainage.

    Arguments:
    in_flow_direction_raster -- The input raster that shows the direction of flow out of each cell.

    Results:
    out_raster -- Output raster"""
    ...

def Slice(
    in_raster,
    number_zones=...,
    slice_type=...,
    base_output_zone=...,
    nodata_to_value=...,
    class_interval_size=...,
):
    """Slice_sa(in_raster, {number_zones}, {slice_type}, {base_output_zone}, {nodata_to_value}, {class_interval_size})

    Slices or reclassifies the range of values of the input cells into zones (classes). The available data classification methods are equal interval, equal area (quantile), natural breaks, standard deviation (mean-centered), standard deviation (mean as a break), defined interval, and geometric interval.

    Arguments:
    in_raster -- The input raster to be reclassified.
    number_zones -- The number of zones that the input raster will be reclassified into.
    slice_type -- Specifies the manner in which the input raster will be reclassified into zones.
    base_output_zone -- The starting value that will be used for zones (classes) on the output raster dataset.
    nodata_to_value -- Replace NoData with a value in the output.
    class_interval_size -- The size of the interval between classes.

    Results:
    out_raster -- Output raster"""
    ...

def Slope(
    in_raster,
    output_measurement=...,
    z_factor=...,
    method=...,
    z_unit=...,
    analysis_target_device=...,
):
    """Slope_sa(in_raster, {output_measurement}, {z_factor}, {method}, {z_unit}, {analysis_target_device})

    Identifies the slope (gradient or steepness) from each cell of a raster.

    Arguments:
    in_raster -- The input surface raster.
    output_measurement -- Specifies the measurement units (degrees or percentages) of the output slope raster.
    z_factor -- The number of ground x,y units in one surface z-unit.
    method -- Specifies whether the calculation will be based on a planar (flat earth) or a geodesic (ellipsoid) method.
    z_unit -- Specifies the linear unit that will be used for vertical z-values.
    analysis_target_device -- Specifies the device that will be used to perform the calculation.

    Results:
    out_raster -- Output raster"""
    ...

def SnapPourPoint(
    in_pour_point_data, in_accumulation_raster, snap_distance, pour_point_field=...
):
    """SnapPourPoint_sa(in_pour_point_data, in_accumulation_raster, snap_distance, {pour_point_field})

    Snaps pour points to the cell of highest flow accumulation within a specified distance.

    Arguments:
    in_pour_point_data -- The input pour point locations that are to be snapped.
    in_accumulation_raster -- The input flow accumulation raster.
    snap_distance -- Maximum distance, in map units, to search for a cell of higher accumulated flow.
    pour_point_field -- The field used to assign values to the pour point locations.

    Results:
    out_raster -- Output raster"""
    ...

def SolarRadiationGraphics(
    in_surface_raster,
    in_points_feature_or_table=...,
    sky_size=...,
    height_offset=...,
    calculation_directions=...,
    latitude=...,
    time_configuration=...,
    day_interval=...,
    hour_interval=...,
    out_sunmap_raster=...,
    zenith_divisions=...,
    azimuth_divisions=...,
    out_skymap_raster=...,
):
    """SolarRadiationGraphics_sa(in_surface_raster, {in_points_feature_or_table}, {sky_size}, {height_offset}, {calculation_directions}, {latitude}, {time_configuration}, {day_interval}, {hour_interval}, {out_sunmap_raster}, {zenith_divisions}, {azimuth_divisions}, {out_skymap_raster})

    Derives raster representations of a hemispherical viewshed, sun map, and sky map, which are used in the calculation of direct, diffuse, and global solar radiation.

    Arguments:
    in_surface_raster -- The input elevation surface raster.
    in_points_feature_or_table -- The input point feature class or table specifying the locations to analyze solar radiation.
    sky_size -- The resolution or sky size for the viewshed, sky map, and sun map rasters. The units are cells.
    height_offset -- The height (in meters) above the DEM surface for which calculations will be performed.
    calculation_directions -- The number of azimuth directions that will be used when calculating the viewshed.
    latitude -- The latitude for the site area. The units are decimal degrees with positive values for the northern hemisphere and negative values for the southern hemisphere.
    time_configuration -- Specifies the time period that will be used for the calculations.
    day_interval -- The time interval through the year (units: days) that will be used to calculate sky sectors for the sun map.
    hour_interval -- The time interval through the day (units: hours) that will be used to calculate sky sectors for the sun map.
    out_sunmap_raster -- The output sun map raster.
    zenith_divisions -- The number of zenith divisions that will be used to create sky sectors in the sky map.
    azimuth_divisions -- The number of azimuth divisions that will be used to create sky sectors in the sky map.
    out_skymap_raster -- The output sky map raster.

    Results:
    out_viewshed_raster -- Output viewshed raster"""
    ...

def Spline(
    in_point_features,
    z_field,
    cell_size=...,
    spline_type=...,
    weight=...,
    number_points=...,
):
    """Spline_sa(in_point_features, z_field, {cell_size}, {spline_type}, {weight}, {number_points})

    Interpolates a raster surface from points using a two-dimensional minimum curvature spline technique.

    Arguments:
    in_point_features -- The input point features containing the z-values to be interpolated into a surface raster.
    z_field -- The field that holds a height or magnitude value for each point.
    cell_size -- The cell size of the output raster that will be created.
    spline_type -- The type of spline to be used.
    weight -- Parameter influencing the character of the surface interpolation.
    number_points -- The number of points per region used for local approximation.

    Results:
    out_raster -- Output raster"""
    ...

def SplineWithBarriers(
    in_point_features,
    Z_value_field,
    Input_barrier_features=...,
    cell_size=...,
    Smoothing_Factor=...,
):
    """SplineWithBarriers_sa(in_point_features, Z_value_field, {Input_barrier_features}, {cell_size}, {Smoothing_Factor})

    Interpolates a raster surface, using barriers, from points using a minimum curvature spline technique. The barriers are entered as either polygon or polyline features.

    Arguments:
    in_point_features -- The input point features containing the z-values to be interpolated into a surface raster.
    Z_value_field -- The field that holds a height or magnitude value for each point.
    Input_barrier_features -- The optional input barrier features to constrain the interpolation.
    cell_size -- The cell size of the output raster that will be created.
    Smoothing_Factor -- The parameter that influences the smoothing of the output surface.

    Results:
    Output_raster -- Output raster"""
    ...

def Square(in_raster_or_constant):
    """Square_sa(in_raster_or_constant)

    Calculates the square of the cell values in a raster.

    Arguments:
    in_raster_or_constant -- The input values to find the square of.

    Results:
    out_raster -- Output raster"""
    ...

def SquareRoot(in_raster_or_constant):
    """SquareRoot_sa(in_raster_or_constant)

    Calculates the square root of the cell values in a raster.

    Arguments:
    in_raster_or_constant -- The input values to find the square root of.

    Results:
    out_raster -- Output raster"""
    ...

def StorageCapacity(
    in_surface_raster,
    out_table,
    in_zone_data=...,
    zone_field=...,
    analysis_type=...,
    min_elevation=...,
    max_elevation=...,
    increment_type=...,
    increment=...,
    z_unit=...,
    out_chart=...,
):  # -> Any:
    """StorageCapacity_sa(in_surface_raster, out_table, {in_zone_data}, {zone_field}, {analysis_type}, {min_elevation}, {max_elevation}, {increment_type}, {increment}, {z_unit}, {out_chart})

    Creates a table and a chart of elevations and corresponding storage capacities for an input surface raster. The tool calculates the surface area and total volume of the underlying region at a series of elevation increments.

    Arguments:
    in_surface_raster -- The input raster representing a continuous surface.
    out_table -- The output table that contains for each zone the surface area and total volumes for each increment in elevation.
    in_zone_data -- The dataset that defines the zones.
    zone_field -- The field that contains the values that define each zone.
    analysis_type -- Specifies the analysis type.
    min_elevation -- The minimum elevation from which storage capacities are assessed.
    max_elevation -- The maximum elevation from which storage capacities are assessed.
    increment_type -- Specifies the increment type to use when computing elevation increments between minimum and maximum elevations.
    increment -- An incremental value that is either the number of increments or the difference in elevation between increments. The value is determined based on the increment type parameter value.
    z_unit -- Specifies the linear unit that will be used for vertical z-values.
    out_chart -- The name of the output chart for display."""
    ...

def StreamLink(in_stream_raster, in_flow_direction_raster):
    """StreamLink_sa(in_stream_raster, in_flow_direction_raster)

    Assigns unique values to sections of a raster linear network between intersections.

    Arguments:
    in_stream_raster -- An input raster that represents a linear stream network.
    in_flow_direction_raster -- The input raster that shows the direction of flow out of each cell.

    Results:
    out_raster -- Output raster"""
    ...

def StreamOrder(in_stream_raster, in_flow_direction_raster, order_method=...):
    """StreamOrder_sa(in_stream_raster, in_flow_direction_raster, {order_method})

    Assigns a numeric order to segments of a raster representing branches of a linear network.

    Arguments:
    in_stream_raster -- An input raster that represents a linear stream network.
    in_flow_direction_raster -- The input raster that shows the direction of flow out of each cell.
    order_method -- The method used for assigning stream order.

    Results:
    out_raster -- Output raster"""
    ...

def StreamToFeature(
    in_stream_raster, in_flow_direction_raster, out_polyline_features, simplify=...
):  # -> Any:
    """StreamToFeature_sa(in_stream_raster, in_flow_direction_raster, out_polyline_features, {simplify})

    Converts a raster representing a linear network to features representing the linear network.

    Arguments:
    in_stream_raster -- An input raster that represents a linear stream network.
    in_flow_direction_raster -- The input raster that shows the direction of flow out of each cell.
    out_polyline_features -- Output feature class that will hold the converted streams.
    simplify -- Specifies whether weeding is used."""
    ...

def SurfaceParameters(
    in_raster,
    parameter_type=...,
    local_surface_type=...,
    neighborhood_distance=...,
    use_adaptive_neighborhood=...,
    z_unit=...,
    output_slope_measurement=...,
    project_geodesic_azimuths=...,
    use_equatorial_aspect=...,
    in_analysis_mask=...,
):
    """SurfaceParameters_sa(in_raster, {parameter_type}, {local_surface_type}, {neighborhood_distance}, {use_adaptive_neighborhood}, {z_unit}, {output_slope_measurement}, {project_geodesic_azimuths}, {use_equatorial_aspect}, {in_analysis_mask})

    Determines parameters of a raster surface such as aspect, slope, and curvatures.

    Arguments:
    in_raster -- The input surface raster.
    parameter_type -- Specifies the output surface parameter type that will be computed.
    local_surface_type -- Specifies the type of surface function that will be fitted around the target cell.
    neighborhood_distance -- The output will be calculated over this distance from the target cell center. It determines the neighborhood size.
    use_adaptive_neighborhood -- Specifies whether neighborhood distance will vary with landscape changes (adaptive). The maximum distance is determined by the neighborhood distance. The minimum distance is the input raster cell size.
    z_unit -- Specifies the linear unit that will be used for vertical z-values.
    output_slope_measurement -- The measurement units (degrees or percentages) that will be used for the output slope raster.
    project_geodesic_azimuths -- Specifies whether geodesic azimuths will be projected to correct the angle distortion caused by the output spatial reference.
    use_equatorial_aspect -- Specifies whether aspect will be measured from a point on the equator or from the north pole.
    in_analysis_mask -- The input data defining the locations where the analysis will occur.

    Results:
    out_raster -- Output raster"""
    ...

def TabulateArea(
    in_zone_data,
    zone_field,
    in_class_data,
    class_field,
    out_table,
    processing_cell_size=...,
    classes_as_rows=...,
):  # -> Any:
    """TabulateArea_sa(in_zone_data, zone_field, in_class_data, class_field, out_table, {processing_cell_size}, {classes_as_rows})

    Calculates cross-tabulated areas between two datasets and outputs a table.

    Arguments:
    in_zone_data -- The dataset that defines the zones.
    zone_field -- The field that contains the values that define each zone.
    in_class_data -- The dataset that defines the classes that will have their area summarized within each zone.
    class_field -- The field that holds the class values.
    out_table -- The output table that will contain the summary of the area of each class in each zone.
    processing_cell_size -- The cell size of the output raster that will be created.
    classes_as_rows -- Specifies how the values from the input class raster will be represented in the output table.
    """
    ...

def Tan(in_raster_or_constant):
    """Tan_sa(in_raster_or_constant)

    Calculates the tangent of cells in a raster.

    Arguments:
    in_raster_or_constant -- The input for which to calculate the tangent values.

    Results:
    out_raster -- Output raster"""
    ...

def TanH(in_raster_or_constant):
    """TanH_sa(in_raster_or_constant)

    Calculates the hyperbolic tangent of cells in a raster.

    Arguments:
    in_raster_or_constant -- The input to calculate the hyperbolic tangent values for.

    Results:
    out_raster -- Output raster"""
    ...

def Test(in_raster, where_clause):
    """Test_sa(in_raster, where_clause)

    Performs a Boolean evaluation of the input raster using a logical expression.

    Arguments:
    in_raster -- The input raster on which the Boolean evaluation is performed, based on a logical expression.
    where_clause -- The logical expression that will determine which input cells will return a value of true (1) and which will be false (0).

    Results:
    out_raster -- Output raster"""
    ...

def Thin(
    in_raster, background_value=..., filter=..., corners=..., maximum_thickness=...
):
    """Thin_sa(in_raster, {background_value}, {filter}, {corners}, {maximum_thickness})

    Thins rasterized linear features by reducing the number of cells representing the width of the features.

    Arguments:
    in_raster -- The input raster to be thinned.
    background_value -- Specifies the cell value that will identify the background cells. The linear features are formed from the foreground cells.
    filter -- Specifies whether a filter will be applied as the first phase of thinning.
    corners -- Specifies whether round or sharp turns will be made at turns or junctions.
    maximum_thickness -- The maximum thickness, in map units, of linear features in the input raster.

    Results:
    out_raster -- Output raster"""
    ...

def Times(in_raster_or_constant1, in_raster_or_constant2):
    """Times_sa(in_raster_or_constant1, in_raster_or_constant2)

    Multiplies the values of two rasters on a cell-by-cell basis.

    Arguments:
    in_raster_or_constant1 -- The input containing the values to be multiplied.
    in_raster_or_constant2 -- The input containing the values by which the first input will be multiplied.

    Results:
    out_raster -- Output raster"""
    ...

def TopoToRaster(
    topo_input,
    cell_size=...,
    extent=...,
    Margin=...,
    minimum_z_value=...,
    maximum_z_value=...,
    enforce=...,
    data_type=...,
    maximum_iterations=...,
    roughness_penalty=...,
    discrete_error_factor=...,
    vertical_standard_error=...,
    tolerance_1=...,
    tolerance_2=...,
    out_stream_features=...,
    out_sink_features=...,
    out_diagnostic_file=...,
    out_parameter_file=...,
    profile_penalty=...,
    out_residual_feature=...,
    out_stream_cliff_error_feature=...,
    out_contour_error_feature=...,
):
    """TopoToRaster_sa(topo_input, {cell_size}, {extent}, {Margin}, {minimum_z_value}, {maximum_z_value}, {enforce}, {data_type}, {maximum_iterations}, {roughness_penalty}, {discrete_error_factor}, {vertical_standard_error}, {tolerance_1}, {tolerance_2}, {out_stream_features}, {out_sink_features}, {out_diagnostic_file}, {out_parameter_file}, {profile_penalty}, {out_residual_feature}, {out_stream_cliff_error_feature}, {out_contour_error_feature})

    Interpolates a hydrologically correct raster surface from point, line, and polygon data.

    Arguments:
    topo_input -- The input features containing the z-values to be interpolated into a surface raster.
    cell_size -- The cell size of the output raster that will be created.
    extent -- Extent for the output raster dataset.
    Margin -- Distance in cells to interpolate beyond the specified output extent and boundary.
    minimum_z_value -- The minimum z-value to be used in the interpolation.
    maximum_z_value -- The maximum z-value to be used in the interpolation.
    enforce -- The type of drainage enforcement to apply.
    data_type -- The dominant elevation data type of the input feature data.
    maximum_iterations -- The maximum number of interpolation iterations.
    roughness_penalty -- The integrated squared second derivative as a measure of roughness.
    discrete_error_factor -- The discrete error factor is used to adjust the amount of smoothing when converting the input data to a raster.
    vertical_standard_error -- The amount of random error in the z-values of the input data.
    tolerance_1 -- This tolerance reflects the accuracy and density of the elevation points in relation to surface drainage.
    tolerance_2 -- This tolerance prevents drainage clearance through unrealistically high barriers.
    out_stream_features -- The output line feature class of stream polyline features and ridge line features.
    out_sink_features -- The output point feature class of the remaining sink point features.
    out_diagnostic_file -- The output diagnostic file listing all inputs and parameters used and the number of sinks cleared at each resolution and iteration.
    out_parameter_file -- The output parameter file listing all inputs and parameters used, which can be used with Topo to Raster by File to run the interpolation again.
    profile_penalty -- The profile curvature roughness penalty is a locally adaptive penalty that can be used to partly replace total curvature.
    out_residual_feature -- The output point feature class of all the large elevation residuals as scaled by the local discretisation error.
    out_stream_cliff_error_feature -- The output point feature class of locations where possible stream and cliff errors occur.
    out_contour_error_feature -- The output point feature class of possible errors pertaining to the input contour data.

    Results:
    out_surface_raster -- Output surface raster"""
    ...

def TopoToRasterByFile(
    in_parameter_file,
    out_stream_features=...,
    out_sink_features=...,
    out_residual_feature=...,
    out_stream_cliff_error_feature=...,
    out_contour_error_feature=...,
):
    """TopoToRasterByFile_sa(in_parameter_file, {out_stream_features}, {out_sink_features}, {out_residual_feature}, {out_stream_cliff_error_feature}, {out_contour_error_feature})

    Interpolates a hydrologically correct raster surface from point, line, and polygon data using parameters specified in a file.

    Arguments:
    in_parameter_file -- The input ASCII text file containing the inputs and parameters to use for the interpolation.
    out_stream_features -- Output feature class of stream polyline features.
    out_sink_features -- Output feature class of remaining sink point features.
    out_residual_feature -- The output point feature class of all the large elevation residuals as scaled by the local discretisation error.
    out_stream_cliff_error_feature -- The output point feature class of locations where possible stream and cliff errors occur.
    out_contour_error_feature -- The output point feature class of possible errors pertaining to the input contour data.

    Results:
    out_surface_raster -- Output surface raster"""
    ...

def TrainIsoClusterClassifier(
    in_raster,
    max_classes,
    out_classifier_definition,
    in_additional_raster=...,
    max_iterations=...,
    min_samples_per_cluster=...,
    skip_factor=...,
    used_attributes=...,
    max_merge_per_iter=...,
    max_merge_distance=...,
):  # -> Any:
    """TrainIsoClusterClassifier_sa(in_raster, max_classes, out_classifier_definition, {in_additional_raster}, {max_iterations}, {min_samples_per_cluster}, {skip_factor}, {[used_attribute,...]}, {max_merge_per_iter}, {max_merge_distance})

    Generates an Esri classifier definition file (.ecd) using the Iso Cluster classification definition.

    Arguments:
    in_raster -- The raster dataset to classify.
    max_classes -- Maximum number of desired classes to group pixels or segments. This should be set to be greater than the number of classes in your legend.
    out_classifier_definition -- The output JSON format file that will contain attribute information, statistics, hyperplane vectors, and other information for the classifier. An .ecd file will be created.
    in_additional_raster -- Ancillary raster datasets, such as a multispectral image or a DEM, will be incorporated to generate attributes and other required information for classification. This parameter is optional.
    max_iterations -- The maximum number of iterations the clustering process will run.
    min_samples_per_cluster -- The minimum number of pixels or segments in a valid cluster or class.
    skip_factor -- Number of pixels to skip for a pixel image input. If a segmented image is an input, specify the number of segments to skip.
    used_attribute -- Specifies the attributes that will be included in the attribute table associated with the output raster.
    max_merge_per_iter -- The maximum number of cluster merges per iteration. Increasing the number of merges will reduce the number of classes that are created. A lower value will result in more classes.
    max_merge_distance -- The maximum distance between cluster centers in feature space. Increasing the distance will allow more clusters to merge, resulting in fewer classes. A lower value will result in more classes. Values from 0 to 5 typically return the best results.
    """
    ...

def TrainKNearestNeighborClassifier(
    in_raster,
    in_training_features,
    out_classifier_definition,
    in_additional_raster=...,
    kNN=...,
    max_samples_per_class=...,
    used_attributes=...,
    dimension_value_field=...,
):  # -> Any:
    """TrainKNearestNeighborClassifier_sa(in_raster, in_training_features, out_classifier_definition, {in_additional_raster}, {kNN}, {max_samples_per_class}, {[used_attribute,...]}, {dimension_value_field})

    Generates an Esri classifier definition file (.ecd) using the K-Nearest Neighbor classification method.

    Arguments:
    in_raster -- The raster dataset to classify.
    in_training_features -- The training sample file or layer that delineates the training sites.
    out_classifier_definition -- A JSON formatted .ecd file that contains attribute information, statistics, or other information for the classifier.
    in_additional_raster -- Ancillary raster datasets, such as a multispectral image or a DEM, will be incorporated to generate attributes and other required information for classification. This parameter is optional.
    kNN -- The number of neighbors that will be used in searching for each input pixel or segment. Increasing the number of neighbors will decrease the influence of individual neighbors on the outcome of the classification. The default value is 1.
    max_samples_per_class -- The maximum number of training samples that will be used for each class. The default value of 1000 is recommended when the inputs are nonsegmented rasters. A value that is less than or equal to 0 means that the system will use all the samples from the training sites to train the classifier.
    used_attribute -- Specifies the attributes that will be included in the attribute table associated with the output raster.
    dimension_value_field -- Contains dimension values in the input training sample feature class.
    """
    ...

def TrainMaximumLikelihoodClassifier(
    in_raster,
    in_training_features,
    out_classifier_definition,
    in_additional_raster=...,
    used_attributes=...,
    dimension_value_field=...,
):  # -> Any:
    """TrainMaximumLikelihoodClassifier_sa(in_raster, in_training_features, out_classifier_definition, {in_additional_raster}, {[used_attribute,...]}, {dimension_value_field})

    Generates an Esri classifier definition file (.ecd) using the Maximum Likelihood Classifier (MLC) classification definition.

    Arguments:
    in_raster -- The raster dataset to classify.
    in_training_features -- The training sample file or layer that delineates the training sites.
    out_classifier_definition -- The output JSON format file that will contain attribute information, statistics, hyperplane vectors, and other information for the classifier. An .ecd file will be created.
    in_additional_raster -- Incorporates ancillary raster datasets, such as a segmented image or DEM. This parameter is optional.
    used_attribute -- Specifies the attributes that will be included in the attribute table associated with the output raster.
    dimension_value_field -- Contains dimension values in the input training sample feature class.
    """
    ...

def TrainRandomTreesClassifier(
    in_raster,
    in_training_features,
    out_classifier_definition,
    in_additional_raster=...,
    max_num_trees=...,
    max_tree_depth=...,
    max_samples_per_class=...,
    used_attributes=...,
    dimension_value_field=...,
):  # -> Any:
    """TrainRandomTreesClassifier_sa(in_raster, in_training_features, out_classifier_definition, {in_additional_raster}, {max_num_trees}, {max_tree_depth}, {max_samples_per_class}, {[used_attribute,...]}, {dimension_value_field})

    Generates an Esri classifier definition file (.ecd) using the Random Trees classification method.

    Arguments:
    in_raster -- The raster dataset to classify.
    in_training_features -- The training sample file or layer that delineates the training sites.
    out_classifier_definition -- A JSON file that contains attribute information, statistics, or other information for the classifier. An .ecd file is created.
    in_additional_raster -- Ancillary raster datasets, such as a multispectral image or a DEM, will be incorporated to generate attributes and other required information for classification. This parameter is optional.
    max_num_trees -- The maximum number of trees in the forest. Increasing the number of trees will lead to higher accuracy rates, although this improvement will level off eventually. The number of trees increases the processing time linearly.
    max_tree_depth -- The maximum depth of each tree in the forest. Depth is another way of saying the number of rules each tree is allowed to create to come to a decision. Trees will not grow any deeper than this setting.
    max_samples_per_class -- The maximum number of samples that will be used to define each class.
    used_attribute -- Specifies the attributes that will be included in the attribute table associated with the output raster.
    dimension_value_field -- Contains dimension values in the input training sample feature class.
    """
    ...

def TrainSupportVectorMachineClassifier(
    in_raster,
    in_training_features,
    out_classifier_definition,
    in_additional_raster=...,
    max_samples_per_class=...,
    used_attributes=...,
    dimension_value_field=...,
):  # -> Any:
    """TrainSupportVectorMachineClassifier_sa(in_raster, in_training_features, out_classifier_definition, {in_additional_raster}, {max_samples_per_class}, {[used_attribute,...]}, {dimension_value_field})

    Generates an Esri classifier definition file (.ecd) using the Support Vector Machine (SVM) classification definition.

    Arguments:
    in_raster -- The raster dataset to classify.
    in_training_features -- The training sample file or layer that delineates the training sites.
    out_classifier_definition -- The output JSON format file that will contain attribute information, statistics, hyperplane vectors, and other information for the classifier. An .ecd file will be created.
    in_additional_raster -- Ancillary raster datasets, such as a multispectral image or a DEM, will be incorporated to generate attributes and other required information for classification. This parameter is optional.
    max_samples_per_class -- The maximum number of samples that will be used to define each class.
    used_attribute -- Specifies the attributes that will be included in the attribute table associated with the output raster.
    dimension_value_field -- Contains dimension values in the input training sample feature class.
    """
    ...

def Trend(
    in_point_features,
    z_field,
    cell_size=...,
    order=...,
    regression_type=...,
    out_rms_file=...,
):
    """Trend_sa(in_point_features, z_field, {cell_size}, {order}, {regression_type}, {out_rms_file})

    Interpolates a raster surface from points using a trend technique.

    Arguments:
    in_point_features -- The input point features containing the z-values to be interpolated into a surface raster.
    z_field -- The field that holds a height or magnitude value for each point.
    cell_size -- The cell size of the output raster that will be created.
    order -- The order of the polynomial.
    regression_type -- The type of regression to be performed.
    out_rms_file -- File name for the output text file that contains information about the RMS error and the Chi-Square of the interpolation.

    Results:
    out_raster -- Output raster"""
    ...

def UpdateAccuracyAssessmentPoints(
    in_class_data,
    in_points,
    out_points,
    target_field=...,
    polygon_dimension_field=...,
    point_dimension_field=...,
):  # -> Any:
    """UpdateAccuracyAssessmentPoints_sa(in_class_data, in_points, out_points, {target_field}, {polygon_dimension_field}, {point_dimension_field})

    Updates the Target field in the attribute table to compare reference points to the classified image.

    Arguments:
    in_class_data -- The input classification image or other thematic GIS reference data. The input can be a raster or feature class.
    in_points -- The point feature class providing the accuracy assessment points to be updated.
    out_points -- The output point feature class that contains the updated random point field for accuracy assessment purposes.
    target_field -- Specifies whether the input data is a classified image or ground truth data.
    polygon_dimension_field -- The dimension field for the Input Accuracy Assessment Points parameter value. The assessment points will be updated based on the matching dimension values with this field.
    point_dimension_field -- The dimension field in the Input Accuracy Assessment Points parameter value. Input data with identical dimension values will be used to update corresponding points.
    """
    ...

def Viewshed(
    in_raster,
    in_observer_features,
    z_factor=...,
    curvature_correction=...,
    refractivity_coefficient=...,
    out_agl_raster=...,
):
    """Viewshed_sa(in_raster, in_observer_features, {z_factor}, {curvature_correction}, {refractivity_coefficient}, {out_agl_raster})

    Determines the raster surface locations visible to a set of observer features.

    Arguments:
    in_raster -- The input surface raster.
    in_observer_features -- The feature class that identifies the observer locations.
    z_factor -- The number of ground x,y units in one surface z-unit.
    curvature_correction -- Specifies whether correction for the earth's curvature will be applied.
    refractivity_coefficient -- The coefficient of the refraction of visible light in air.
    out_agl_raster -- The output above ground level (AGL) raster.

    Results:
    out_raster -- Output raster"""
    ...

def Viewshed2(
    in_raster,
    in_observer_features,
    out_agl_raster=...,
    analysis_type=...,
    vertical_error=...,
    out_observer_region_relationship_table=...,
    refractivity_coefficient=...,
    surface_offset=...,
    observer_elevation=...,
    observer_offset=...,
    inner_radius=...,
    inner_radius_is_3d=...,
    outer_radius=...,
    outer_radius_is_3d=...,
    horizontal_start_angle=...,
    horizontal_end_angle=...,
    vertical_upper_angle=...,
    vertical_lower_angle=...,
    analysis_method=...,
    analysis_target_device=...,
):
    """Viewshed2_sa(in_raster, in_observer_features, {out_agl_raster}, {analysis_type}, {vertical_error}, {out_observer_region_relationship_table}, {refractivity_coefficient}, {surface_offset}, {observer_elevation}, {observer_offset}, {inner_radius}, {inner_radius_is_3d}, {outer_radius}, {outer_radius_is_3d}, {horizontal_start_angle}, {horizontal_end_angle}, {vertical_upper_angle}, {vertical_lower_angle}, {analysis_method}, {analysis_target_device})

    Determines the raster surface locations visible to a set of observer features using geodesic methods.

    Arguments:
    in_raster -- The input surface raster. It can be an integer or a floating-point raster.
    in_observer_features -- The input feature class that identifies the observer locations. It can be point, multipoint, or polyline features.
    out_agl_raster -- The output above ground level (AGL) raster.
    analysis_type -- Specifies the type of visibility analysis you wish to perform, either determining how visible each cell is to the observers, or identifying for each surface location which observers are visible.
    vertical_error -- The amount of uncertainty (the Root Mean Square error, or RMSE) in the surface elevation values. It is a floating-point value representing the expected error of the input elevation values. When this parameter is assigned a value greater than 0, the output visibility raster will be floating point. In this case, each cell value on the output visibility raster represents the sum of probabilities that the cell is visible to any of the observers.
    out_observer_region_relationship_table -- The output table for identifying the regions that are visible to each observer. This table can be related to the input observer feature class and the output visibility raster for identifying the regions visible to given observers.
    refractivity_coefficient -- The coefficient of the refraction of visible light in air.
    surface_offset -- A vertical distance to be added to the z-value of each cell as it is considered for visibility. It must be a positive integer or floating-point value.
    observer_elevation -- The surface elevations of the observer points or vertices.
    observer_offset -- A vertical distance to be added to the observer elevation. It must be a positive integer or floating-point value.
    inner_radius -- The start distance from which visibility is determined. Cells closer than this distance are not visible in the output but can still block visibility of the cells between inner radius and outer radius.
    inner_radius_is_3d -- Specifies the type of distance for the inner radius parameter.
    outer_radius -- The maximum distance from which visibility is determined. Cells beyond this distance are excluded from the analysis.
    outer_radius_is_3d -- Specifies the type of distance for the outer radius parameter.
    horizontal_start_angle -- The start angle of the horizontal scan range. Specify the value in degrees from 0 to 360, either as integer or floating point, with 0 oriented to north. The default value is 0.
    horizontal_end_angle -- The end angle of the horizontal scan range. Specify the value in degrees from 0 to 360, either as integer or floating point, with 0 oriented to north. The default value is 360.
    vertical_upper_angle -- The upper vertical angle limit of the scan relative to the horizontal plane. The value is specified in degrees and can be integer or floating point. The allowed range is from above -90 up to and including 90.
    vertical_lower_angle -- The lower vertical angle limit of the scan relative to the horizontal plane. The value is specified in degrees and can be integer or floating point. The allowed range is from -90 up to but not including 90.
    analysis_method -- Specifies the method by which the visibility will be calculated. This option allows you to trade some accuracy for increased performance.
    analysis_target_device -- Specifies the device that will be used to perform the calculation.

    Results:
    out_raster -- Output raster"""
    ...

def Visibility(
    in_raster,
    in_observer_features,
    out_agl_raster=...,
    analysis_type=...,
    nonvisible_cell_value=...,
    z_factor=...,
    curvature_correction=...,
    refractivity_coefficient=...,
    surface_offset=...,
    observer_elevation=...,
    observer_offset=...,
    inner_radius=...,
    outer_radius=...,
    horizontal_start_angle=...,
    horizontal_end_angle=...,
    vertical_upper_angle=...,
    vertical_lower_angle=...,
):
    """Visibility_sa(in_raster, in_observer_features, {out_agl_raster}, {analysis_type}, {nonvisible_cell_value}, {z_factor}, {curvature_correction}, {refractivity_coefficient}, {surface_offset}, {observer_elevation}, {observer_offset}, {inner_radius}, {outer_radius}, {horizontal_start_angle}, {horizontal_end_angle}, {vertical_upper_angle}, {vertical_lower_angle})

    Determines the raster surface locations visible to a set of observer features, or identifies which observer points are visible from each raster surface location.

    Arguments:
    in_raster -- The input surface raster.
    in_observer_features -- The feature class that identifies the observer locations.
    out_agl_raster -- The output above-ground-level (AGL) raster.
    analysis_type -- The visibility analysis type.
    nonvisible_cell_value -- Value assigned to nonvisible cells.
    z_factor -- Number of ground x,y units in one surface z unit.
    curvature_correction -- Specifies whether correction for the earth's curvature will be applied.
    refractivity_coefficient -- The coefficient of the refraction of visible light in air.
    surface_offset -- A vertical distance to be added to the z-value of each cell as it is considered for visibility. It must be a positive integer or floating-point value.
    observer_elevation -- The surface elevations of the observer points or vertices.
    observer_offset -- A vertical distance to be added to the observer elevation. It must be a positive integer or floating-point value.
    inner_radius -- The start distance from which visibility is determined. Cells closer than this distance are not visible in the output but can still block visibility of the cells between inner radius and outer radius.
    outer_radius -- The maximum distance from which visibility is determined. Cells beyond this distance are excluded from the analysis.
    horizontal_start_angle -- The start angle of the horizontal scan range. Specify the value in degrees from 0 to 360, either as integer or floating point, with 0 oriented to north. The default value is 0.
    horizontal_end_angle -- The end angle of the horizontal scan range. Specify the value in degrees from 0 to 360, either as integer or floating point, with 0 oriented to north. The default value is 360.
    vertical_upper_angle -- The upper vertical angle limit of the scan relative to the horizontal plane. The value is specified in degrees and can be integer or floating point. The allowed range is from above -90 up to and including 90.
    vertical_lower_angle -- The lower vertical angle limit of the scan relative to the horizontal plane. The value is specified in degrees and can be integer or floating point. The allowed range is from -90 up to but not including 90.

    Results:
    out_raster -- Output raster"""
    ...

def Watershed(in_flow_direction_raster, in_pour_point_data, pour_point_field=...):
    """Watershed_sa(in_flow_direction_raster, in_pour_point_data, {pour_point_field})

    Determines the contributing area above a set of cells in a raster.

    Arguments:
    in_flow_direction_raster -- The input raster that shows the direction of flow out of each cell.
    in_pour_point_data -- The input pour point locations.
    pour_point_field -- The field used to assign values to the pour point locations.

    Results:
    out_raster -- Output raster"""
    ...

def WeightedOverlay(in_weighted_overlay_table):
    """WeightedOverlay_sa(in_weighted_overlay_table)

    Overlays several rasters using a common measurement scale and weights each according to its importance.

    Arguments:
    in_weighted_overlay_table -- The weighted overlay table allows the calculation of a multiple-criteria analysis between several rasters.

    Results:
    out_raster -- Output raster"""
    ...

def WeightedSum(in_weighted_sum_table):
    """WeightedSum_sa(in_weighted_sum_table)

    Overlays several rasters, multiplying each by their given weight and summing them together.

    Arguments:
    in_weighted_sum_table -- The weighted sum table allows you to apply different weights to individual input rasters before they are summed together.

    Results:
    out_raster -- Output raster"""
    ...

def ZonalFill(in_zone_raster, in_weight_raster):
    """ZonalFill_sa(in_zone_raster, in_weight_raster)

    Fills zones using the minimum cell value from a weight raster along the zone boundary.

    Arguments:
    in_zone_raster -- The input raster that defines the zones to be filled.
    in_weight_raster -- Weight, or value, to be assigned to each zone.

    Results:
    out_raster -- Output raster"""
    ...

def ZonalGeometry(in_zone_data, zone_field, geometry_type=..., cell_size=...):
    """ZonalGeometry_sa(in_zone_data, zone_field, {geometry_type}, {cell_size})

    Calculates the specified geometry measure (area, perimeter, thickness, or the characteristics of ellipse) for each zone in a dataset.

    Arguments:
    in_zone_data -- The dataset that defines the zones.
    zone_field -- The field that contains the values that define each zone.
    geometry_type -- Geometry type to be calculated.
    cell_size -- The cell size of the output raster that will be created.

    Results:
    out_raster -- Output raster"""
    ...

def ZonalGeometryAsTable(
    in_zone_data, zone_field, out_table, processing_cell_size=...
):  # -> Any:
    """ZonalGeometryAsTable_sa(in_zone_data, zone_field, out_table, {processing_cell_size})

    Calculates the geometry measures (area, perimeter, thickness, and the characteristics of ellipse) for each zone in a dataset and reports the results as a table.

    Arguments:
    in_zone_data -- The dataset that defines the zones.
    zone_field -- The field that contains the values that define each zone.
    out_table -- Output table that will contain the summary of the values in each zone.
    processing_cell_size -- The cell size of the output raster that will be created."""
    ...

def ZonalHistogram(
    in_zone_data,
    zone_field,
    in_value_raster,
    out_table,
    out_graph=...,
    zones_as_rows=...,
):  # -> Any:
    """ZonalHistogram_sa(in_zone_data, zone_field, in_value_raster, out_table, {out_graph}, {zones_as_rows})

    Creates a table and a histogram graph that show the frequency distribution of cell values on the value input for each unique zone.

    Arguments:
    in_zone_data -- The dataset that defines the zones.
    zone_field -- The field that contains the values that define each zone.
    in_value_raster -- The raster that contains the values used to create the histogram.
    out_table -- The output table file.
    out_graph -- The name of the output graph for display.
    zones_as_rows -- Specifies how the values from the input value raster will be represented in the output table.
    """
    ...

def ZonalStatistics(
    in_zone_data,
    zone_field,
    in_value_raster,
    statistics_type=...,
    ignore_nodata=...,
    process_as_multidimensional=...,
    percentile_value=...,
    percentile_interpolation_type=...,
    circular_calculation=...,
    circular_wrap_value=...,
):
    """ZonalStatistics_sa(in_zone_data, zone_field, in_value_raster, {statistics_type}, {ignore_nodata}, {process_as_multidimensional}, {percentile_value}, {percentile_interpolation_type}, {circular_calculation}, {circular_wrap_value})

    Summarizes the values of a raster within the zones of another dataset.

    Arguments:
    in_zone_data -- The dataset that defines the zones.
    zone_field -- The field that contains the values that define each zone.
    in_value_raster -- The raster that contains the values on which to calculate a statistic.
    statistics_type -- Specifies the statistic type to be calculated.
    ignore_nodata -- Specifies whether NoData values in the value input will be ignored in the results of the zone that they fall within.
    process_as_multidimensional -- Specifies how the input rasters will be calculated if they are multidimensional.
    percentile_value -- The percentile to calculate. The default is 90, indicating the 90th percentile.
    percentile_interpolation_type -- Specifies the method of interpolation that will be used when the percentile value falls between two cell values from the input value raster.
    circular_calculation -- Specifies how the input raster will be processed for circular data.
    circular_wrap_value -- The value that will be used to round a linear value to the range of a given circular statistic. Its value must be a positive integer or a floating-point value. The default value is 360 degrees.

    Results:
    out_raster -- Output Raster"""
    ...

def ZonalStatisticsAsTable(
    in_zone_data,
    zone_field,
    in_value_raster,
    out_table,
    ignore_nodata=...,
    statistics_type=...,
    process_as_multidimensional=...,
    percentile_values=...,
    percentile_interpolation_type=...,
    circular_calculation=...,
    circular_wrap_value=...,
):  # -> Any:
    """ZonalStatisticsAsTable_sa(in_zone_data, zone_field, in_value_raster, out_table, {ignore_nodata}, {statistics_type}, {process_as_multidimensional}, {[percentile_value,...]}, {percentile_interpolation_type}, {circular_calculation}, {circular_wrap_value})

    Summarizes the values of a raster within the zones of another dataset and reports the results as a table.

    Arguments:
    in_zone_data -- The dataset that defines the zones.
    zone_field -- The field that contains the values that define each zone.
    in_value_raster -- The raster that contains the values on which to calculate a statistic.
    out_table -- The output table that will contain the summary of the values in each zone.
    ignore_nodata -- Specifies whether NoData values in the value input will be ignored in the results of the zone that they fall within.
    statistics_type -- Specifies the statistic type to be calculated.
    process_as_multidimensional -- Specifies how the input rasters will be calculated if they are multidimensional.
    percentile_value -- The percentile to calculate. The default is 90, indicating the 90th percentile.
    percentile_interpolation_type -- Specifies the method of interpolation that will be used when the percentile value falls between two cell values from the input value raster.
    circular_calculation -- Specifies how the input raster will be processed for circular data.
    circular_wrap_value -- The value that will be used to round a linear value to the range of a given circular statistic. Its value must be a positive integer or a floating-point value. The default value is 360 degrees.
    """
    ...

def ApplyEnvironment(in_raster):
    """ApplyEnvironment(in_raster)

    Creates a copy of in_raster with environment settings applied.

    Arguments:
    in_raster -- The input that will be copied.

    Results:
    out_raster -- Output raster"""
    ...

def FloatDivide(in_raster_or_constant1, in_raster_or_constant2):
    """FloatDivide(in_raster_or_constant1, in_raster_or_constant2)

    Divides the values of two rasters on a cell-by-cell basis. The result will
    be a true floating point division.

    Arguments:
    in_raster_or_constant1 -- The input whose values will be divided by the second input.
    in_raster_or_constant2 -- The input whose values the first input are to be divided by.

    Results:
    out_raster -- Output raster"""
    ...

def FloorDivide(in_raster_or_constant1, in_raster_or_constant2):
    """FloorDivide(in_raster_or_constant1, in_raster_or_constant2)

    Divides the values of two rasters on a cell-by-cell basis. The result will
    be a floored floating point division.

    Arguments:
    in_raster_or_constant1 -- The input whose values will be divided by the second input.
    in_raster_or_constant2 -- The input whose values the first input are to be divided by.

    Results:
    out_raster -- Output raster"""
    ...
