"""
This type stub file was generated by pyright.
"""

from arcpy.geoprocessing._base import gptooldoc

r"""The Business Analyst toolbox contains sets of tools that perform GIS
operations fundamental to market analysis. With the tools in this
toolbox, you can perform demographic reporting, review customer and
competitor distributions, identify key trade areas, and visualize data
variables."""
__all__ = ['AddFieldBasedSuitabilityCriteria', 'AddPointLayerBasedSuitabilityCriteria', 'AddVariableBasedSuitabilityCriteria', 'AnalyzeMarketAreaGap', 'AnalyzeMarketPotential', 'AssignCustomersByDistance', 'CalculateMarketPenetration', 'CalculateSuitabilityScore', 'ColorCodedLayer', 'CreateTargetGroup', 'CustomerDerivedTA', 'DesireLines', 'EnrichLayer', 'ExportSegmentationProfile', 'FindNearbyLocations', 'GenerateApproximateDriveTimes', 'GenerateCustomerProfile', 'GenerateDriveTimeTradeArea', 'GenerateGeographiesFromOverlay', 'GenerateGridsAndHexagons', 'GenerateMarketAreaProfile', 'GeneratePointsFromBusinessListings', 'GenerateSDCXIndex', 'GenerateSegmentationProfileReport', 'GenerateSurveyReportForProfile', 'GenerateSurveyReportForTargets', 'GenerateTargetGroupLayer', 'GenerateTargetLayer', 'GenerateTargetPenetrationLayer', 'GenerateThresholdDriveTimeTradeArea', 'GenerateThresholdRingTradeArea', 'GenerateTradeAreaRings', 'HuffModel', 'HuffModelCalibration', 'ImportBusinessAnalystReportTemplate', 'ImportSegmentationProfile', 'ImportSurveyProfiles', 'MakeSuitabilityAnalysisLayer', 'MeasureCannibalization', 'RemoveOverlap', 'RemoveOverlapMultiple', 'RemoveSuitabilityCriteria', 'SetCriteriaProperties', 'StandardGeographyTA', 'SummaryReports']
__alias__ = ...
@gptooldoc('CalculateMarketPenetration_ba', None)
def CalculateMarketPenetration(in_features=..., out_feature_class=..., id_field=..., market_penetration_base_field=..., in_customer_features=..., area_description_field=..., weight_field=..., create_report=..., store_id=..., link_field=..., report_title=..., report_folder=..., report_format=...): # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """CalculateMarketPenetration_ba(in_features, out_feature_class, id_field, market_penetration_base_field, in_customer_features, {area_description_field}, {weight_field}, {create_report}, {store_id}, {link_field}, {report_title}, {report_folder}, {report_format;report_format...})

        Calculates the market penetration based on the number of customers
        within an area compared to a demographic variable such as total
        population.

     INPUTS:
      in_features (Feature Layer):
          The input feature class used for calculating market penetration.
      id_field (Field):
          A unique ID field in the market penetration layer.
      market_penetration_base_field (Field):
          The field containing the values used to calculate market penetration.
          This field will be used as the denominator and represents your
          market-for example, Total Population or Total Households.
      in_customer_features (Feature Layer):
          The input feature class containing the points for the customer layer.
      area_description_field {Field}:
          The field used to describe each feature in the market penetration
          layer.
      weight_field {Field}:
          The field in the customer layer used as a weight to calculate market
          penetration rather than customer counts.
      create_report {Boolean}:
          Specifies whether a summary report will be created per boundary or by
          combining reports into a single report file.

          * CREATE_REPORT-A summary report will be created.

          * DO_NOT_CREATE_REPORT-A summary report will not be created. This is
          the default.
      store_id {Field}:
          A unique identifier associated with each store for each trade area.
      link_field {Field}:
          An ID that assigns a trade area to a customer.
      report_title {String}:
          The title of the report.
      report_folder {Folder}:
          The output directory that will contain the report.
      report_format {String}:
          Specifies one or more output report formats. The default value is PDF.
          Additional available formats: XLSX, HTML, CSV, PAGX.

     OUTPUTS:
      out_feature_class (Feature Class):
          The output feature class that contains the calculated market
          penetration features."""
    ...

@gptooldoc('ColorCodedLayer_ba', None)
def ColorCodedLayer(classification_variable=..., out_layer_name=..., classification_method=..., number_of_classes=...): # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """ColorCodedLayer_ba(classification_variable, out_layer_name, classification_method, number_of_classes)

        Creates a multigeography-level, scale-dependent choropleth layer from
        a variable describing a business, demographic, consumer, or landscape
        characteristic.

     INPUTS:
      classification_variable (String):
          A variable that will display as a color-coded map.
      out_layer_name (String):
          The name of the color-coded layer that will be added to the map.
      classification_method (String):
          Specifies the method that will be used to calculate the class breaks.

          * NATURAL_BREAKS-Natural breaks classes are based on natural groupings
          inherent in the data. Class breaks that best group similar values and
          that maximize the differences between classes will be identified. This
          is the default.

          * QUANTILE-Each class will contain an equal number of features. A
          quantile classification is well suited to linearly distributed data.

          * EQUAL_INTERVAL-The range of attribute values will be divided into
          equal-sized subranges. This allows you to specify the number of
          intervals, and ArcGIS Pro will automatically determine the class
          breaks based on the value range.

          * GEOMETRIC_INTERVAL-Class breaks will be created based on class
          intervals that have a geometric series. The geometric coefficient in
          this classifier can change once (to its inverse) to optimize the class
          ranges.
      number_of_classes (String):
          The number of data classification breaks that will appear on the map.
          The default value is 5."""
    ...

@gptooldoc('DesireLines_ba', None)
def DesireLines(in_stores_layer=..., in_customers_layer=..., out_feature_class=..., store_id_field=..., link_field=..., distance_type=..., units=..., cutoff=..., travel_direction=..., time_of_day=..., time_zone=..., create_report=..., report_title=..., report_folder=..., report_format=...): # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """DesireLines_ba(in_stores_layer, in_customers_layer, out_feature_class, store_id_field, link_field, {distance_type}, {units}, {cutoff}, {travel_direction}, {time_of_day}, {time_zone}, {create_report}, {report_title}, {report_folder}, {report_format;report_format...})

        Generates a series of lines from each customer to an associated store
        location. These lines are often called spider diagrams. The tool can
        also generate an optional Wind Rose report from the output.

     INPUTS:
      in_stores_layer (Feature Layer):
          The input point layer representing store or facility locations.
      in_customers_layer (Feature Layer):
          The input point layer representing customers or patrons.
      store_id_field (Field):
          A unique ID field representing a store or facility location.
      link_field (Field):
          An ID field used to assign individual customers to stores.
      distance_type {String}:
          The method of travel that will be used for distance calculation.
          Straight Line is the default value.When using Portal for ArcGIS or
          local data sources, travel mode
          options are dynamically populated.
      units {String}:
          The type of distance- or time-measuring units that will be used when
          calculating minimal distance.
      cutoff {Double}:
          The distance beyond which customers will be considered outliers and
          excluded from consideration during desire line generation.
      travel_direction {String}:
          Specifies the direction of travel that will be used between stores and
          demand points.

          * TOWARD_STORES-The direction of travel will be from demand points to
          stores. This is the default.

          * AWAY_FROM_STORES-The direction of travel will be from stores to
          demand points.
      time_of_day {Date}:
          The time at which travel begins.
      time_zone {String}:
          Specifies the time zone that will be used for the time_of_day
          parameter.

          * UTC-Coordinated universal time (UTC) will be used. Choose this
          option if you want to choose the best location for a specific time,
          such as now, but aren't certain in which time zone the stores or
          demand points are located.

          * TIME_ZONE_AT_LOCATION-The time zone in which the stores or demand
          points are located will be used. If travel_direction is
          AWAY_FROM_STORES, this is the time zone of the stores. If
          travel_direction is TOWARD_STORES, this is the time zone of the demand
          points. This is the default.
      create_report {Boolean}:
          Specifies whether a Wind Rose report will be created.

          * CREATE_REPORT-A report will be created.

          * DO_NOT_CREATE_REPORT-A report will not be created. This is the
          default.
      report_title {String}:
          The title of the Wind Rose report.
      report_folder {Folder}:
          The output directory that will contain the Wind Rose report.
      report_format {String}:
          One or more output report formats. The default value is PDF.
          Additional available formats are XLSX, HTML, CSV, and PAGX.

     OUTPUTS:
      out_feature_class (Feature Class):
          The resultant feature class that will be added to the Contents pane."""
    ...

@gptooldoc('EnrichLayer_ba', None)
def EnrichLayer(in_features=..., out_feature_class=..., variables=..., buffer_type=..., distance=..., unit=...): # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """EnrichLayer_ba(in_features, out_feature_class, {variables;variables...}, {buffer_type}, {distance}, {unit})

        Enriches data by adding demographic and landscape facts about the
        people and places that surround or are inside data locations.

     INPUTS:
      in_features (Feature Layer):
          The features that will be enriched.
      variables {String}:
          One or more variables that will be summarized and added to the output
          feature class.
      buffer_type {String}:
          Defines the area that will be enriched. The default value is Straight
          Line.When you're signed in to ArcGIS Online, travel mode options are
          dynamically populated. Input line features can only use the Straight
          Line distance method.
      distance {Double}:
          The distance or size of an area to enrich, for example, a 1-mile
          buffer or 5-minute walk time. Units correspond to the polygon type.
          The default value is 1.
      unit {String}:
          The units associated with the distance parameter. The default value is
          Kilometers.

     OUTPUTS:
      out_feature_class (Feature Class):
          The output layer containing both the input attributes and user-
          selected attributes. Selected attributes are summarized from
          underlying demographic boundaries. Only the area inside the input
          boundary is considered."""
    ...

@gptooldoc('FindNearbyLocations_ba', None)
def FindNearbyLocations(in_features=..., id_field=..., in_location_points=..., out_feature_class=..., distance_type=..., units=..., distance_limit=..., number_limit=..., percent_limit=..., create_report=..., report_title=..., report_folder=..., report_format=..., report_fields=..., travel_direction=..., time_of_day=..., time_zone=..., search_tolerance=..., location_name=...): # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """FindNearbyLocations_ba(in_features, id_field, in_location_points, out_feature_class, {distance_type}, {units}, {distance_limit}, {number_limit}, {percent_limit}, {create_report}, {report_title}, {report_folder}, {report_format;report_format...}, {report_fields;report_fields...}, {travel_direction}, {time_of_day}, {time_zone}, {search_tolerance}, {location_name})

        Identifies locations closest to the input features based on a selected
        distance type. The number of points in the output is defined by
        limiting the count or percentage of location points to return or by
        limiting the distance from the input points.

     INPUTS:
      in_features (Feature Layer):
          The point layer to be measured to or from the in_location_points
          parameter value.
      id_field (Field):
          A field containing unique identifiers for each input feature.
      in_location_points (Feature Layer):
          The layer that will be used to generate the output with distance and
          direction attributes to or from the in_features parameter value.
      distance_type {String}:
          The calculated distance based on the method of travel. Straight Line
          is the default value.
      units {String}:
          The measurement units, in distance or time, that will be used when
          calculating nearby locations.
      distance_limit {Double}:
          The analysis extent measured in distance or time.
      number_limit {Long}:
          The numeric limit of the in_location_points value.
      percent_limit {Double}:
          The closest points, as a percentage of the points of the
          in_location_points value.
      create_report {Boolean}:
          Specifies whether an output report will be created.

          * CREATE_REPORT-A report will be created.

          * DO_NOT_CREATE_REPORT-A report will not be created. This is the
          default.
      report_title {String}:
          The title of the output report.
      report_folder {Folder}:
          The directory that will contain the output report.
      report_format {String}:
          The output report formats. The default value is InfographicHTML.
          Additional available formats are PDF, XLSX, S.XLSX, HTML, S.XML, ZIP,
          CVS, PAGX, and InfographicPDF.
      report_fields {Field}:
          The additional fields that will be added to the report.
      travel_direction {String}:
          Specifies whether travel times or distances will be measured from
          location points to input features or from input features to location
          points.

          * TOWARD_STORES-The direction of travel will be from location points
          to input features. This is the default.

          * AWAY_FROM_STORES-The direction of travel will be from input features
          to location points.
      time_of_day {Date}:
          The time at which travel will begin.
      time_zone {String}:
          Specifies the time zone that will be used for the time_of_day
          parameter.

          * UTC-Coordinated universal time (UTC) will be used. Choose this
          option if you want the best location for a specific time, such as now,
          but aren't certain of the time zone in which the in_location_points
          value will be located.

          * TIME_ZONE_AT_LOCATION-The time zone in which the in_location_points
          value is located will be used. If the travel direction is input
          features to location points, this is the time zone of the input
          features. If the travel direction is location points to input
          features, this is the time zone of the location points. This is the
          default.
      search_tolerance {Linear Unit}:
          The maximum distance that input points can be from the network. Points
          located beyond the search tolerance will be excluded from processing.
      location_name {Field}:
          A field from the input in_location_points parameter. This field
          contains the name or ID for each input point used in the Find Nearby
          Locations report.

     OUTPUTS:
      out_feature_class (Feature Class):
          The output location point features."""
    ...

@gptooldoc('GenerateGridsAndHexagons_ba', None)
def GenerateGridsAndHexagons(area_of_interest=..., out_feature_class=..., cell_type=..., enrich_type=..., cell_size=..., h3_resolution=..., variables=..., distance_type=..., distance=..., units=..., out_enriched_buffers=..., travel_direction=..., time_of_day=..., time_zone=..., search_tolerance=..., polygon_detail=...): # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """GenerateGridsAndHexagons_ba(area_of_interest, out_feature_class, {cell_type}, {enrich_type}, {cell_size}, {h3_resolution}, {variables;variables...}, {distance_type}, {distance}, {units}, {out_enriched_buffers}, {travel_direction}, {time_of_day}, {time_zone}, {search_tolerance}, {polygon_detail})

        Creates features with vector-based square grid cells, hexagons, or H3
        hexagons for a given area.

     INPUTS:
      area_of_interest (Feature Layer):
          The input feature class used to define the extent of the grid or
          hexagon layer.
      cell_type {String}:
          Specifies the cell type that will be created in the output.

          * SQUARE-Regular four-sided polygons with equal side lengths will be
          created. This is the default.

          * HEXAGON-Regular six-sided polygons with equal side lengths will be
          created.

          * H3_HEXAGON-Regular six-sided polygons with equal side lengths based
          on Uber's hexagonal hierarchical spatial index will be created.
      enrich_type {String}:
          Specifies the method that will be used for variable enrichment.

          * ENRICH_CELL-Enrichment will be performed on the cell_type parameter
          value.

          * ENRICH_BUFFER-Enrichment will be performed on a buffer around the
          centroid of the grid or hexagon. The default distance_type parameter
          value is straight_line.
      cell_size {Areal Unit}:
          The size of the cell to generate squares or hexagons. The default
          value is 1 square mile.
      h3_resolution {Long}:
          The resolution that will be used to generate the H3 hexagons. A value
          of 15 represents the finest resolution. The default value is 7.
      variables {String}:
          A list of variables that will be appended to the output.
      distance_type {String}:
          The method of travel that will be used for the buffer calculation.
      distance {Double}:
          The distance that will be used for the buffer calculations.
      units {String}:
          The units that will be used for the distance parameter.
      travel_direction {String}:
          Specifies the direction of travel that will be used between the center
          of the cell and the buffer boundary.

          * TOWARD_STORES-The direction of travel will be from location points
          to input features. This is the default.

          * AWAY_FROM_STORES-The direction of travel will be from input features
          to location points.
      time_of_day {Date}:
          The time at which the travel will begin.
      time_zone {String}:
          Specifies the time zone that will be used for the time_of_day
          parameter.

          * UTC-Coordinated universal time (UTC) will be used. Choose this
          option if you want the best location for a specific time, such as now,
          but aren't certain of the time zone.

          * TIME_ZONE_AT_LOCATION-The time zone in which the area_of_interest
          value is located will be used. This is the default.
      search_tolerance {Linear Unit}:
          The maximum distance that input points can be from the network. Points
          located beyond the search tolerance will be excluded from processing.
      polygon_detail {String}:
          Specifies the level of detail that will be used for the output drive
          time polygons.

          * STANDARD-The optimal setting that combines processing speed with
          overall accuracy will be used. This is the default.

          * GENERALIZED-The fastest method will be used.

          * HIGH-The highest level of detail will be used.

     OUTPUTS:
      out_feature_class (Feature Class):
          The feature class that will contain the grid or hexagon features.
      out_enriched_buffers {Feature Class}:
          The feature class that will contain the enriched buffers."""
    ...

@gptooldoc('GeneratePointsFromBusinessListings_ba', None)
def GeneratePointsFromBusinessListings(out_feature_class=..., in_search_features=..., search_terms=..., exact_match=..., match_name_only=..., filters=..., max_count=..., business_dataset=...): # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """GeneratePointsFromBusinessListings_ba(out_feature_class, {in_search_features}, {search_terms}, {exact_match}, {match_name_only}, {filters;filters...}, {max_count}, {business_dataset})

        Generates a point feature layer from a business point location search.

     INPUTS:
      in_search_features {Feature Layer}:
          The area that will be used to search for businesses. Selected features
          supersede the feature class and will be used as the search area.
      search_terms {String}:
          The terms that will be used to search for businesses. You can use
          terms such as business name or business type keywords. If this
          parameter is not set, all businesses from the in_search_features
          parameter will be returned.
      exact_match {Boolean}:
          Specifies whether only the text provided for the search_terms
          parameter will be returned from the search.

          * EXACT_MATCH-Only exact matches to the text provided for the
          search_terms parameter will be returned.

          * PARTIAL_MATCH-Partial matches to the text provided for the
          search_terms parameter as well as exact matches will be returned. This
          is the default.
      match_name_only {Boolean}:
          Specifies whether the search will be limited to the business name
          only.

          * MATCH_NAME_ONLY-Only exact matches to the business name provided for
          the search_terms parameter will be returned.

          * MATCH_ALL_FIELDS-Partial matches to the business name provided for
          the search_terms parameter as well as exact matches will be returned.
          This is the default.
      filters {Value Table}:
          The filters that will be applied to the search_terms parameter.

          * filter_name-Set filter by the dataset field.

          * filter_value-Set filter by applying a value to the selected field.

          * include-Set filter by including or excluding field values.
      max_count {Long}:
          The limit for the number of returned features. The default value is
          1,000,000 for local data and 5,000 for online data hosted by ArcGIS
          Online.The record limit when using on-premises hosted data is set by
          your
          administrator.
      business_dataset {String}:
          The dataset that will be used in the business search.

     OUTPUTS:
      out_feature_class (Feature Class):
          The output feature class that will contain the returned businesses."""
    ...

@gptooldoc('HuffModel_ba', None)
def HuffModel(in_facility_features=..., facility_id_field=..., in_candidate_features=..., candidate_id_field=..., in_sales_potential_features=..., sales_potential_id_field=..., sales_potential_field=..., out_feature_class=..., attractiveness_variables=..., distance_exponent=..., distance_type=..., distance_units=..., out_distance_matrix=..., travel_direction=..., time_of_day=..., time_zone=...): # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """HuffModel_ba(in_facility_features, facility_id_field, in_candidate_features, candidate_id_field, in_sales_potential_features, sales_potential_id_field, sales_potential_field, out_feature_class, attractiveness_variables;attractiveness_variables..., distance_exponent, {distance_type}, {distance_units}, {out_distance_matrix}, {travel_direction}, {time_of_day}, {time_zone})

        Creates a probability surface to predict the sales potential of an
        area based on distance and an attractiveness factor.

     INPUTS:
      in_facility_features (Feature Layer):
          An input point feature layer representing existing facility locations.
          It is the first feature from the layer or the feature selected when a
          selection is available.
      facility_id_field (Field):
          A unique ID field for existing facilities.
      in_candidate_features (Feature Layer):
          An input point feature layer representing new candidate facility
          locations. It is the first feature from the layer or the feature
          selected when a selection is available.
      candidate_id_field (Field):
          A unique ID field for candidate facilities.
      in_sales_potential_features (Feature Layer):
          An input point or polygon feature layer used to calculate the sales
          potential. It is either all features from a layer or only selected
          features when a selection is available.
      sales_potential_id_field (Field):
          A unique ID field for sales potential features.
      sales_potential_field (Field):
          The field containing the values that will be used to calculate the
          sales potential.
      attractiveness_variables (Value Table):
          The attribute fields that indicate the attractiveness of each
          competitor. In many cases, the size of the facility is used as a
          substitute for attractiveness and will be a multivalue table.An
          additional attractiveness variable is needed. The attractiveness
          field must be present in the existing facilities (competitors) and the
          candidate facilities layer.

          * existing_facilities_value-Numeric field in the in_facility_features
          parameter layer that represents attractiveness.

          * candidates_location_value-Numeric field in the in_candidate_features
          parameter layer that matches the attractiveness value from the
          in_facility_features parameter layer. Distance does not require a
          matching field.

          * exponent-The value that determines how much of a factor the variable
          is to the attractiveness value. The default value is 1.
      distance_exponent (Double):
          The distance exponent is generally a negative number because
          attractiveness decreases when distance increases. The default value is
          -1.5.
      distance_type {String}:
          The type of distance, based on method of travel, that will be used.
          The default value is Straight Line.
      distance_units {String}:
          The distance-measuring units that will be used when calculating
          distance.
      travel_direction {String}:
          Specifies the direction of travel that will be used between stores and
          sales potential features.

          * TOWARD_STORES-The direction of travel will be from sales potential
          features to stores. This is the default.

          * AWAY_FROM_STORES-The direction of travel will be from stores to
          sales potential features.
      time_of_day {Date}:
          The time and date that will be used when calculating distance.
      time_zone {String}:
          Specifies the time zone that will be used for the time_of_day
          parameter.

          * TIME_ZONE_AT_LOCATION-The time zone in which the territories are
          located will be used. This is the default.

          * UTC-Coordinated universal time (UTC) will be used.

     OUTPUTS:
      out_feature_class (Feature Class):
          The output feature class that will contain the tool results
          representing the probability of sales.
      out_distance_matrix {Table}:
          The name and location of the matrix table of distance calculations.
          The IDs for the in_facility_features and in_candidate_features
          parameters must be unique."""
    ...

@gptooldoc('HuffModelCalibration_ba', None)
def HuffModelCalibration(in_facility_features=..., facility_id_field=..., in_customer_features=..., link_field=..., in_sales_potential_features=..., sales_potential_id_field=..., out_calibration=..., attractiveness_variables=..., customer_weight_field=..., distance_type=..., distance_units=..., travel_direction=..., time_of_day=..., time_zone=...): # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """HuffModelCalibration_ba(in_facility_features, facility_id_field, in_customer_features, link_field, in_sales_potential_features, sales_potential_id_field, out_calibration, attractiveness_variables;attractiveness_variables..., {customer_weight_field}, {distance_type}, {distance_units}, {travel_direction}, {time_of_day}, {time_zone})

        Calculates exponent values for use in the Huff Model tool.

     INPUTS:
      in_facility_features (Feature Layer):
          The input point feature class representing competitors or existing
          stores.
      facility_id_field (Field):
          A unique ID field representing a store or facility location.
      in_customer_features (Feature Layer):
          The input point feature class representing customer locations.
      link_field (Field):
          The field that will be used as an ID to assign individual customers to
          a facility or store.
      in_sales_potential_features (Feature Layer):
          The input polygon feature class used to determine the potential sales
          market.
      sales_potential_id_field (Field):
          A unique ID field representing the sales potential area.
      attractiveness_variables (Value Table):
          The fields that will be used to determine the attractiveness of each
          competitor. In many cases, the size of the store is used as a
          substitute for attractiveness.
      customer_weight_field {Field}:
          A calculated weighted value field assigned to each customer.
      distance_type {String}:
          The method of travel that will be used to calculate distance. The
          default value is Straight Line.
      distance_units {String}:
          The distance-measuring units that will be used when calculating
          distance.
      travel_direction {String}:
          Specifies the direction of travel that will be used between stores and
          sales potential features.

          * TOWARD_STORES-The direction of travel will be from sales potential
          features to stores. This is the default.

          * AWAY_FROM_STORES-The direction of travel will be from stores to
          sales potential features.
      time_of_day {Date}:
          The time and date that will be used when calculating distance.
      time_zone {String}:
          Specifies the time zone that will be used for the time_of_day
          parameter.

          * TIME_ZONE_AT_LOCATION-The time zone in which the territories are
          located will be used. This is the default.

          * UTC-Coordinated universal time (UTC) will be used.

     OUTPUTS:
      out_calibration (File):
          The output calibration file that will contain the calibrated Huff
          model results, which is the exponent values for the attractiveness
          variables and distance. The output file extension will be *.huffmodel."""
    ...

@gptooldoc('ImportBusinessAnalystReportTemplate_ba', None)
def ImportBusinessAnalystReportTemplate(online_report_template_id=..., output_folder=..., dataset_id=..., config=...): # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """ImportBusinessAnalystReportTemplate_ba(online_report_template_id, {output_folder}, {dataset_id}, {config})

        Imports an online report so that it can run locally using a locally
        installed ArcGIS Business Analyst dataset.

     INPUTS:
      online_report_template_id (String):
          The report template ID.
      output_folder {Folder}:
          The local folder where the report template items will be imported.
      dataset_id {String}:
          The dataset that will be used to populate the report variables.
      config {String}:
          A JSON string specifying where the report's SDCX variables
          will be stored. The config options are as follows:

          * id-The portal item ID of the SDCX.

          * download-True or false. Set to true to download the SDCX, or set to
          false to reference an existing SDCX.

          * path-The location of the SDCX. Use an empty string to use the
          existing default-for example, the report output folder location-or
          specify a new folder location or an existing folder that contains the
          SDCX.

          * name-The name of the SDCX. Specify a new name for the SDCX or the
          name of an existing SDCX."""
    ...

@gptooldoc('SummaryReports_ba', None)
def SummaryReports(in_features=..., report_templates=..., reports_folder=..., summarization_options=..., single_report=..., formats=..., store_id_field=..., store_name_field=..., store_address_field=..., store_latitude_field=..., store_longitude_field=..., ring_id_field=..., area_description_field=..., title=..., subtitle=..., report_per_feature=...): # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """SummaryReports_ba(in_features, report_templates;report_templates..., reports_folder, {summarization_options}, {single_report}, {formats;formats...}, {store_id_field}, {store_name_field}, {store_address_field}, {store_latitude_field}, {store_longitude_field}, {ring_id_field}, {area_description_field}, {title}, {subtitle}, {report_per_feature})

        Creates and populates demographic style summary reports for a boundary
        layer using Esri report templates.

     INPUTS:
      in_features (Feature Layer):
          The boundary layer containing one or more polygons that will be used
          to create reports.
      report_templates (String):
          One or more report templates that will be used to create the summary
          report. You must be signed in to ArcGIS Online or have Business
          Analyst Data installed.
      reports_folder (Folder):
          The output location where the summary reports will be saved.
      summarization_options {String}:
          Specifies how the data will be displayed in a report.

          * INDIVIDUAL_FEATURES-Selected report templates will be returned for
          each individual trade area polygon. This is the default.

          * WHOLE_LAYER-Selected report templates will be returned representing
          only the full extent of the trade area.

          * BOTH_FEATURES_AND_LAYER-Selected report templates will be returned
          for both individual features and the whole layer.
      single_report {Boolean}:
          Specifies whether a single output will be created or a separate file
          will be created for each report.

          * CREATE_SINGLE_REPORT-All reports will be combined into a single
          output.

          * CREATE_REPORT_PER_TEMPLATE-A separate file will be created for each
          selected report. This is the default.
      formats {String}:
          The report output format. The default value is PDF.
      store_id_field {Field}:
          The field that will be used to group data for each site in output
          reports. These field values are not displayed in the header.
      store_name_field {Field}:
          The field values that will be displayed in the output report headers
          that identify the site corresponding to each polygon's data.
      store_address_field {Field}:
          The store address associated with each trade area.
      store_latitude_field {Field}:
          The field that will contain the latitude coordinates (y field).
      store_longitude_field {Field}:
          The field that will contain the longitude coordinates (x field).
      ring_id_field {Field}:
          The field that will control the presentation order of data for inputs
          with multiple polygons per site.
      area_description_field {Field}:
          The field that will be displayed as the output template header with
          values corresponding to each input polygon's data.
      title {String}:
          The title in the report header.
      subtitle {String}:
          The subtitle in the report header. The default value is Prepared by
          Business Analyst Pro.
      report_per_feature {Boolean}:
          Specifies whether a single report or multiple reports will be created.

          * CREATE_REPORT_PER_FEATURE-A report will be created per feature.

          * CREATE_SINGLE_REPORT-A single report will be created. This is the
          default."""
    ...

@gptooldoc('GenerateSDCXIndex_ba', None)
def GenerateSDCXIndex(sdcx_file=...): # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """GenerateSDCXIndex_ba(sdcx_file)

        Creates an index for a Statistical Data Collection (SDCX). The index
        will improve performance when using the custom data in analysis tools
        such as Enrich Layer.

     INPUTS:
      sdcx_file (File):
          The input Statistical Data Collection file (.sdcx)."""
    ...

@gptooldoc('AddFieldBasedSuitabilityCriteria_ba', None)
def AddFieldBasedSuitabilityCriteria(in_analysis_layer=..., fields=...): # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """AddFieldBasedSuitabilityCriteria_ba(in_analysis_layer, fields;fields...)

        Adds criteria based on the numerical fields existing in the input
        layer.

     INPUTS:
      in_analysis_layer (Feature Layer):
          The Suitability Analysis layer that will be used in the analysis.
      fields (Field):
          The numeric fields from which the suitability criteria will be
          determined."""
    ...

@gptooldoc('AddPointLayerBasedSuitabilityCriteria_ba', None)
def AddPointLayerBasedSuitabilityCriteria(in_analysis_layer=..., site_layer_id_field=..., in_point_features=..., criteria_type=..., distance_type=..., units=..., in_site_centers_features=..., site_centers_id_field=..., weight_field=..., statistics_type=..., cutoff_distance=...): # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """AddPointLayerBasedSuitabilityCriteria_ba(in_analysis_layer, site_layer_id_field, in_point_features, criteria_type, {distance_type}, {units}, {in_site_centers_features}, {site_centers_id_field}, weight_field, {statistics_type}, {cutoff_distance})

        Adds criteria based on spatial relationships between the input layer
        and a given point layer.

     INPUTS:
      in_analysis_layer (Feature Layer):
          The Suitability Analysis layer that will be used in the analysis.
      site_layer_id_field (Field):
          A field containing unique values for each record within the
          Suitability Analysis layer.
      in_point_features (Feature Layer):
          The layer containing point locations to be added as criteria based on
          spatial relationship to the Suitability Analysis layer.
      criteria_type (String):
          Defines the type of spatial relationship to be used as criteria.

          * COUNT-A count of points that fall within each Suitability Analysis
          layer polygon. This is the default.

          * WEIGHT-Calculates field-weighted criteria of points that fall within
          each Suitability Analysis polygon based on the user-selected
          statistical type.

          * MINIMAL_DISTANCE-Adds distance from the closest point to each of the
          Suitability Analysis layer centroids as criteria.
      distance_type {String}:
          Defines how minimal distance is calculated based on method of travel.
      units {String}:
          Defines the type of distance measuring units to be used when
          calculating minimal distance.
      in_site_centers_features {Feature Layer}:
          The point layer that will be used as site centers. This point layer
          will replace default polygon centroids of the Suitability Analysis
          layer.
      site_centers_id_field {Field}:
          A field existing within the in_site_centers_features parameter that
          uniquely identifies each record.
      weight_field (Field):
          Numeric fields that exist within a point layer that can be selected
          for weighting.
      statistics_type {String}:
          The type of statistical operation to be applied to the weighted field.

          * SUM-Calculates the total of the field values in each point feature.

          * AVE-Determines the average field value in each point feature.

          * STD_DEV-Calculates the standard deviation of the field values in
          each point feature.

          * MIN-Determines the smallest field value in each point feature.

          * MAX-Determines the largest field value in each point feature.
      cutoff_distance {Double}:
          The distance beyond which points will not be considered in the
          calculation."""
    ...

@gptooldoc('AddVariableBasedSuitabilityCriteria_ba', None)
def AddVariableBasedSuitabilityCriteria(in_analysis_layer=..., variables=...): # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """AddVariableBasedSuitabilityCriteria_ba(in_analysis_layer, variables;variables...)

        Adds criteria based on the values calculated for the input layer using
        the Enrich Layer tool.

     INPUTS:
      in_analysis_layer (Feature Layer):
          The Suitability Analysis layer that will be used in the analysis.
      variables (String):
          The variables from which the suitability criteria will be determined."""
    ...

@gptooldoc('CalculateSuitabilityScore_ba', None)
def CalculateSuitabilityScore(in_analysis_layer=...): # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """CalculateSuitabilityScore_ba(in_analysis_layer)

        Calculates or recalculates a suitability score.

     INPUTS:
      in_analysis_layer (Feature Layer):
          The Suitability Analysis Layer that will be used in the analysis."""
    ...

@gptooldoc('MakeSuitabilityAnalysisLayer_ba', None)
def MakeSuitabilityAnalysisLayer(in_features=..., layer_name=...): # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """MakeSuitabilityAnalysisLayer_ba(in_features, layer_name)

        Creates a Suitability Analysis layer for a given input site's
        polygonal layer.

     INPUTS:
      in_features (Feature Layer):
          The feature layer that will be used in the creation of the Suitability
          Analysis layer.
      layer_name (String):
          The name of the output Suitability Analysis layer to be created."""
    ...

@gptooldoc('RemoveSuitabilityCriteria_ba', None)
def RemoveSuitabilityCriteria(in_analysis_layer=..., drop_criteria=...): # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """RemoveSuitabilityCriteria_ba(in_analysis_layer, drop_criteria;drop_criteria...)

        Removes criteria from a suitability analysis layer.

     INPUTS:
      in_analysis_layer (Feature Layer):
          The suitability analysis layer from which criteria will be removed.
      drop_criteria (String):
          A list of criteria to be removed from a suitability analysis layer."""
    ...

@gptooldoc('SetCriteriaProperties_ba', None)
def SetCriteriaProperties(in_analysis_layer=..., criteria_properties=...): # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """SetCriteriaProperties_ba(in_analysis_layer, criteria_properties;criteria_properties...)

        Define parameters for criteria.

     INPUTS:
      in_analysis_layer (Feature Layer):
          The Suitability Analysis layer that will be used in the analysis.
      criteria_properties (Value Table):
          The input features that will be used to set up your criteria
          properties.

          * criterion-The field, point, or variable that will be used to
          calculate your suitability score.

          * title-The name of your criteria.

          * weight-The influence a criteria value has on the overall suitability
          score. The number must be greater than or equal to 0.

          * influence-Can be positive, inverse, or ideal. An example of
          a positive influence is as follows: You want a site to score higher if
          it has a greater number of households holding graduate or professional
          degrees. An example of an inverse influence is as follows: A lower
          median home value is more desirable as it is indicative of greater
          home affordability. An example of an ideal influence would be a search
          for areas within a range of values.

          * POSITIVE-The higher the criteria value, the higher the suitability
          score.

          * INVERSE-The lower the criteria value, the higher the suitability
          score.

          * IDEAL-The closer to the ideal value, the higher the score.

          * ideal_value-The closer the criteria value is to the ideal_value, the
          higher the suitability score.

          * minimum_value-A numeric value that sets a hard limit for the
          criteria lower bound.

          * maximum_value-A numeric value that sets a hard limit for the
          criteria upper bound.

          * enabled-Check to include the criteria in the final suitability
          score."""
    ...

@gptooldoc('AnalyzeMarketAreaGap_ba', None)
def AnalyzeMarketAreaGap(customer_layer=..., target_profile=..., base_profile=..., geography_level=..., out_feature_class=..., target_group=..., core_target=..., developmental_target=..., boundary_layer=..., create_report=..., report_title=..., report_folder=..., report_format=...): # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """AnalyzeMarketAreaGap_ba(customer_layer, target_profile, base_profile, geography_level, out_feature_class, target_group, core_target, developmental_target, {boundary_layer}, {create_report}, {report_title}, {report_folder}, {report_format;report_format...})

        Generates a layer that displays the gap between total customers and
        expected customers.

     INPUTS:
      customer_layer (Feature Layer):
          A point layer representing customers.
      target_profile (File):
          A segmentation profile representing the segments to be analyzed. The
          target profile usually represents your customer segmentation profile.
      base_profile (File):
          A segmentation profile representing the base profile segments. This is
          the segmentation used for comparison. The base profile usually
          represents your market area segmentation profile.
      geography_level (String):
          The geography level that will be used to define the market area gap
          analysis layer.
      target_group (File):
          A collection of segments grouped into targets. Targets represent
          segments that are selected based on similar characteristics-for
          example, segments that have high index and percent composition.
      core_target (String):
          A group of segments that make up a large percentage of your customer
          base and have an above average index, indicating likelihood to be a
          customer.
      developmental_target (String):
          A group of segments that make up a significant percentage of your
          customers and of the market area but do not have an above average
          index.
      boundary_layer {Feature Layer}:
          The boundary that determines the layer extent. If not specified, the
          entire country will be used.
      create_report {Boolean}:
          Specifies whether a gap analysis report will be created.

          * CREATE_REPORT-A gap analysis report will be created.

          * DO_NOT_CREATE_REPORT-A gap analysis report will not be created. This
          is the default.
      report_title {String}:
          The title of the report.
      report_folder {Folder}:
          The output location where the report will be saved.
      report_format {String}:
          The report output format. The default value is PDF. Additional
          available formats are XLSX, HTML, CSV, and PAGX.

     OUTPUTS:
      out_feature_class (Feature Class):
          The output feature class containing the market area gap analysis."""
    ...

@gptooldoc('AnalyzeMarketPotential_ba', None)
def AnalyzeMarketPotential(target_profile=..., base_profile=..., geography_level=..., out_feature_class=..., boundary_layer=..., create_report=..., report_title=..., report_folder=..., report_format=...): # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """AnalyzeMarketPotential_ba(target_profile, base_profile, geography_level, out_feature_class, {boundary_layer}, {create_report}, {report_title}, {report_folder}, {report_format;report_format...})

        Generates a layer that displays expected customers by a selected
        geography level.

     INPUTS:
      target_profile (File):
          A segmentation profile representing the segments to be analyzed. The
          target profile usually represents your customer segmentation profile.
      base_profile (File):
          A segmentation profile representing the base profile segments. This is
          the segmentation used for comparison. The base profile usually
          represents your market area segmentation profile.
      geography_level (String):
          The geography level that will be used to define the market potential
          layer.
      boundary_layer {Feature Layer}:
          The boundary that determines the layer extent. If not specified, the
          entire country will be used.
      create_report {Boolean}:
          Specifies whether a market potential report will be created.

          * CREATE_REPORT-A market potential report will be created.

          * DO_NOT_CREATE_REPORT-A market potential report will not be created.
          This is the default.
      report_title {String}:
          The title of the report.
      report_folder {Folder}:
          The output location where the report will be saved.
      report_format {String}:
          The report output format. The default value is PDF. Additional
          available formats are XLSX, HTML, CSV, and PAGX.

     OUTPUTS:
      out_feature_class (Feature Class):
          The output feature class containing the market potential analysis."""
    ...

@gptooldoc('CreateTargetGroup_ba', None)
def CreateTargetGroup(target_group=..., input_type=...): # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """CreateTargetGroup_ba(target_group, input_type;input_type...)

        Creates a new target group. A target group is a container for targets
        that you create, name, and populate with segments from a locally
        installed Business Analyst dataset.

     INPUTS:
      input_type (Value Table):
          Specifies a list of the targets to be added to the new target group.

          * name-The name of the target.

          * segments-The segments to be added to the target.

          * color-The color associated with the segment.

     OUTPUTS:
      target_group (File):
          The name for the output target group file."""
    ...

@gptooldoc('ExportSegmentationProfile_ba', None)
def ExportSegmentationProfile(in_profile=..., out_table_name=...): # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """ExportSegmentationProfile_ba(in_profile, out_table_name)

        Exports a segmentation profile to a table.

     INPUTS:
      in_profile (File):
          The segmentation file to export.

     OUTPUTS:
      out_table_name (Table):
          The name of the table to be created."""
    ...

@gptooldoc('GenerateCustomerProfile_ba', None)
def GenerateCustomerProfile(in_customers_layer=..., in_segmentation_base=..., out_profile=..., in_volume_field=...): # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """GenerateCustomerProfile_ba(in_customers_layer, in_segmentation_base, out_profile, {in_volume_field})

        Creates a segmentation profile with an existing customer layer.

     INPUTS:
      in_customers_layer (Feature Layer):
          The input point feature class that represents existing customers.
      in_segmentation_base (String):
          The segmentation base for the profile being created. Available options
          are provided by the segmentation dataset in use.
      in_volume_field {Field}:
          The field containing volume information from which the profile can
          optionally be created. For example, you can create a profile using the
          sales for each customer.

     OUTPUTS:
      out_profile (File):
          The name of the segmentation profile file to be created."""
    ...

@gptooldoc('GenerateMarketAreaProfile_ba', None)
def GenerateMarketAreaProfile(in_features=..., segmentation_base=..., out_profile=...): # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """GenerateMarketAreaProfile_ba(in_features, segmentation_base, out_profile)

        Creates a segmentation profile by summarizing segments from standard
        geography boundaries within the input area.

     INPUTS:
      in_features (Feature Layer):
          The input feature class with polygon features used to create a
          segmentation area profile.
      segmentation_base (String):
          The segmentation base for the profile being created. Available options
          are provided by the segmentation dataset in use.

     OUTPUTS:
      out_profile (File):
          The name of the segmentation profile file to be created."""
    ...

@gptooldoc('GenerateSegmentationProfileReport_ba', None)
def GenerateSegmentationProfileReport(target_profile=..., base_profile=..., report_title=..., report_folder=..., report_format=...): # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """GenerateSegmentationProfileReport_ba(target_profile, base_profile, {report_title}, {report_folder}, {report_format;report_format...})

        Creates a report that displays segments of your customers and compares
        them to the study area (base profile).

     INPUTS:
      target_profile (File):
          A segmentation profile representing the segments to be profiled. The
          target profile usually represents your customer segmentation profile.
      base_profile (File):
          A segmentation profile representing the base profile segments. This is
          the segmentation used for comparison. The base profile usually
          represents your market area segmentation profile.
      report_title {String}:
          The title of the report.
      report_folder {Folder}:
          The output location to which the report will be saved.
      report_format {String}:
          The report output format. The default value is PDF. Additional
          available formats are XLSX, HTML, CSV, and PAGX."""
    ...

@gptooldoc('GenerateSurveyReportForProfile_ba', None)
def GenerateSurveyReportForProfile(target_profile=..., base_profile=..., survey_category=..., report_folder=..., sort_column=..., sort_order=..., report_title=..., report_format=...): # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """GenerateSurveyReportForProfile_ba(target_profile, base_profile, survey_category, report_folder, {sort_column}, {sort_order}, {report_title}, {report_format;report_format...})

        Displays characteristics from the consumer survey data for your target
        profile to determine customer lifestyle habits and preferences.

     INPUTS:
      target_profile (File):
          A segmentation profile representing the segments to be analyzed. The
          target profile usually represents your customer segmentation profile.
      base_profile (File):
          A segmentation profile representing the base profile segments. This is
          the segmentation used for comparison. The base profile usually
          represents your market area segmentation profile.
      survey_category (String):
          A category that contains characteristics from the consumer survey.
      report_folder (Folder):
          The output location where the report will be saved.
      sort_column {String}:
          Specifies the column to use to sort the report.

          * EXPECTED_NUMBER-Sort is based on counts-for example, number of
          adults. This is the default.

          * INDEX-Sort is based on rank.
      sort_order {String}:
          Specifies the order of the report, based on the sort column, in
          ascending or descending order.

          * ASCENDING-Sort in ascending order.

          * DESCENDING-Sort in descending order. This is the default.
      report_title {String}:
          The title of the report.
      report_format {String}:
          The report output format. The default value is PDF. Additional
          available formats are XLSX, HTML, CSV, and PAGX."""
    ...

@gptooldoc('GenerateSurveyReportForTargets_ba', None)
def GenerateSurveyReportForTargets(target_profile=..., target_group=..., core_target=..., developmental_target=..., report_folder=..., report_type=..., survey_categories=..., report_title=..., report_format=...): # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """GenerateSurveyReportForTargets_ba(target_profile, target_group, core_target, developmental_target, report_folder, {report_type}, {survey_categories;survey_categories...}, {report_title}, {report_format;report_format...})

        Displays the top characteristics, in each of the selected survey
        categories, of your Core and Developmental target groups, as well as
        your overall customer profile.

     INPUTS:
      target_profile (File):
          A segmentation profile representing the segments to be analyzed. The
          target profile usually represents your customer segmentation profile.
      target_group (File):
          A collection of segments grouped into targets. Targets represent
          segments that are selected based on similar characteristics-for
          example, segments that have high index and percent composition.
      core_target (String):
          A group of segments that make up a large percentage of your customer
          base and have an above average index, indicating likelihood to be a
          customer.
      developmental_target (String):
          A group of segments that make up a significant percentage of your
          customers and of the market area but do not have an above average
          index.
      report_folder (Folder):
          The output location where the report will be saved.
      report_type {String}:
          Specifies the survey categories to be added to the report.

          * UNDERSTANDING_YOUR_TARGET-Media-related characteristics-for example,
          reading, watching, and listening related.

          * DEVELOPING_MARKET_STRATEGIES-Leisure-related characteristics-for
          example, leisure, sports, and travel.

          * CUSTOM-User-defined characteristics. This is the default.
      survey_categories {String}:
          A category that contains the characteristics from the consumer survey.
      report_title {String}:
          The title of the report.
      report_format {String}:
          The report output format. The default value is PDF. Additional
          available formats are XLSX, HTML, CSV, and PAGX."""
    ...

@gptooldoc('GenerateTargetGroupLayer_ba', None)
def GenerateTargetGroupLayer(geography_level=..., segmentation_base=..., out_feature_class=..., target_group=..., boundary_layer=...): # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """GenerateTargetGroupLayer_ba(geography_level, segmentation_base, out_feature_class, target_group, {boundary_layer})

        Generates a layer that identifies geographies that contain selected
        segments and categorized groups based on targets.

     INPUTS:
      geography_level (String):
          The geography level that will be used to define the target layer.
      segmentation_base (String):
          The segmentation base for the profile being created. Available options
          are provided by the segmentation dataset in use.
      target_group (File):
          A user-created group of targets. This is used if the dataset supports
          target groups.
      boundary_layer {Feature Layer}:
          The boundary that determines the layer extent.

     OUTPUTS:
      out_feature_class (Feature Class):
          The output feature class for the target layer."""
    ...

@gptooldoc('GenerateTargetLayer_ba', None)
def GenerateTargetLayer(geography_level=..., segmentation_base=..., out_feature_class=..., input_type=..., target_group=..., target=..., segments=..., boundary_layer=...): # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """GenerateTargetLayer_ba(geography_level, segmentation_base, out_feature_class, input_type, {target_group}, {target}, {segments;segments...}, {boundary_layer})

        Creates a layer that identifies geographies that contain selected
        segments and geographies that do not contain selected segments.

     INPUTS:
      geography_level (String):
          The geography level that will be used to define the target layer.
      segmentation_base (String):
          The segmentation base for the profile being created. Available options
          are provided by the segmentation dataset in use.
      input_type (String):
          Specifies whether target groups or segments will be used.

          * USE_TARGET_GROUP-A group of targets will be used.

          * SELECT_SEGMENTS-Segments will be used. One or more segments can make
          up a target.
      target_group {File}:
          The target group, if the dataset supports target groups.
      target {String}:
          A target from the selected target_group.
      segments {String}:
          Segments from the provided dataset.
      boundary_layer {Feature Layer}:
          The boundary that determines the layer extent.

     OUTPUTS:
      out_feature_class (Feature Class):
          The output feature class for the target layer."""
    ...

@gptooldoc('GenerateTargetPenetrationLayer_ba', None)
def GenerateTargetPenetrationLayer(geography_level=..., segmentation_base=..., out_feature_class=..., input_type=..., target_group=..., target=..., segments=..., boundary_layer=...): # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """GenerateTargetPenetrationLayer_ba(geography_level, segmentation_base, out_feature_class, input_type, {target_group}, {target}, {segments;segments...}, {boundary_layer})

        Generates a layer based on the percent of penetration of selected
        segments, providing a detailed view of the concentrations of your
        target segments.

     INPUTS:
      geography_level (String):
          The geography level that will be used to define the target layer.
      segmentation_base (String):
          The segmentation base for the profile being created. Available options
          are provided by the segmentation dataset in use.
      input_type (String):
          The geographic layer containing the segmentation data or the target
          group.

          * USE_TARGET_GROUP-A target group will be used as the input type.

          * SELECT_SEGMENTS-Selected segments will be used as the input type.
          One or more segments can compose a target. This is the default.
      target_group {File}:
          A user-created group of targets. This parameter is used when the
          dataset supports target groups.
      target {String}:
          A target from the selected target_group.
      segments {String}:
          Segments from the provided dataset.
      boundary_layer {Feature Layer}:
          The boundary that determines the extent of the analysis.

     OUTPUTS:
      out_feature_class (Feature Class):
          The output feature class for the target layer."""
    ...

@gptooldoc('ImportSegmentationProfile_ba', None)
def ImportSegmentationProfile(in_table=..., segmentation_base=..., out_profile=..., segment_id_field=..., count_field=..., total_volume_field=...): # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """ImportSegmentationProfile_ba(in_table, segmentation_base, out_profile, segment_id_field, count_field, {total_volume_field})

        Generates a segmentation profile from a table.

     INPUTS:
      in_table (Table View):
          The input table with segmentation information.
      segmentation_base (String):
          The segmentation base for the profile being created. Available options
          are provided by the segmentation dataset in use.
      segment_id_field (Field):
          A string field that contains the segmentation code.
      count_field (Field):
          A numeric field that contains segment count information.
      total_volume_field {Field}:
          A numeric field that contains volume information.

     OUTPUTS:
      out_profile (File):
          The name of the segmentation file to be created."""
    ...

@gptooldoc('ImportSurveyProfiles_ba', None)
def ImportSurveyProfiles(profiles=..., out_folder=...): # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """ImportSurveyProfiles_ba(profiles;profiles..., out_folder)

        Imports segmentation profiles consisting of survey variable data.

     INPUTS:
      profiles (String):
          Categories of survey variables that can be selected for importing as
          profiles.
      out_folder (Folder):
          The folder selected to contain the profiles being created."""
    ...

@gptooldoc('AssignCustomersByDistance_ba', None)
def AssignCustomersByDistance(in_features=..., in_store_features=..., store_id_field=..., out_feature_class=..., link_field=..., distance_type=..., distance_units=..., travel_direction=..., time_of_day=..., time_zone=..., search_tolerance=...): # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """AssignCustomersByDistance_ba(in_features, in_store_features, store_id_field, out_feature_class, {link_field}, {distance_type}, {distance_units}, {travel_direction}, {time_of_day}, {time_zone}, {search_tolerance})

        Assigns customers to the closest store based on a selected distance
        type.

     INPUTS:
      in_features (Feature Layer):
          The input point feature layer representing customers.
      in_store_features (Feature Layer):
          The input point feature layer representing store or facilities.
      store_id_field (Field):
          A unique ID field for in_store_features.
      link_field {String}:
          A new field that contains the assigned store or facility ID.
      distance_type {String}:
          The method of travel used to calculate the distance between customers
          and stores.
      distance_units {String}:
          The units that will be used to measure the selected distance type.
      travel_direction {String}:
          Specifies the direction of travel that will be used between stores or
          facilities and customers.

          * TOWARD_STORES-The direction of travel will be from customers to
          stores. This is the default.

          * AWAY_FROM_STORES-The direction of travel will be from stores to
          customers.
      time_of_day {Date}:
          The time and date that will be used when calculating distance.
      time_zone {String}:
          Specifies the time zone that will be used for the time_of_day
          parameter.

          * TIME_ZONE_AT_LOCATION-The time zone in which the territories are
          located will be used. This is the default.

          * UTC-Coordinated universal time (UTC) will be used.
      search_tolerance {Linear Unit}:
          The maximum distance that input points can be from the network. Points
          located beyond the search tolerance will be excluded from
          processing.The parameter requires a distance value and units for the
          tolerance.
          The default value is 5000 meters.

     OUTPUTS:
      out_feature_class (Feature Class):
          A point layer containing customers with assigned store or facility and
          distance."""
    ...

@gptooldoc('CustomerDerivedTA_ba', None)
def CustomerDerivedTA(in_stores_layer=..., store_id_field=..., in_customers_layer=..., link_field=..., out_feature_class=..., method=..., rings=..., customer_aggregation_type=..., customer_weight_field=..., exclude_outlying_customers=..., cutoff_distance=..., dissolve_option=..., use_customer_centroids=..., distance_type=..., units=..., travel_direction=..., time_of_day=..., time_zone=..., search_tolerance=..., polygon_detail=..., iterations_limit=..., minimum_step=..., target_percent_diff=...): # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """CustomerDerivedTA_ba(in_stores_layer, store_id_field, in_customers_layer, link_field, out_feature_class, method, rings;rings..., customer_aggregation_type, {customer_weight_field}, {exclude_outlying_customers}, {cutoff_distance}, {dissolve_option}, {use_customer_centroids}, {distance_type}, {units}, {travel_direction}, {time_of_day}, {time_zone}, {search_tolerance}, {polygon_detail}, {iterations_limit}, {minimum_step}, {target_percent_diff})

        Creates trade areas around stores based on the number of customers or
        volume attribute of each customer.

     INPUTS:
      in_stores_layer (Feature Layer):
          A point layer representing store or facility locations.
      store_id_field (Field):
          The unique ID field representing a store or facility location.
      in_customers_layer (Feature Layer):
          An input point layer representing customers or patrons.
      link_field (Field):
          An ID field that will be used to assign individual customers to
          stores.
      method (String):
          Specifies the type of customer-derived trade area that will be
          generated.

          * SIMPLE-A generalized trade area based on the percentages of
          customers corresponding to each store will be generated.

          * AMOEBA-Points representing the boundary of the polygon trade area
          will be connected using natural curvature.

          * DETAILED-Points representing the boundary of the polygon trade area
          will be connected using straight lines.

          * DETAILED_WITH_SMOOTHING-Points representing the boundary of the
          polygon trade area will be connected with smoothed curves using cubic
          splines. This approach takes into account the shape and pattern of the
          customer distributions. This is the default.

          * THRESHOLD_RINGS-Concentric rings that expand from input stores
          until they contain the specified threshold of customers will be
          generated.

          * THRESHOLD_DRIVETIMES-Polygons that expand from stores along network
          routes until they contain the specified threshold of customers will be
          generated.
      rings (Double):
          The values that will be used to represent the percentage of
          customers-for example, total count or a customer attribute and total
          sales assigned to each store. Each value represents one trade area
          polygon.
      customer_aggregation_type (String):
          Specifies the type of aggregation that will be used.

          * COUNT-Percentage-based trade areas will be calculated using the
          geographic locations of customers. This is the default.

          * WEIGHT-Percentage-based trade areas will be calculated using a
          customer attribute-for example, sales.
      customer_weight_field {Field}:
          The field that will be used to calculate the trade areas. This is
          based on either the number of customers (count) or the calculated
          weighted value assigned to each customer.
      exclude_outlying_customers {Boolean}:
          Specifies whether outlying customers will be excluded from the trade
          area generation.

          * EXCLUDE_OUTLIERS-Outlying customers will be excluded.

          * ALL_POINTS-Outlying customers will not be excluded; all customers
          will be considered. This is the default.
      cutoff_distance {Linear Unit}:
          The distance beyond which customers will be considered outliers and
          excluded from consideration during trade area generation.
      dissolve_option {String}:
          Specifies whether polygons of the entire area will be created or the
          polygons will be split into individual features.

          * OVERLAP-Output polygons will be generated in which each feature
          begins at zero and grows to satisfy the specified percentage of
          customers. For example, if you specify a trade area of 50 percent and
          70 percent of your customers, one polygon will be generated to include
          0 to 50 percent and a second polygon will include all 0 to 70 percent
          of customers. This is the default.

          * SPLIT-Output polygons will be generated for individual features
          based on the specified percentage breaks. For example, if you specify
          a trade area of 50 percent and 70 percent of your customers, one
          polygon will be generated to include 0 to 50 percent and a second
          polygon will include 50 to 70 percent of customers.
      use_customer_centroids {Boolean}:
          Specifies whether the centroid of your customer area will be used to
          calculate trade areas outward from this point.

          * USE_CENTROIDS-The centroid of customer points will be used to
          calculate trade areas.

          * USE_STORES-The centroid of customer points will not used; store
          location will be used as the starting point to calculate trade areas.
          This is the default.
      distance_type {String}:
          The method of travel that will be used to calculate the distance.
      units {String}:
          The units that will be used for the distance values.
      travel_direction {String}:
          Specifies the direction of travel that will be used between stores and
          customers.

          * TOWARD_STORES-The direction of travel will be from customers to
          stores. This is the default.

          * AWAY_FROM_STORES-The direction of travel will be from stores to
          customers.
      time_of_day {Date}:
          The time and date that will be used when calculating distance.
      time_zone {String}:
          Specifies the time zone that will be used for the time_of_day
          parameter.

          * TIME_ZONE_AT_LOCATION-The time zone in which the territories are
          located will be used. This is the default.

          * UTC-Coordinated universal time (UTC) will be used.
      search_tolerance {Linear Unit}:
          The maximum distance that input points can be from the network. Points
          located beyond the search tolerance will be excluded from
          processing.The parameter requires a distance value and units for the
          tolerance.
      polygon_detail {String}:
          Specifies the level of detail that will be used for the output drive
          time polygons.

          * STANDARD-Polygons with a standard level of detail will be created.
          This is the default.

          * GENERALIZED-Generalized polygons will be created using the hierarchy
          present in the network data source to produce results quickly.

          * HIGH-Polygons with a high level of detail will be created for
          applications in which precise results are important.
      iterations_limit {Long}:
          Restricts the number of drive times that can be used to find the
          optimal threshold limit.
      minimum_step {Double}:
          The minimum increment distance or time-for example, 1 mile or 1
          minute-that will be used between iterations to expand until the
          threshold is reached.
      target_percent_diff {Double}:
          The maximum percentage difference between the target value and
          threshold value that will be used when determining the threshold drive
          time, for example, 5 percent. The default value is 5.

     OUTPUTS:
      out_feature_class (Feature Class):
          The output trade area feature class."""
    ...

@gptooldoc('GenerateApproximateDriveTimes_ba', None)
def GenerateApproximateDriveTimes(in_features=..., out_feature_class=..., distance_type=..., units=..., in_stores_layer=..., store_id_field=..., link_field=..., iterations_limit=..., minimum_step=..., target_percent_diff=..., travel_direction=..., time_of_day=..., time_zone=..., search_tolerance=..., polygon_detail=...): # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """GenerateApproximateDriveTimes_ba(in_features, out_feature_class, distance_type, {units}, {in_stores_layer}, {store_id_field}, {link_field}, {iterations_limit}, {minimum_step}, {target_percent_diff}, {travel_direction}, {time_of_day}, {time_zone}, {search_tolerance}, {polygon_detail})

        Creates trade areas that approximate the size, shape, and area of
        existing polygons using available routes from the selected distance
        type.

     INPUTS:
      in_features (Feature Layer):
          The input polygon feature layer.
      distance_type (String):
          The method of travel used to create the output polygons.
      units {String}:
          The distance units to be used with the threshold values.
      in_stores_layer {Feature Layer}:
          A point layer that will be used as the starting point for creating
          network service areas.
      store_id_field {Field}:
          The ID that uniquely identifies each in_stores_layer point.
      link_field {Field}:
          The ID that uniquely identifies each in_features point.
      iterations_limit {Long}:
          The maximum number of drive times that can be used to find the optimal
          threshold limit.
      minimum_step {Double}:
          The minimum increment distance or time-for example, 1 mile or 1
          min-that will be used between iterations to expand until the threshold
          is reached.
      target_percent_diff {Double}:
          The maximum difference between the target value and threshold value
          when determining the threshold drive time, for example, 5 percent. The
          default value is 5.
      travel_direction {String}:
          Specifies the direction of travel for output polygon creation.

          * TOWARD_STORES-The direction of travel will be from customers to
          stores. This is the default.

          * AWAY_FROM_STORES-The direction of travel will be from stores to
          customers.
      time_of_day {Date}:
          The time and date that will be used when calculating distance.
      time_zone {String}:
          Specifies the time zone that will be used for the time_of_day
          parameter.

          * TIME_ZONE_AT_LOCATION-The time zone in which the territories are
          located will be used. This is the default.

          * UTC-Coordinated universal time (UTC) will be used.
      search_tolerance {Linear Unit}:
          The maximum distance that input points can be from the network.The
          default value is 5000 meters.
      polygon_detail {String}:
          Specifies the level of detail that will be used for the output drive
          time polygons.

          * STANDARD-Polygons with a standard level of detail will be created.
          This is the default.

          * GENERALIZED-Generalized polygons will be created using the hierarchy
          present in the network data source to produce results quickly.

          * HIGH-Polygons with a high level of detail will be created for
          applications in which precise results are important.

     OUTPUTS:
      out_feature_class (Feature Class):
          The output feature class containing the drive time polygons."""
    ...

@gptooldoc('GenerateDriveTimeTradeArea_ba', None)
def GenerateDriveTimeTradeArea(in_features=..., out_feature_class=..., distance_type=..., distances=..., units=..., id_field=..., dissolve_option=..., remove_overlap=..., travel_direction=..., time_of_day=..., time_zone=..., search_tolerance=..., polygon_detail=..., input_method=..., expression=...): # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """GenerateDriveTimeTradeArea_ba(in_features, out_feature_class, distance_type, {distances;distances...}, {units}, {id_field}, {dissolve_option}, {remove_overlap}, {travel_direction}, {time_of_day}, {time_zone}, {search_tolerance}, {polygon_detail}, {input_method}, {expression})

        Creates a feature class of trade areas around point features based on
        travel time and distance.

     INPUTS:
      in_features (Feature Layer):
          The input point feature layer.
      distance_type (String):
          The method of travel that will be used for drive time calculation.
      distances {Double}:
          The distances that will be used for drive time calculations.
      units {String}:
          The units that will be used for the distance values. The default value
          is miles.
      id_field {Field}:
          A unique ID field for existing facilities.
      dissolve_option {String}:
          Specifies whether overlapping or nonoverlapping service areas for a
          single location will be used when multiple distances are specified.

          * OVERLAP-Each polygon will include the area reachable from the
          facility up to the distance value. This is the default.

          * SPLIT-Each polygon will include only the area between consecutive
          distance values.
      remove_overlap {Boolean}:
          Specifies whether overlapping concentric rings will be created or
          overlap will be removed from multiple locations in relation to one
          another.

          * REMOVE_OVERLAP-Polygons will be split and the overlap between output
          features will be removed.

          * KEEP_OVERLAP-Output features will be created with overlap. This is
          the default.
      travel_direction {String}:
          Specifies the direction of travel that will be used between stores and
          customers.

          * TOWARD_STORES-The direction of travel will be from customers to
          stores. This is the default.

          * AWAY_FROM_STORES-The direction of travel will be from stores to
          customers.
      time_of_day {Date}:
          The time and date that will be used when calculating distance.
      time_zone {String}:
          Specifies the time zone that will be used for the Time of Day
          parameter.

          * TIME_ZONE_AT_LOCATION-The time zone in which the territories are
          located will be used. This is the default.

          * UTC-Coordinated universal time (UTC) will be used.
      search_tolerance {Linear Unit}:
          The maximum distance that input points can be from the network. Points
          located beyond the search tolerance will be excluded from
          processing.This parameter requires a distance value and units for the
          tolerance.
          The default value is 5000 meters.
      polygon_detail {String}:
          Specifies the level of detail that will be used for the output drive
          time polygons.

          * STANDARD-Polygons with a standard level of detail will be created.
          This is the default.

          * GENERALIZED-Generalized polygons will be created using the hierarchy
          present in the network data source to produce results quickly.

          * HIGH-Polygons with a high level of detail will be created for
          applications in which precise results are important.
      input_method {String}:
          Specifies the type of value that will be used for each drive time.

          * VALUES-A constant value will be used (all trade areas will be the
          same size). This is the default.

          * EXPRESSION-The values from a field or an expression will be used
          (trade areas can be a different size).
      expression {SQL Expression}:
          A fields-based expression used to calculate drive time.

     OUTPUTS:
      out_feature_class (Feature Class):
          The output feature class containing the drive time polygons."""
    ...

@gptooldoc('GenerateGeographiesFromOverlay_ba', None)
def GenerateGeographiesFromOverlay(geography_level=..., in_features=..., id_field=..., out_feature_class=..., overlap_type=..., ratios=...): # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """GenerateGeographiesFromOverlay_ba(geography_level, in_features, id_field, out_feature_class, {overlap_type}, {ratios})

        Generates trade areas from the features of an input standard geography
        level that has a specified spatial relationship with the input.

     INPUTS:
      geography_level (String):
          The geography level that will be used to define the trade area.
      in_features (Feature Layer):
          The features used to extract the standard geography level features by
          the specified spatial relationship. It can be either all features from
          the layer or only those selected once a selection is available.
      id_field (Field):
          The field used to identify the input_features parameter-for example,
          the IDs of drive time polygons.
      overlap_type {String}:
          Specifies how the subgeography will be selected from the boundary
          layer.

          * INTERSECT-If any of the subgeography features touch or intersect the
          boundary layer, they will be included in the output layer. This is the
          default.

          * CENTROID_WITHIN-If the centroids of any of the subgeography features
          are contained within the boundary layer, they will be included in the
          output layer.

          * COMPLETELY_WITHIN-Only the features of the subgeography layer that
          are completely contained within the boundary layer will be included in
          the output layer.
      ratios {String}:
          Specifies the ratios to be calculated.

          * NO_RATIOS-No ratios will be implemented. This is the default.

          * AREA_ONLY-Only the ratios within the portion (area) of the standard
          geography level that intersects an input feature will be implemented.

          * ALL_RATIOS-All available ratios will be implemented. This option is
          not available when using online data.

     OUTPUTS:
      out_feature_class (Feature Class):
          The output feature containing the trade area."""
    ...

@gptooldoc('GenerateThresholdDriveTimeTradeArea_ba', None)
def GenerateThresholdDriveTimeTradeArea(in_features=..., out_feature_class=..., threshold_variable=..., threshold_values=..., distance_type=..., units=..., id_field=..., travel_direction=..., time_of_day=..., time_zone=..., search_tolerance=..., polygon_detail=..., iterations_limit=..., minimum_step=..., target_percent_diff=..., input_method=..., expression=...): # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """GenerateThresholdDriveTimeTradeArea_ba(in_features, out_feature_class, threshold_variable, {threshold_values;threshold_values...}, distance_type, {units}, {id_field}, {travel_direction}, {time_of_day}, {time_zone}, {search_tolerance}, {polygon_detail}, {iterations_limit}, {minimum_step}, {target_percent_diff}, {input_method}, {expression})

        Creates a feature class of network distance trade areas that expand
        around point features until criteria is reached.

     INPUTS:
      in_features (Feature Layer):
          The input point feature layer.
      threshold_variable (String):
          The selected Business Analyst dataset variable to which the threshold
          value will be applied.
      threshold_values {Double}:
          The threshold variable value that will determine the size of the
          output rings. The rings will expand until they contain the threshold
          value of the selected variable.
      distance_type (String):
          The method of travel that will be used to create the output polygons.
      units {String}:
          The distance units that will be used with the threshold values.
      id_field {Field}:
          The ID that uniquely identifies each input point and is included in
          the output as an attribute.
      travel_direction {String}:
          Specifies the direction of travel that will be used for output polygon
          creation.

          * TOWARD_STORES-The direction of travel will be from customers to
          stores. This is the default.

          * AWAY_FROM_STORES-The direction of travel will be from stores to
          customers.
      time_of_day {Date}:
          The time and date that will be used when calculating distance.
      time_zone {String}:
          Specifies the time zone that will be used for the Time of Day
          parameter.

          * TIME_ZONE_AT_LOCATION-The time zone in which the territories are
          located will be used. This is the default.

          * UTC-Coordinated universal time (UTC) will be used.
      search_tolerance {Linear Unit}:
          The maximum distance that input points can be from the network.The
          default value is 5000 meters.
      polygon_detail {String}:
          Specifies the level of detail that will be used for the output drive
          time polygons.

          * STANDARD-Polygons with a standard level of detail will be created.
          This is the default.

          * GENERALIZED-Generalized polygons will be created using the hierarchy
          present in the network data source to produce results quickly.

          * HIGH-Polygons with a high level of detail will be created for
          applications in which precise results are important.
      iterations_limit {Long}:
          Restricts the number of drive times that can be used to find the
          optimal threshold limit.
      minimum_step {Double}:
          The minimum distance between one threshold area candidate and the next
          as the model approaches the threshold value to prevent infinite
          iterations.
      target_percent_diff {Double}:
          The maximum percentage difference between the target value and
          threshold value that will be used when determining the threshold drive
          time, for example, 5 percent. The default value is 5.
      input_method {String}:
          Specifies the type of value that will be used for each drive time.

          * VALUES-A constant value will be used (all trade areas will be the
          same size). This is the default.

          * EXPRESSION-The values from a field or an expression will be used
          (trade areas can be a different size).
      expression {SQL Expression}:
          A fields-based expression that will be used to calculate drive time.

     OUTPUTS:
      out_feature_class (Feature Class):
          The output feature class containing the drive time polygons."""
    ...

@gptooldoc('GenerateThresholdRingTradeArea_ba', None)
def GenerateThresholdRingTradeArea(in_features=..., out_feature_class=..., threshold_variable=..., threshold_values=..., units=..., id_field=..., input_method=..., expression=..., minimum_step=..., target_percent_diff=...): # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """GenerateThresholdRingTradeArea_ba(in_features, out_feature_class, threshold_variable, {threshold_values;threshold_values...}, {units}, {id_field}, {input_method}, {expression}, {minimum_step}, {target_percent_diff})

        Creates a feature class of ring trade areas that expand around point
        features until the threshold value is reached.

     INPUTS:
      in_features (Feature Layer):
          The input point feature layer.
      threshold_variable (String):
          The selected Business Analyst dataset variable to which the threshold
          value will be applied.
      threshold_values {Double}:
          The threshold variable value that will determine the size of the
          output rings. The rings will expand until they contain the threshold
          value of the selected variable.
      units {String}:
          The distance units to be used with the threshold values.
      id_field {Field}:
          The ID that uniquely identifies each input point and is included in
          the output as an attribute.
      input_method {String}:
          Specifies the type of value that will be used for each drive time.

          * VALUES-A constant value will be used (all trade areas will be the
          same size). This is the default.

          * EXPRESSION-The values from a field or an expression will be used
          (trade areas can be a different size).
      expression {SQL Expression}:
          A fields-based expression that will be used to calculate the radii.
      minimum_step {Double}:
          The minimum distance between one threshold area candidate and the next
          as the model approaches the threshold value to prevent infinite
          iterations.
      target_percent_diff {Double}:
          The maximum percentage difference between the target value and
          threshold value that will be used when determining the threshold drive
          time, for example, 5 percent. The default value is 5.

     OUTPUTS:
      out_feature_class (Feature Class):
          The output feature class containing the threshold rings."""
    ...

@gptooldoc('GenerateTradeAreaRings_ba', None)
def GenerateTradeAreaRings(in_features=..., out_feature_class=..., radii=..., units=..., id_field=..., remove_overlap=..., dissolve_option=..., input_method=..., expression=...): # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """GenerateTradeAreaRings_ba(in_features, out_feature_class, {radii;radii...}, {units}, {id_field}, {remove_overlap}, {dissolve_option}, {input_method}, {expression})

        Creates rings around point locations.

     INPUTS:
      in_features (Feature Layer):
          The input features containing the center points for the rings.
      radii {Double}:
          The distances, in ascending size, used to create rings around the
          input features.
      units {String}:
          The linear unit to be used with the distance values.
      id_field {Field}:
          A unique ID field in the ring center layer.
      remove_overlap {Boolean}:
          Creates overlapping concentric rings or removes overlap.

          * REMOVE_OVERLAP-Thiessen polygons are used to remove overlap between
          output ring polygons.

          * KEEP_OVERLAP-Output ring features are created with overlap. This is
          the default.
      dissolve_option {String}:
          Specifies whether overlapping or nonoverlapping service areas for a
          single location will be used when multiple distances are specified.

          * OVERLAP-Each polygon will include the area reachable from the
          facility up to the distance value. This is the default.

          * SPLIT-Each polygon will include only the area between consecutive
          distance values.
      input_method {String}:
          Specifies the type of value that is to be used for each drive time.

          * VALUES-Uses a constant value (all trade areas will be the same
          size). This is the default.

          * EXPRESSION-The values from a field or an expression (trade areas can
          be a different size).
      expression {SQL Expression}:
          A fields-based expression to calculate the radii.

     OUTPUTS:
      out_feature_class (Feature Class):
          The feature class that will contain the output ring features."""
    ...

@gptooldoc('MeasureCannibalization_ba', None)
def MeasureCannibalization(in_features=..., area_id_field=..., area_description_field=..., out_feature_class=..., store_id_field=..., create_report=..., report_title=..., report_folder=..., report_format=..., variables=...): # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """MeasureCannibalization_ba(in_features, area_id_field, area_description_field, out_feature_class, {store_id_field}, {create_report}, {report_title}, {report_folder}, {report_format;report_format...}, {variables;variables...})

        Calculates the amount of overlap between two or more polygons. Overlap
        refers to the extent of the polygons beyond intersection.

     INPUTS:
      in_features (Feature Layer):
          The input polygon features that will be analyzed for overlap.
      area_id_field (Field):
          The field that uniquely identifies each feature in the input layer.
      area_description_field (Field):
          The field that describes each feature in the input layer.
      store_id_field {Field}:
          The unique ID that associates a store with each polygon when the
          inputs are trade areas.
      create_report {Boolean}:
          Specifies whether a report will be generated.

          * CREATE_REPORT-A report will be generated.

          * DO_NOT_CREATE_REPORT-A report will not be generated. This is the
          default.
      report_title {String}:
          The title of the report. The default value is Measure Cannibalization.
      report_folder {Folder}:
          The output location where the report will be saved.
      report_format {String}:
          The output format or formats of the report.
      variables {String}:
          One or more variables that will be used to calculate additional
          overlap metrics-for example, the total number of people and households
          in intersection areas, or the percentage of the total number of people
          and households in a trade area falling into overlapped area.

     OUTPUTS:
      out_feature_class (Feature Class):
          The output feature class that will contain the areas of overlap found
          in the input layer."""
    ...

@gptooldoc('RemoveOverlap_ba', None)
def RemoveOverlap(in_features=..., out_feature_class=..., method=..., define_trade_area=..., ring_id_field=..., weight_field=..., store_id=..., in_stores_layer=..., link_field=...): # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """RemoveOverlap_ba(in_features, out_feature_class, {method}, {define_trade_area}, {ring_id_field}, {weight_field}, {store_id}, {in_stores_layer}, {link_field})

        Removes overlap between two or more areas to form adjacent boundaries.

     INPUTS:
      in_features (Feature Layer):
          The input features containing the overlapping polygons.
      method {String}:
          Specifies how the overlap between trade areas will be removed.

          * CENTER_LINE-Overlap will be removed by creating a border that
          evenly distributes the area of intersection between polygons. This is
          the default.

          * THIESSEN-Overlap will be removed using straight lines to divide the
          area of intersection.

          * GRID-Overlap will be removed by creating a grid of parallel lines
          used to define a natural division between polygons.
      define_trade_area {Boolean}:
          Specifies whether ring overlap in a trade area will be removed.

          * DEFINE_TRADE_AREA-Overlap will only be removed between polygons with
          equal values in the ring_id_field parameter.

          * DO_NOT_DEFINE_TRADE_AREA-Overlap will be removed from all
          intersecting polygons. This is the default.
      ring_id_field {Field}:
          A field from the input that defines common trade areas. Overlap
          between polygons will only be removed if their values in this field
          are equal.
      weight_field {Field}:
          A field from the input used to influence removal of overlap based on
          its values.
      store_id {Field}:
          A unique ID field in the stores feature layer.
      in_stores_layer {Feature Layer}:
          The input features containing the center points for the overlapping
          trade areas.
      link_field {Field}:
          A unique ID field representing a store or facility location.

     OUTPUTS:
      out_feature_class (Feature Class):
          The feature class containing the new trade area features."""
    ...

@gptooldoc('RemoveOverlapMultiple_ba', None)
def RemoveOverlapMultiple(in_features=..., out_feature_class=..., method=..., join_attributes=...): # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """RemoveOverlapMultiple_ba(in_features;in_features..., out_feature_class, {method}, {join_attributes})

        Removes overlap between polygons contained in multiple input layers.

     INPUTS:
      in_features (Value Table):
          The input features containing the overlapping polygons.
      method {String}:
          Specifies how the overlap between trade areas will be removed.

          * CENTER_LINE-Overlap will be removed by creating a border that evenly
          distributes the area of intersection between polygons. This is the
          default.

          * THIESSEN-Overlap will be removed using straight lines to divide the
          area of intersection.

          * GRID-Overlap will be removed by creating a grid of parallel lines
          used to define a natural division between polygons.
      join_attributes {String}:
          Specifies which attributes of input layers will be copied to the
          output.

          * ALL-All attributes from the input features will be transferred to
          the output feature class. This is the default.

          * NO_FID-All attributes from the input features, except the FID field,
          will be transferred to the output feature class.

          * ONLY_FID-Only the FID field from the input features will be
          transferred to the output feature class.

     OUTPUTS:
      out_feature_class (Feature Class):
          The feature class containing the new trade area features."""
    ...

@gptooldoc('StandardGeographyTA_ba', None)
def StandardGeographyTA(geography_level=..., out_feature_class=..., input_type=..., in_ids_table=..., geography_key_field=..., ids_list=..., summarize_duplicates=..., group_field=..., dissolve_output=...): # -> conversion | int | float | complex | basestring | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown]:
    """StandardGeographyTA_ba(geography_level, out_feature_class, {input_type}, {in_ids_table}, {geography_key_field}, {ids_list}, {summarize_duplicates}, {group_field}, {dissolve_output})

        Creates trade areas based on predefined named statistical areas. This
        tool does not consume credits.

     INPUTS:
      geography_level (String):
          The geography level that will be used to define the trade area.
      input_type {String}:
          Specifies whether the geography IDs will be from a table or a list.

          * TABLE-The input IDs will be from a table.

          * LIST-The input IDs will be from a list. This is the default.
      in_ids_table {Table View}:
          The input table with IDs that will be used to select geographies that
          will define the trade area.
      geography_key_field {Field}:
          A field with in_ids_table that identifies the records that will be
          included in the output.
      ids_list {String}:
          The input list of comma-separated geography IDs.
      summarize_duplicates {Boolean}:
          Specifies whether duplicate fields in the table containing matching
          geography IDs will be summarized.

          * SUMMARIZE_DUPLICATES-The numeric fields for all duplicate records
          will be summarized.

          * USE_FIRST-The data of the first record will be appended. Other
          records will be ignored. This is the default.
      group_field {Field}:
          The field that will be used to perform a group by operation.
      dissolve_output {Boolean}:
          Specifies whether the output will be dissolved based on the
          group_field parameter value.

          * DISSOLVE-The output will be dissolved.

          * DONT_DISSOLVE-The output will not be dissolved. This is the default.

     OUTPUTS:
      out_feature_class (Feature Class):
          The output feature containing the trade area."""
    ...

