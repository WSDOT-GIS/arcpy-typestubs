"""
This type stub file was generated by pyright.
"""

__all__ = ['ApparentReflectance', 'Apply', 'ArgStatistics', 'Arithmetic', 'Aspect', 'AspectSlope', 'BandArithmetic', 'BAI', 'Buffered', 'CIg', 'CIre', 'Classify', 'ClayMinerals', 'Colormap', 'ColormapToRGB', 'ColorspaceConversion', 'Complex', 'CompositeBand', 'ComputeChange', 'Contour', 'ContrastBrightness', 'Convolution', 'Curvature', 'DetectChangeUsingChangeAnalysis', 'EVI', 'ElevationVoidFill', 'EqualToFrequency', 'ExtractBand', 'FerrousMinerals', 'GEMI', 'GenerateTrend', 'Geometric', 'GeometricMedian', 'GNDVI', 'GVITM', 'Grayscale', 'GreaterThanFrequency', 'HeatIndex', 'HighestPosition', 'Hillshade', 'InterpolateRasterByDimension', 'IronOxide', 'LessThanFrequency', 'LinearUnmixing', 'Lookup', 'LowestPosition', 'MLClassify', 'MNDWI', 'MSAVI', 'MTVI2', 'Mask', 'Majority', 'Max', 'Mean', 'Median', 'Min', 'Minority', 'NBR', 'NDBI', 'NDMI', 'NDSI', 'NDVI', 'NDVIre', 'NDWI', 'PVI', 'Pansharpen', 'Percentile', 'Popularity', 'PredictUsingTrend', 'RTVICore', 'RadarCalibration', 'Range', 'Rank', 'RasterCalculator', 'RasterizeFeatures', 'RegionGrow', 'Remap', 'Reproject', 'Resample', 'S1RadiometricCalibration', 'S1ThermalNoiseRemoval', 'SAVI', 'SR', 'SRre', 'SegMeanShift', 'ShadedRelief', 'Slope', 'Speckle', 'SpectralConversion', 'Statistics', 'StatisticsHistogram', 'StdDev', 'Stretch', 'Sultan', 'Sum', 'TSAVI', 'TasseledCap', 'Threshold', 'TransposeBits', 'TrendToRGB', 'UnitConversion', 'VARI', 'Variety', 'VectorField', 'VectorFieldRenderer', 'WindChill', 'ZonalRemap']
def Grayscale(raster, conversion_parameters=...):
    """
    The Grayscale function converts a multi-band image into a single-band Grayscale
    image. Specified weights are applied to each of the input bands, and a
    normalization is applied for output.

    Parameters:
      raster(Raster): the input raster
      conversion_parameters(List): array of double (A length of N array representing weights for each band, where N=band count.)

    Returns:
      output_raster(Raster): The output raster with this function applied to it
    """
    ...

def Arithmetic(raster1, raster2, operation_type=..., extent_type=..., cellsize_type=...):
    """
    The Arithmetic function performs an Arithmetic operation between two rasters or a raster and a scalar, and vice versa.

    Parameters:
      raster1(Raster): the first raster (can be scalar)
      raster2(Raster): the 2nd raster (can be scalar)
      operation_type(string): one of "Plus", "Minus", "Multiply", "Divide", "Power", "Mode"
      extent_type(string): one of "FirstOf", "IntersectionOf" "UnionOf", "LastOf"
      cellsize_type(string): one of "FirstOf", "MinOf", "MaxOf "MeanOf", "LastOf"

    Returns:
      output_raster(Raster): The output raster with the function applied to it
    """
    ...

def ArgStatistics(rasters, stat_type=..., min_value=..., max_value=..., multiple_occurrence_value=..., ignore_nodata=..., extent_type=..., cellsize_type=...):
    """
    The ArgStatistics function produces an output with a pixel value that represents a statistical metric from all
    bands of input rasters. The statistics can be the band index (or the slice index for multidimensional raster) of the maximum, minimum, or median value, or the
    duration (number of bands) between a minimum and maximum value



    Parameters:
      rasters(list of Rasters): Input rasters
      stat_type(string): one of "max", "min", "median", "duration"
      min_value(double): required if the type is duration
      max_value(double): required if the type is duration
      multiple_occurrence_value(int): the value will be returned when the max or min value occurred at multiple bands or slices. required if stat_ype is max or min
      ignore_nodata(bool): default is True, in this case, only cells that have data values will be used in determining the output value. False: the output value will be nodata value if one of the cells have a value of NoData
      extent_type(string): one of "FirstOf", "IntersectionOf" "UnionOf", "LastOf"
      cellsize_type(string): one of "FirstOf", "MinOf", "MaxOf "MeanOf", "LastOf"



    Returns:
      output_raster(Raster): The output raster
    """
    ...

def Aspect(raster):
    """
    Aspect identifies the downslope direction of the maximum rate of change in value from each cell to its neighbors.
    Aspect can be thought of as the slope direction. The values of the output raster will be the compass direction of
    the Aspect.

    Parameters:
      raster(Raster): Input raster

    Returns:
      output_raster(Raster): The output raster with this function applied to it
    """
    ...

def BandArithmetic(raster, band_ids, method=...):
    """

    The BandArithmetic function performs an arithmetic operation on the bands of a raster.

    Parameters:
      raster(Raster): Input raster
      band_ids(String): band ids (one-based) seperated by space
      method(int): Default 1. The type of band arithmetic algorithm you want to deploy.
                   You can define your custom algorithm, or choose a predefined index.
                   0 = UserDefined,
                   1 = NDVI,
                   2 = SAVI,
                   3 = TSAVI,
                   4 = MSAVI,
                   5 = GEMI,
                   6 = PVI,
                   7 = GVITM,
                   8 = Sultan,
                   9 = VARI,
                   10 = GNDVI,
                   11 = SR,
                   12 = NDVIre,
                   13 = SRre,
                   14 = MTVI2,
                   15 = RTVICore,
                   16 = CIre,
                   17 = CIg,
                   18 = NDWI,
                   19 = EVI,
                   20 = IronOxide,
                   21 = FerrousMinerals,
                   22 = ClayMinerals
                   23 = WNDWI

    Returns:
      output_raster(Raster): The output raster with this function applied to it
    """
    ...

def BAI(raster, red_band_id=..., nir_band_id=...):
    """
    Burn Area Index (BAI)
    The Burn Area Index (BAI) uses the reflectance values in the red and NIR portion of the spectrum to identify
    the areas of the terrain affected by fire.

    BAI = 1/((0.1 -RED)^2 + (0.06 - NIR)^2)

    :param raster: the input raster / imagery layer
    :param red_band_id: the band ID of the red band, e.g.,6. Note that band ID uses one-based indexing.
    :param nir_band_id: the band ID of the nir band, e.g.,5. Note that band ID uses one-based indexing.
    :return: Burn Area Index raster
    """
    ...

def CIg(raster, nir_band_id=..., green_band_id=...):
    """
    The Chlorophyll Index - Green (CIg) is a vegetation index for estimating
    the chlorophyll content in leaves using the ratio of reflectivity in
    the near-infrared (NIR) and green bands.

    CIg = [(NIR / Green)-1]

    Parameters:
      raster(Raster): Input raster
      nir_band_id(int): NIR band ID, e.g., 7. Note that band ID uses one-based indexing.
      green_band_id(int): green band ID, e.g., 3. Note that band ID uses one-based indexing.

    Returns:
      output_raster(Raster): The output raster with this function applied to it
    """
    ...

def CIre(raster, nir_band_id=..., redEdge_band_id=...):
    """
    The Chlorophyll Index - Red-Edge (CIre) is a vegetation index for estimating
    the chlorophyll content in leaves using the ratio of reflectivity in the
    near-infrared (NIR) and red-edge bands.

    CIre = [(NIR / RedEdge)-1]

    Parameters:
      raster(Raster): Input raster
      nir_band_id(int): NIR band ID, e.g., 7. Note that band ID uses one-based indexing.
      redEdge_band_id(int): red-edge band ID, e.g., 6. Note that band ID uses one-based indexing.

    Returns:
      output_raster(Raster): The output raster with this function applied to it
    """
    ...

def ClayMinerals(raster, swir1_band_id=..., swir2_band_id=...):
    """
    The Clay Minerals (CM) ratio is a geological index for identifying
    mineral features containing clay and alunite using two shortwave
    infrared (SWIR) bands. CM is used in mineral composite mapping.

    CM = SWIR1 / SWIR2

    Parameters:
      raster(Raster): Input raster
      swir1_band_id(int): SWIR1 band ID, e.g., 6. Note that band ID uses one-based indexing.
      swir2_band_id(int): SWIR2 band ID, e.g., 7. Note that band ID uses one-based indexing.

    Returns:
      output_raster(Raster): The output raster with this function applied to it
    """
    ...

def ColorspaceConversion(raster, conversion_type=...):
    """
    The ColorspaceConversion function converts the color model of a three-band
    unsigned 8-bit image from either the hue, saturation, and value (HSV)
    to red, green, and blue (RGB) or vice versa. An ExtractBand function and/or
    a Stretch function are sometimes used for converting the imagery into valid
    input of ColorspaceConversion function.

    Parameters:
      raster(Raster): Input raster. The pixeltype should be unsigned 8-bit
      conversion_type(string):  one of "rgb_to_hsv" or "hsv_to_rgb". Default is "rgb_to_hsv"

    Returns:
      output_raster(Raster): The output raster with this function applied to it
    """
    ...

def ColormapToRGB(raster):
    """
    The function is designed to work with single band image service that has
    internal colormap. It will convert the image into a three-band 8-bit RGB
    raster. This function takes no arguments except an input raster.

    Parameters:
      raster(Raster): Input raster

    Returns:
      output_raster(Raster): The output raster with this function applied to it
    """
    ...

def Colormap(raster, colormap=..., colorramp=...):
    """
    Transforms the pixel values to display the raster data as a color (RGB) image, based on specific colors in
    a color map.

    Parameters:
      raster(Raster): Input raster
      colormap(string or list or dict): Default value is None.
                        Could be a string specifying the color map name, One of Random | NDVI | Elevation | Gray
                        Could be a list in the form of
                            [
                               [value1, red1, green1, blue1], //[int, int, int, int]
                               [value2, red2, green2, blue2],
                               ...
                            ]
                        Could be a dict in the form of:
                            {"values":[value_1, value_2,...], "colors":[color_1, color_2,...], "labels":[label_1, label_2,...]}
                            here, labels are optional

      colorramp(string or dict): Default value is None.
                        Can be a string specifying color ramp name like "Black To White", "Yellow To Red", "Slope", or other colorramp names supported in ArcGIS Pro
                        Can be a dict. For more information about colorramp object, see color ramp object https://developers.arcgis.com/documentation/common-data-types/color-ramp-objects.htm
    Returns:
      output_raster(Raster): The output raster with this function applied to it
    """
    ...

def Complex(raster):
    """
    Complex function computes magnitude from complex values. It is used when
    input raster has complex pixel type. It computes magnitude from complex
    value to convert the pixel type to floating point for each pixel. It takes
    no argument but an input raster.

    Parameters:
      raster(Raster): Input raster

    Returns:
      output_raster(Raster): The output raster with this function applied to it
    """
    ...

def CompositeBand(rasters):
    """
    Combines multiple images to form a multiband image.

    Parameters:
      raster(list of Rasters): Input rasters

    Returns:
      output_raster(Raster): The output multiband raster.
    """
    ...

def ContrastBrightness(raster, contrast_offset=..., brightness_offset=...):
    """
    The ContrastBrightness function enhances the appearance of raster data (imagery) by modifying the brightness or
    contrast within the image. This function works on 8-bit input raster only.

    Parameters:
      raster(Raster): Input raster. The pixel type of the input raster must be 8-bit .
      contrast_offset(float): contrast offset value. Value can be in range -100 to 100
      brightness_offset(float): brightness offset value. Value can be in range -100 to 100

    Returns:
      output_raster(Raster): The output raster with this function applied to it
    """
    ...

def Convolution(raster, kernel=...):
    """
    The Convolution function performs filtering on the pixel values in an image, which can be used for sharpening an
    image, blurring an image, detecting edges within an image, or other kernel-based enhancements.

    Parameters:
      raster(Raster): Input raster
      kernel(int, list of list): well known kernel or user defined kernel passed as a list of list.
                                 well known kernels:
                                 LINE_DETECTION_HORIZONTAL = 0
                                 LINE_DETECTION_VERTICAL = 1
                                 LINE_DETECTION_LEFT_DIAGONAL = 2
                                 LINE_DETECTION_RIGHT_DIAGONAL = 3
                                 GRADIENT_NORTH = 4
                                 GRADIENT_WEST = 5
                                 GRADIENT_EAST = 6
                                 GRADIENT_SOUTH = 7
                                 GRADIENT_NORTH_EAST = 8
                                 GRADIENT_NORTH_WEST = 9
                                 SMOOTH_ARITHMETIC_MEAN = 10
                                 SMOOTHING_3X3 = 11
                                 SMOOTHING_5X5 = 12
                                 SHARPENING_3X3 = 13
                                 SHARPENING_5X5 = 14
                                 LAPLACIAN_3X3 = 15
                                 LAPLACIAN_5X5 = 16
                                 SOBEL_HORIZONTAL = 17
                                 SOBEL_VERTICAL = 18
                                 SHARPEN = 19
                                 SHARPEN2 = 20
                                 POINT_SPREAD = 21

    Returns:
      output_raster(Raster): The output raster with this function applied to it
    """
    ...

def Curvature(raster, curvature_type=..., z_factor=...):
    """
    The Curvature function displays the shape or curvature of the slope. A part of a surface can be concave or convex;
    you can tell that by looking at the curvature value. The curvature is calculated by computing the second derivative
    of the surface.

    Parameters:
      raster(Raster): Input raster
      curvature_type(string): default value is 'standard'. The curvature type accentuates different aspects of the slope.
                              One of 'standard', 'planform', 'profile'
                              standard - Combines both the Profile and Planform curvatures.

                              planform - Is parallel to the slope and indicates the direction of maximum slope.
                              It affects the acceleration and deceleration of flow across the surface.

                              profile - Is perpendicular to the direction of the maximum slope.
                              It affects the convergence and divergence of flow across a surface.

      z_factor(double): The z-factor adjusts the units of measure for the z units when they are
                        different from the x,y units of the input surface. If the x,y units and
                        z units are in the same units of measure, the z-factor should be set to 1.
                        The z-values of the input surface are multiplied by the z-factor when
                        calculating the final output surface. For example, if your z units are
                        feet and your x,y units are meters, you would use a z-factor of 0.3048

    Returns:
      output_raster(Raster): The output raster with this function applied to it
    """
    ...

def ElevationVoidFill(raster, max_void_width=...):
    """
    The elevation_void_fill function is used to create pixels where holes exist in your elevation.

    Parameters:
      raster(Raster): Input raster
      max_void_width(int): Default is 0. The maximum void width value is used to specify the largest size of a void
                            that you want to fill. If the width or height of the bounding box around the
                            void is larger than the maximum void width value, the void is not filled.
                            The units of this parameter is the same as the units used in your data's
                            spatial reference system

    Returns:
      output_raster(Raster): The output raster with this function applied to it
    """
    ...

def ExtractBand(raster, band_ids=..., band_names=..., band_wavelengths=..., missing_band_action=..., wavelength_match_tolerance=...):
    """
    The ExtractBand function allows you to extract one or more bands from a raster, or it can reorder the bands in a
    multiband image.

    Parameters:
      raster(Raster): Input raster
      band_ids(int or list of int): single band ID or list of band IDs. Note band ID (one-based indexing)
      band_names(string or list of string): single band name or list of Band names
      band_wavelengths(list of double): Band wavelengths
      missing_band_action(int): 0 = BestMatch, 1 = Fail
      wavelength_match_tolerance(double): wavelength match tolerance

    Returns:
      output_raster(Raster): The output raster with this function applied to it
    """
    ...

def EVI(raster, nir_band_id=..., red_band_id=..., blue_band_id=...):
    """
    The Enhanced Vegetation Index (EVI) is an optimized vegetation index that accounts
    for atmospheric influences and vegetation background signal. It's similar to NDVI,
    but is less sensitive to background and atmospheric noise, and it does not become
    saturated NDVI when viewing areas with very dense green vegetation.

    EVI =  2.5 * [(NIR - Red)/(NIR + (6*Red) - (7.5*Blue) + 1)]

    Parameters:
      raster(Raster): Input raster
      nir_band_id(int): NIR band ID, e.g., 5. Note that band ID uses one-based indexing.
      red_band_id(int): red band ID, e.g., 4. Note that band ID uses one-based indexing.
      blue_band_id(int): blue band ID , e.g., 2. Note that band ID uses one-based indexing.

    Returns:
      output_raster(Raster): The output raster with this function applied to it
    """
    ...

def FerrousMinerals(raster, swir_band_id=..., nir_band_id=...):
    """
    The Ferrous Minerals (FM) ratio is a geological index for identifying
    rock features containing some quantity of iron-bearing minerals using
    the shortwave infrared (SWIR) and near-infrared (NIR) bands. FM is used
    in mineral composite mapping.

    FM = SWIR / NIR

    Parameters:
      raster(Raster): Input raster
      swir_band_id(int): SWIR band ID, e.g., 6. Note that band ID uses one-based indexing.
      nir_band_id(int): NIR band ID, e.g., 5. Note that band ID uses one-based indexing.

    Returns:
      output_raster(Raster): The output raster with this function applied to it
    """
    ...

def Statistics(raster, kernel_columns=..., kernel_rows=..., stat_type=..., fill_no_data_only=...):
    """
    Function calculates focal statistics for each pixel of an image based on a defined focal neighborhood.

    Parameters:
      raster(Raster): Input raster
      kernel_columns(int): The number of pixel columns to use in your focal neighborhood dimension.
      kernel_rows(int): The number of pixel rows to use in your focal neighborhood dimension
      stat_type(string): There are seven types of focal statistical functions:
                       Min, Max, Mean, StandardDeviation, Median, Majority, Minority
                          -Min-Calculates the minimum value of the pixels within the neighborhood
                          -Max-Calculates the maximum value of the pixels within the neighborhood
                          -Mean-Calculates the average value of the pixels within the neighborhood. This is the default.
                          -StandardDeviation-Calculates the standard deviation value of the pixels within the neighborhood
                          -Median-Calculates the median value of pixels within the neighborhood.
                          -Majority-Calculates the majority value, or the value that occurs most frequently, of the pixels within the neighborhood.
                          -Minority-Calculates the minority value, or the value that occurs least frequently, of the pixels within the neighborhood.
      fill_no_data_only(bool): Set to True, to fill no data pixels only.

    Returns:
      output_raster(Raster): The output raster with this function applied to it
    """
    ...

def Hillshade(dem, azimuth=..., altitude=..., z_factor=..., slope_type=..., ps_power=..., psz_factor=..., remove_edge_effect=..., hillshade_type=...):
    """
    A hillshade is a grayscale 3D model of the surface taking the sun's relative position into account to shade the image.

    Parameters:
      dem(Raster): Input DEM raster
      azimuth(double): default 315.0 Azimuth is the sun's relative position along the horizon (in degrees).
                       This position is indicated by the angle of the sun measured clockwise from due north.
                       An azimuth of 0 degrees indicates north, east is 90 degrees, south is 180 degrees,
                       and west is 270 degrees.
      altitude(double): default 45.0 Altitude is the sun's angle of elevation above the horizon and ranges from 0 to 90 degrees.
                        A value of 0 degrees indicates that the sun is on the horizon, that is, on the same horizontal
                        plane as the frame of reference. A value of 90 degrees indicates that the sun is directly overhead.
      z_factor(double): default 1. The z-factor is a scaling factor used to convert the elevation values for two purposes:

                        - Convert the elevation units (such as meters or feet) to the horizontal coordinate units of the dataset,
                          which may be feet, meters, or degrees.

                        - Add vertical exaggeration for visual effect.

      slope_type(int): default is 1. 1=DEGREE, 2=PERCENTRISE, 3=SCALED.
      ps_power(double):  default value is 0.664. used together with SCALED slope type. Pixel Size Power accounts for the altitude changes (or scale)
                        as the viewer zooms in and out on the map display. It is the exponent applied to the pixel size term
                        in the equation that controls the rate at which the Z Factor changes to avoid significant loss of
                        relief.
      psz_factor(double):  default value is 0.024. used together with SCALED slope type. Pixel Size Factor accounts for changes in scale as the viewer
                         zooms in and out on the map display. It controls the rate at which the Z Factor changes.
      remove_edge_effect(bool): Set to True to remove edge effect
      hillshade_type(int): Default is 0, 0 = traditional, 1 = multi - directional

                           Traditional - Calculates hillshade from a single illumination direction.
                           You can set the Azimuth and Altitude to control the location of the light source.

                           Multidirectional - Combines light from multiple sources to represent an enhanced
                           visualization of the terrain.

    Returns:
      output_raster(Raster): The output raster with this function applied to it
    """
    ...

def GEMI(raster, nir_band_id=..., red_band_id=...):
    """
    Global Environmental Monitoring Index
    GEMI = eta*(1-0.25*eta)-((Red-0.125)/(1-Red))
    where eta = (2*(NIR^2-Red^2)+1.5*NIR+0.5*Red)/(NIR+Red+0.5)

    Parameters:
      raster(Raster): Input raster
      nir_band_id(int): NIR band ID, e.g., 4. Note that band ID uses one-based indexing.
      red_band_id(int): red band ID, e.g., 3. Note that band ID uses one-based indexing.

    Returns:
      output_raster(Raster): The output raster with this function applied to it
    """
    ...

def GNDVI(raster, nir_band_id=..., green_band_id=...):
    """
    Green Normalized Difference Vegetation Index

    GNDVI = (NIR-Green)/(NIR+Green)

    Parameters:
      raster(Raster): Input raster
      nir_band_id(int): NIR band ID, e.g., 4. Note that band ID uses one-based indexing.
      green_band_id(int): green band ID, e.g., 2. Note that band ID uses one-based indexing.

    Returns:
      output_raster(Raster): The output raster with this function applied to it
    """
    ...

def GVITM(raster, band1_id=..., band2_id=..., band3_id=..., band4_id=..., band5_id=..., band7_id=...):
    """
    Green Vegetation Index - Landsat TM
    GVITM = -0.2848*Band1-0.2435*Band2-0.5436*Band3+0.7243*Band4+0.0840*Band5-0.1800*Band7

    Parameters:
      :param raster(Raster): Input raster
      :param band1_id(int): the band ID of band1, e.g., 1. Note that band ID uses one-based indexing.
      :param band2_id(int): the band ID of band2, e.g., 2. Note that band ID uses one-based indexing.
      :param band3_id(int): the band ID of band3, e.g., 3. Note that band ID uses one-based indexing.
      :param band4_id(int): the band ID of band4, e.g., 4. Note that band ID uses one-based indexing.
      :param band5_id(int): the band ID of band5, e.g., 5. Note that band ID uses one-based indexing.
      :param band7_id(int): the band ID of band6, e.g., 7. Note that band ID uses one-based indexing.

    Returns:
      output_raster(Raster): The output raster with this function applied to it
    """
    ...

def IronOxide(raster, red_band_id=..., blue_band_id=...):
    """
    The Iron Oxide (IO) ratio is a geological index for identifying rock
    features that have experienced oxidation of iron-bearing sulfides
    using the red and blue bands. IO is useful in identifying iron oxide
    features below vegetation canopies, and is used in mineral composite mapping.

    IronOxide = Red / Blue

    :param raster: the input raster / imagery layer
    :param red_band_id: the band ID of the red band, e.g.,4. Note that band ID uses one-based indexing.
    :param blue_band_id: the band ID of the blue band, e.g.,2. Note that band ID uses one-based indexing.
    :return: output raster
    """
    ...

def Lookup(raster, field=...):
    """
    Creates a new raster by looking up values found in another field in the table of the input raster.
    For more information see, https://pro.arcgis.com/en/pro-app/help/data/imagery/lookup-function.htm

    :param raster: The input raster that contains a field from which to create a new raster.
    :param field: Field containing the desired values for the new raster.

    :return: the output raster with this function applied to it
    """
    ...

def Mask(raster, no_data_values=..., included_ranges=..., no_data_interpretation=...):
    """
    The mask function changes the image by specifying a certain pixel value or a range of pixel values as no data.
    The arguments for the mask function are as follows:

    :param raster: input raster
    :param no_data_values: array of numbers [band0_val,band1_val,...]
    :param included_ranges: array of double [band0_lowerbound,band0_upperbound,band1...],
    :param no_data_interpretation: int 0=MatchAny, 1=MatchAll
    :return: the output raster with this function applied to it

    """
    ...

def MLClassify(raster, signature):
    """
    The ml_classify function allows you to perform a supervised classification using the maximum likelihood classification
     algorithm. For more information, see https://pro.arcgis.com/en/pro-app/help/data/imagery/ml-classify-function.htm
     The arguments for the ml_classify function are as follows:

    :param raster: input raster
    :param signature: string. a signature string returned from computeClassStatistics (GSG)
    :return: the output raster

    """
    ...

def MNDWI(raster, green_band_id=..., swir_band_id=...):
    """
    The Modified Normalized Difference Water Index (MNDWI) uses green and SWIR bands for the enhancement 
    of open water features. It also diminishes built-up area features that are often correlated with open
    water in other indices.

    MNDWI = (Green - SWIR) / (Green + SWIR)

    :param raster: the input raster / imagery layer
    :param green_band_id: the band ID of the nir band, e.g.,3. Note that band ID uses one-based indexing. .
    :param swir_band_id: the band ID of the red band, e.g.,6. Note that band ID uses one-based indexing. .
    :return: Modified Normalized Difference Water Index
    """
    ...

def MSAVI(raster, nir_band_id=..., red_band_id=...):
    """
    Modified Soil Adjusted Vegetation Index
    MSAVI2 = (1/2)*(2(NIR+1)-sqrt((2*NIR+1)^2-8(NIR-Red)))

    :param raster: the input raster / imagery layer
    :param nir_band_id: the band ID of the nir band, e.g.,4. Note that band ID uses one-based indexing.
    :param red_band_id: the band ID of the red band, e.g.,3. Note that band ID uses one-based indexing.
    :return: output raster
    """
    ...

def MTVI2(raster, nir_band_id=..., red_band_id=..., green_band_id=...):
    """
    The Modified Triangular Vegetation Index (MTVI2) is a vegetation index
    for detecting leaf chlorophyll content at the canopy scale while being
    relatively insensitive to leaf area index. It uses reflectance in the green,
    red, and near-infrared (NIR) bands

    MTVI2 = (1.5*(1.2*(NIR-Green)-2.5*(Red-Green))/sqrt((2*NIR+1)^2-(6*NIR-5*sqrt(Red))-0.5))

    :param raster: the input raster / imagery layer
    :param nir_band_id: the band ID of the nir band, e.g.,7. Note that band ID uses one-based indexing.
    :param red_band_id: the band ID of the red band, e.g.,5. Note that band ID uses one-based indexing.
    :param green_band_id: the band ID of the green band, e.g.,3. Note that band ID uses one-based indexing.
    :return: output raster
    """
    ...

def NBR(raster, swir_band_id=..., nir_band_id=...):
    """
    Normalized Burn Ratio Index (NBR)
    The Normalized Burn Ratio Index (NBR) uses the NIR and SWIR bands to emphasize burned areas,
    while mitigating illumination and atmospheric effects. Your images should be corrected to reflectance values
    before using this index.

    NBR = (NIR - SWIR) / (NIR+ SWIR)

    :param raster: the input raster / imagery layer
    :param swir_band_id: the band ID of the swir band, e.g.,7. Note that band ID uses one-based indexing.
    :param nir_band_id: the band ID of the nir band, e.g.,5. Note that band ID uses one-based indexing.
    :return: Normalized Burn Ratio Index raster
    """
    ...

def NDBI(raster, swir_band_id=..., nir_band_id=...):
    """
    Normalized Difference Built-up Index (NDBI)
    The Normalized Difference Built-up Index (NDBI) uses the NIR and SWIR bands to emphasize man-made built-up areas.
    It is ratio based to mitigate the effects of terrain illumination differences as well as atmospheric effects.

    NDBI = (SWIR - NIR) / (SWIR + NIR)

    :param raster: the input raster / imagery layer
    :param swir_band_id: the band ID of the swir band, e.g.,6. Note that band ID uses one-based indexing.
    :param nir_band_id: the band ID of the nir band, e.g.,5. Note that band ID uses one-based indexing.
    :return: Normalized Difference Built-up Index raster
    """
    ...

def NDMI(raster, nir_band_id=..., swir1_band_id=...):
    """
    Normalized Difference Moisture Index (NDMI)
    The Normalized Difference Moisture Index (NDMI) is sensitive to the moisture levels in vegetation.
    It is used to monitor droughts as well as monitor fuel levels in fire-prone areas. It uses NIR and SWIR bands to
    create a ratio designed to mitigate illumination and atmospheric effects.

    NDMI = (NIR - SWIR1)/(NIR + SWIR1)

    :param raster: the input raster / imagery layer
    :param nir_band_id: the band ID of the nir band, e.g.,5. Note that band ID uses one-based indexing.
    :param swir1_band_id: the band ID of the swir1 band, e.g.,6. Note that band ID uses one-based indexing.
    :return: Normalized Difference Moisture Index
    """
    ...

def NDSI(raster, green_band_id=..., swir_band_id=...):
    """
    Normalized Difference Snow Index (NDSI)
    The Normalized Difference Snow Index (NDSI) is designed to use MODIS (band 4 and band 6) and
    Landsat TM (band 2 and band 5) for identification of snow cover while ignoring cloud cover. Since it is ratio based,
    it also mitigates atmospheric effects.

    NDSI = (Green - SWIR) / (Green + SWIR)

    :param raster: the input raster / imagery layer
    :param green_band_id: the band ID of the green band, e.g.,6. Note that band ID uses one-based indexing.
    :param swir_band_id: the band ID of the swir band, e.g.,5. Note that band ID uses one-based indexing.
    :return: Normalized Difference Snow Index
    """
    ...

def NDVI(raster, nir_band_id=..., red_band_id=...):
    """
    Normalized Difference Vegetation Index
    NDVI = ((NIR - Red)/(NIR + Red))

    :param raster: the input raster / imagery layer
    :param nir_band_id: the band ID of the nir band, e.g.,4. Note that band ID uses one-based indexing. .
    :param red_band_id: the band ID of the red band, e.g.,3. Note that band ID uses one-based indexing. .
    :return: Normalized Difference Vegetation Index raster
    """
    ...

def NDVIre(raster, nir_band_id=..., redEdge_band_id=...):
    """
    Red-Edge NDVI (NDVIre)
    The Red-Edge NDVI (NDVIre) is a vegetation index for estimating
    vegetation health using the red-edge band. It is especially useful
    for estimating crop health in the mid to late stages of growth where
    the chlorophyll concentration is relatively higher. Also, NDVIre can
    be used to map the within-field variability of nitrogen foliage to
    understand the fertilizer requirements of crops.

    NDVIre = (NIR-RedEdge)/(NIR+RedEdge)

    :param raster: the input raster / imagery layer
    :param nir_band_id: the band ID of the nir band, e.g.,7. Note that band ID uses one-based indexing.
    :param rededge_band_id: the band ID of the redEdge band, e.g.,6. Note that band ID uses one-based indexing.
    :return: output raster
    """
    ...

def NDWI(raster, nir_band_id=..., green_band_id=...):
    """
    The Normalized Difference Water Index (NDWI) is an index for delineating and
    monitoring content changes in surface water. It is computed with the near-infrared
    (NIR) and green bands.

    NDWI = (Green - NIR)/(Green +NIR)

    :param raster: the input raster / imagery layer
    :param nir_band_id: the band ID of the nir band, e.g.,5. Note that band ID uses one-based indexing.
    :param green_band_id: the band ID of the green band, e.g.,3. Note that band ID uses one-based indexing.
    :return: output raster
    """
    ...

def Pansharpen(pan_raster, ms_raster, ir_raster=..., fourth_band_of_ms_is_ir=..., weights=..., type=..., sensor=...):
    """
    The Pansharpening function uses a higher-resolution panchromatic raster to
    fuse with a lower-resolution, multiband raster. It can generate colorized
    multispectral image with higher resolution. For more information, see
    https://pro.arcgis.com/en/pro-app/help/data/imagery/pansharpening-function.htm

    :param pan_raster: raster, which is panchromatic
    :param ms_raster: raster, which is multispectral
    :param ir_raster: Optional, if fourth_band_of_ms_is_ir is true or selected pansharpening method doesn't require near-infrared image
    :param fourth_band_of_ms_is_ir: Boolean, "true" if "ms_raster" has near-infrared image on fourth band
    :param weights: Weights applied for Red, Green, Blue, Near-Infrared bands. 4-elements array, Sum of values is 1
    :param type: string, describes the Pansharpening method one of "IHS", "Brovey" "ESRI", "SimpleMean", "Gram-Schmidt". Default is "ESRI"
    :param sensor: string, it is an optional parameter to specify the sensor name
    :return: output raster with function applied
    """
    ...

def PVI(raster, nir_band_id=..., red_band_id=..., a=..., b=...):
    """
    Perpendicular Vegetation Index
    PVI = (NIR-a*Red-b)/(sqrt(1+a^2))

    :param raster: the input raster
    :param nir_band_id: the band ID of the nir band, e.g.,4. Note that band ID uses one-based indexing.
    :param red_band_id: the band ID of the red band, e.g.,3. Note that band ID uses one-based indexing.
    :param a: the slope
    :param b: the gradient

    :return: output raster
    """
    ...

def RasterCalculator(rasters, input_names, expression, extent_type=..., cellsize_type=...):
    """
    The RasterCalculator function provides access to all existing math functions
    so you can make calls to them when building your expressions. The calculator
    function requires single-band inputs. If you need to perform expressions on
    bands in a multispectral image as part of a function chain, you can use
    the Extract Bands Function before the RasterCalculator function.
    For more info including operators supported, see Calculator function
    http://pro.arcgis.com/en/pro-app/help/data/imagery/calculator-function.htm

    :param rasters: array of rasters
    :param input_names: array of strings for arbitrary raster names.
    :param expression: string, expression to calculate output raster from input rasters
    :param extent_type: string, one of "FirstOf", "IntersectionOf" "UnionOf", "LastOf". Default is "FirstOf".
    :param cellsize_type: one of "FirstOf", "MinOf", "MaxOf "MeanOf", "LastOf". Default is "FirstOf".
    :return: output raster with function applied
    """
    ...

def Remap(raster, input_ranges=..., output_values=..., no_data_ranges=..., allow_unmatched=...):
    """
    The remap function allows you to change or reclassify the pixel values of the raster data.
    For more information, see https://pro.arcgis.com/en/pro-app/help/data/imagery/remap-function.htm

    The arguments for the remap function are as follows:

    :param raster: input raster
    :param input_ranges: [range1_from, range1_to, …], input ranges are specified in pairs: from (inclusive) and to (exclusive). Default: None
    :param output_values: [new_value1, ...], output values of corresponding input ranges. Default: None
    :param no_data_ranges: [nodatavalue1_from,  nodatavalue1_to, …],//[double, double, …], nodata ranges are specified in pairs: from (inclusive) and to (exclusive). Default: None
    :param allow_unmatched: Boolean, specify whether to keep the unmatched values or turn into nodata. Default: False
    :return: the remapped raster

    """
    ...

def Resample(raster, resampling_type=..., input_cellsize=..., output_cellsize=...):
    """
    The resample function resamples pixel values from a given resolution.The arguments for the resample function are as follows:

    :param raster: input raster
    :param resampling_type: one of NearestNeighbor,Bilinear,Cubic,Majority,BilinearInterpolationPlus,BilinearGaussBlur,
            BilinearGaussBlurPlus, Average, Minimum, Maximum,VectorAverage(require two bands)
    :param input_cellsize: point that defines cellsize in source spatial reference
    :param output_cellsize: point that defines output cellsize
    :return: the output raster

    """
    ...

def RTVICore(raster, nir_band_id=..., redEdge_band_id=..., green_band_id=...):
    """
    The Red-Edge Triangulated Vegetation Index (RTVICore) is a vegetation index
    for estimating leaf area index and biomass. This index uses reflectance
    in the NIR, red-edge, and green spectral bands

    RTVICore = [100(NIR-RedEdge)-10(NIR-Green)]

    :param raster: the input raster / imagery layer
    :param nir_band_id: the band ID of the nir band, e.g.,7. Note that band ID uses one-based indexing.
    :param redEdge_band_id: the band ID of the redEdge band, e.g.,6. Note that band ID uses one-based indexing.
    :param green_band_id: the band ID of the green band, e.g.,3. Note that band ID uses one-based indexing.
    :return: output raster
    """
    ...

def SAVI(raster, nir_band_id=..., red_band_id=..., l=...):
    """
    Soil-Adjusted Vegetation Index
    SAVI = ((NIR - Red) / (NIR + Red + L)) x (1 + L)
    where L represents amount of green vegetative cover, e.g., 0.5

    :param raster: the input raster / imagery layer
    :param nir_band_id: the band ID of the nir band, e.g.,4. Note that band ID uses one-based indexing.
    :param red_band_id: the band ID of the red band, e.g.,3. Note that band ID uses one-based indexing.
    :param L: the amount of green vegetative cover, e.g., 0.33
    :return: output raster
    """
    ...

def ShadedRelief(raster, azimuth=..., altitude=..., z_factor=..., colormap=..., colorramp=..., slope_type=..., ps_power=..., psz_factor=..., remove_edge_effect=...):
    """
    Shaded relief is a color 3D model of the terrain, created by merging the images from the Elevation-coded and
    Hillshade methods. For more information, see https://pro.arcgis.com/en/pro-app/help/data/imagery/shaded-relief-function.htm

    The arguments for the shaded_relief function are as follows:
        :param raster: input raster
        :param azimuth (double): default 315
        :param altitude (double): default 45
        :param z_factor (double): default 1
        :param colormap(list or dict): default is None.
                                    Could be a list in the form of
                                        [
                                            [value1, red1, green1, blue1], //[int, int, int, int]
                                           [value2, red2, green2, blue2],
                                           ...
                                        ]
                                    Could be a dict in the form of:
                                        {"values":[value_1, value_2,...], "colors":[color_1, color_2,...], "labels":[label_1, label_2,...]}
                                    here, labels are optional
        :param colorramp(string or dict): default is "Elevation #1".
                                    Could be a string specifying colorramp name like "Black To White", "Yellow To Red", "Slope", or other colorramp names supported in ArcGIS Pro
                                    Could be a dict. For more information about colorramp object, see color ramp object https://developers.arcgis.com/documentation/common-data-types/color-ramp-objects.htm
        :param slope_type(string): one of the following "DEGREE", "PERCENTRISE", or "SCALED". Default is "DEGREE"
        :param ps_power(double): used when slope_type is SCALED. default 0.664
        :param psz_factor(double): used when slope_type is SCALED. default 0.024
        :param remove_edge_effect(boolean): True or False. default False
    :return: the output raster
    """
    ...

def Slope(dem, z_factor=..., slope_type=..., ps_power=..., psz_factor=..., remove_edge_effect=...):
    """
    slope represents the rate of change of elevation for each pixel. For more information, see
    https://pro.arcgis.com/en/pro-app/help/data/imagery/slope-function.htm
    The arguments for the slope function are as follows:

    :param dem: input DEM
    :param z_factor: double, default is 1
    :param slope_type: one of the following values: DEGREE, PERCENTRISE, SCALED. default is "DEGREE".
    :param ps_power: double, used together with SCALED slope type, default is 0.664
    :param psz_factor: double, used together with SCALED slope type, default is 0.024
    :param remove_edge_effect: boolean, True or False, default is False
    :return: the output raster

    """
    ...

def Speckle(raster, filter_type=..., filter_size=..., noise_model=..., noise_var=..., additive_noise_mean=..., multiplicative_noise_mean=..., nlooks=..., damp_factor=...):
    """
    The Speckle function filters the speckled radar dataset to smooth out the
    noise while retaining the edges or sharp features in the image. Four speckle
    reduction filtering algorithms are provided through this function. For more
    information including required and optional parameters for each filter and
    the default parameter values, see Speckle function
    https://pro.arcgis.com/en/pro-app/help/data/imagery/speckle-function.htm

    :param raster: input raster type
    :param filter_type: string, one of "Lee", "EnhancedLee" "Frost", "Kaun". Default is "Lee".
    :param filter_size: string, kernel size. One of "3x3", "5x5", "7x7", "9x9", "11x11". Default is "3x3".
    :param noise_model: string, For Lee filter only. One of "Multiplicative", "Additive", "AdditiveAndMultiplicative"
    :param noise_var: double, for Lee filter with noise_model "Additive" or "AdditiveAndMultiplicative"
    :param additive_noise_mean: double, for Lee filter witth noise_model "AdditiveAndMultiplicative" only
    :param multiplicative_noise_mean: double, For Lee filter with noise_model "Additive" or "AdditiveAndMultiplicative"
    :param nlooks: int, for Lee, EnhancedLee and Kuan Filters
    :param damp_factor: double, for EnhancedLee and Frost filters
    :return: output raster with function applied
    """
    ...

def SpectralConversion(raster, conversion_matrix):
    """
    The SpectralConversion function applies a matrix to a multi-band image to
    affect the spectral values of the output. In the matrix, different weights
    can be assigned to all the input bands to calculate each of the output
    bands. The column/row size of the matrix equals to the band count of input
    raster. For more information, see Spectral Conversion function
    https://pro.arcgis.com/en/pro-app/help/data/imagery/spectral-conversion-function.htm

    :param raster: the input raster
    :param conversion_matrix: array of double (A NxN length one-dimension matrix, where N=band count.)
    :return: the output raster with this function applied to it

    Example
    if conversion_matrix = [0.3,0.2,0.5,0,1], then, it means,
        Output band_1 = 0.3 * Input_band_1 + 0.2 * Input_band_2;
        Output band_2 = 0.5 * Input_band_1 + 0.1 * Input_band_2;
    """
    ...

def SR(raster, nir_band_id=..., red_band_id=...):
    """
    The Simple Ratio (SR) is a common vegetation index for estimating the amount of vegetation.
    It is the ratio of light scattered in the NIR and absorbed in red bands, which reduces the effects
    of atmosphere and topography.

    Values are high for vegetation with a large leaf area index, or high canopy closure, 
    and low for soil, water, and nonvegetated features. The range of values is from 0 to about 30, 
    where healthy vegetation generally falls between values of 2 to 8.

    SR = NIR / Red

    :param raster: the input raster / imagery layer
    :param nir_band_id: the band ID of the nir band, e.g.,5. Note that band ID uses one-based indexing. .
    :param red_band_id: the band ID of the red band, e.g.,4. Note that band ID uses one-based indexing. .
    :return: Simple Ratio raster
    """
    ...

def SRre(raster, nir_band_id=..., redEdge_band_id=...):
    """
    The Red-Edge Simple Ratio (SRre) is a vegetation index for estimating the
    amount of healthy and stressed vegetation. It is the ratio of light scattered
    in the NIR and red-edge bands, which reduces the effects of atmosphere and topography.

    Values are high for vegetation with high canopy closure and healthy vegetation,
    lower for high canopy closure and stressed vegetation, and low for soil, water,
    and nonvegetated features. The range of values is from 0 to about 30, where healthy
    vegetation generally falls between values of 1 to 10.

    SRre = NIR / RedEdge

    :param raster: the input raster / imagery layer
    :param nir_band_id: the band ID of the nir band, e.g.,7. Note that band ID uses one-based indexing.
    :param redEdge_band_id: the band ID of the redEdge band, e.g.,6. Note that band ID uses one-based indexing.
    :return: output raster
    """
    ...

def StatisticsHistogram(raster, statistics=..., histograms=...):
    """"
    The function is used to define the statistics and histogram of a raster.
    It is normally used for control the default display of exported image.
    For more information, see Statistics and Histogram function,
    https://pro.arcgis.com/en/pro-app/help/data/imagery/statistics-and-histogram-function.htm

    :param raster: the input raster / imagery layer
    :param statistics: array of statistics objects. (Predefined statistics for each band)
    :param histograms: array of histogram objects. (Predefined histograms for each band)
    :return: Statistics and Histogram defined raster
    """
    ...

def Stretch(raster, stretch_type=..., min=..., max=..., num_stddev=..., statistics=..., dra=..., min_percent=..., max_percent=..., gamma=..., compute_gamma=..., sigmoid_strength_level=...):
    """
    The stretch function enhances an image through multiple stretch types.
    For more information, see https://pro.arcgis.com/en/pro-app/help/data/imagery/stretch-function.htm.
    Gamma stretch works with all stretch types.
    Min and Max can be used to define output minimum and maximum.
    DRA is used to get statistics from the extent in the export_image request.
    ComputeGamma will automatically calculate best gamma value to render exported image based on empirical model.
    Stretch type None does not require other parameters.
    Stretch type StdDev requires NumberOfStandardDeviations, Statistics, or DRA (true).
    Stretch type Histogram (Histogram Equalization) requires the source dataset to have histograms or additional DRA (true).
    Stretch type MinMax requires Statistics or DRA (true).
    Stretch type PercentClip requires MinPercent, MaxPercent, and DRA (true), or histograms from the source dataset.
    Stretch type Sigmoid does not require other parameters.
    Optionally, set the SigmoidStrengthLevel (1 to 6) to adjust the curvature of Sigmoid curve used in color stretch.

    The arguments for the stretch function are as follows:
    :param raster: input raster
    :param stretch_type: str, one of None, StdDev, Histogram, MinMax, PercentClip, Sigmoid
    :param min: double
    :param max: double
    :param num_stddev: double (e.g. 2)
    :param statistics: array of doubles, [[min1, max1, mean1, standardDeviation1], [min2, max2, mean2, standardDeviation2], ...]
    :param dra: True or False. Default is False. Statistics parameter is ignored when DRA is true
    :param min_percent: double (e.g. 0.25), applicable to PercentClip
    :param max_percent: double (e.g. 0.5), applicable to PercentClip
    :param gamma: array of doubles, e.g., [gamma1, gamma2, gamma3], one for each band
    :param compute_gamma: Trur or False. Default is False. applicable to any stretch type
    :param sigmoid_strength_level: int (1~6), applicable to Sigmoid
    :return: the output raster
    """
    ...

def Sultan(raster, band1_id=..., band3_id=..., band4_id=..., band5_id=..., band6_id=...):
    """
    Sultan's Formula (transform to 3 band 8 bit image)
        Band 1 = (Band5 / Band6) x 100
        Band 2 = (Band5 / Band1) x 100
        Band 3 = (Band3 / Band4) x (Band5 / Band4) x 100

    :param raster: the input raster
    :param band1_id(int): the band ID of band1, e.g., 1. Note that band ID uses one-based indexing.
    :param band3_id(int): the band ID of band3, e.g., 3. Note that band ID uses one-based indexing.
    :param band4_id(int): the band ID of band4, e.g., 4. Note that band ID uses one-based indexing.
    :param band5_id(int): the band ID of band5, e.g., 5. Note that band ID uses one-based indexing.
    :param band6_id(int): the band ID of band6, e.g., 6. Note that band ID uses one-based indexing.
    :return: output raster
    """
    ...

def TasseledCap(raster):
    """"
    The function is designed to analyze and map vegetation and urban development
    changes detected by various satellite sensor systems. It is known as the
    Tasseled Cap transformation due to the shape of the graphical distribution
    of data. This function takes no arguments except a raster. The input for
    this function is the source raster of image service. There are no other
    parameters for this function because all the information is derived from
    the input's properties and key metadata (bands, data type, and sensor name).
    Only imagery from the Landsat MSS, Landsat TM, Landsat ETM+, IKONOS,
    QuickBird, WorldView-2 and RapidEye sensors are supported. Prior to applying
    this function, there should not be any functions that would alter the pixel
    values in the function chain, such as the Stretch, Apparent Reflectance or
    Pansharpening function. The only exception is for Landsat ETM+; when using
    Landsat ETM+, the Apparent Reflectance function must precede the Tasseled
    Cap function. For more information, see
    https://pro.arcgis.com/en/pro-app/help/data/imagery/tasseled-cap-function.htm

    :param raster: the input raster / imagery layer
    :return: the output raster with TasseledCap function applied to it
    """
    ...

def Threshold(raster):
    """
    The binary threshold function produces the binary image. It uses the Otsu method and assumes the input image to have
     a bi-modal histogram. The arguments for the threshold function are as follows:

    :param raster: input raster
    :return: the output raster

    """
    ...

def TransposeBits(raster, input_bit_positions=..., output_bit_positions=..., constant_fill_value=..., fill_raster=...):
    """
    The transpose_bits function performs a bit operation. It extracts bit values from the source data and assigns them
    to new bits in the output data.The arguments for the transpose_bits function are as follows:

    Either providing a fill_value or a fill_raster to initialize pixel values of the output raster.
    Landsat 8 has a quality assessment band. The following are the example input and output bit positions to extract
    confidence levels by mapping them to 0-3:
    * Landsat 8 Water: {"input_bit_positions":[4,5],"output_bit_positions":[0,1]}
    * Landsat 8 Cloud Shadow: {"input_bit_positions":[6,7],"output_bit_positions":[0,1]}
    * Landsat 8 Vegetation: {"input_bit_positions":[8,9],"output_bit_positions":[0,1]}
    * Landsat 8 Snow/Ice: {"input_bit_positions":[10,11],"output_bit_positions":[0,1]}
    * Landsat 8 Cirrus: {"input_bit_positions":[12,13],"output_bit_positions":[0,1]}
    * Landsat 8 Cloud: {"input_bit_positions":[14,15],"output_bit_positions":[0,1]}
    * Landsat 8 Designated Fill: {"input_bit_positions":[0],"output_bit_positions":[0]}
    * Landsat 8 Dropped Frame: {"input_bit_positions":[1],"output_bit_positions":[0]}
    * Landsat 8 Terrain Occlusion: {"input_bit_positions":[2],"output_bit_positions":[0]}

    :param raster: input raster
    :param input_bit_positions: array of long, required
    :param output_bit_positions: array of long, required
    :param constant_fill_value: int, required
    :param fill_raster: optional, the fill raster
    :return: the output raster

    """
    ...

def TSAVI(raster, nir_band_id=..., red_band_id=..., s=..., a=..., X=...):
    """
    Transformed Soil Adjusted Vegetation Index
    TSAVI = (s(NIR-s*Red-a))/(a*NIR+Red-a*s+X*(1+s^2))

    :param raster: the input raster / imagery layer
    :param nir_band_id: the band ID of the nir band, e.g.,4. Note that band ID uses one-based indexing.
    :param red_band_id: the band ID of the red band, e.g.,3. Note that band ID uses one-based indexing.
    :param s: the soil line slope, e.g.,0.33
    :param a: the soil line intercept, e.g.,0.5
    :param X: an adjustment factor that is set to minimize soil noise, e.g.,1.5
    :return: output raster
    """
    ...

def UnitConversion(raster, from_unit=..., to_unit=...):
    """
    The unit_conversion function performs unit conversions.The arguments for the unit_conversion function are as follows:
    from_unit and to_unit take the following str values:
    Speed Units: MetersPerSecond, KilometersPerHour, Knots, FeetPerSecond, MilesPerHour
    Temperature Units: Celsius,Fahrenheit,Kelvin
    Distance Units: str, one of Inches, Feet, Yards, Miles, NauticalMiles, Millimeters, Centimeters, Meters

    :param raster: input raster
    :param from_unit(string): value could be one of [MetersPerSecond, KilometersPerHour, Knots, FeetPerSecond, MilesPerHour,Celsius,Fahrenheit,Kelvin, Inches, Feet, Yards, Miles, NauticalMiles, Millimeters, Centimeters, Meters]
    :param to_unit(string): value could be one of [MetersPerSecond, KilometersPerHour, Knots, FeetPerSecond, MilesPerHour,Celsius,Fahrenheit,Kelvin, Inches, Feet, Yards, Miles, NauticalMiles, Millimeters, Centimeters, Meters]
    :return: the output raster

    """
    ...

def VARI(raster, red_band_id=..., green_band_id=..., blue_band_id=...):
    """
    Visible Atmospherically Resistant Index

    VARI = (Green - Red)/(Green + Red - Blue)

    :param raster: the input raster / imagery layer
    :param red_band_id:  the band ID of the red band, e.g.,3. Note that band ID uses one-based indexing.
    :param green_band_id: the band ID of the green band, e.g.,2. Note that band ID uses one-based indexing.
    :param blue_band_id: the band ID of the blue band, e.g.,1. Note that band ID uses one-based indexing.
    :return: output raster
    """
    ...

def VectorField(raster_u_mag, raster_v_dir, input_data_type=..., angle_reference_system=..., output_data_type=...):
    """
    The VectorField function is used to composite two single-band rasters (each raster represents U/V or Magnitude/Direction)
    into a two-band raster (each band represents U/V or Magnitude/Direction). Data combination type (U-V or Magnitude-Direction)
    can also be converted interchangeably with this function.
    For more information, see https://pro.arcgis.com/en/pro-app/help/data/imagery/vector-field-function.htm

    :param raster_u_mag: raster item representing 'U' or 'Magnitude' - imagery layers filtered by where clause, spatial and temporal filters
    :param raster_v_dir: raster item representing 'V' or 'Direction' - imagery layers filtered by where clause, spatial and temporal filters
    :param input_data_type: string, 'Vector-UV' or 'Vector-MagDir' per input used in 'raster_u_mag' and 'raster_v_dir'
    :param angle_reference_system: string, optional when 'input_data_type' is 'Vector-UV', one of "Geographic", "Arithmetic"
    :param output_data_type: string, 'Vector-UV' or 'Vector-MagDir'
    :return: the output raster with this function applied to it
    """
    ...

def VectorFieldRenderer(raster, is_uv_components=..., reference_system=..., mass_flow_angle_representation=..., calculation_method=..., symbology_name=...):
    """
    The vector_field_renderer function symbolizes a U-V or Magnitude-Direction raster.The arguments for the vector_field_renderer function are as follows:

    :param raster: input raster
    :param is_uv_components: bool
    :param reference_system: int 1=Arithmetic, 2=Geographic
    :param mass_flow_angle_representation: int 0=from 1=to
    :param calculation_method: string, one of "Vector Average", 'Nearest neighbor', 'Bilinear', 'Cubic', 'Minimum', 'Maximum
    :param symbology_name: string, one of "Single Arrow" , "Wind Barb", "Ocean Current"
    :return: the output raster

    """
    ...

def AspectSlope(raster, z_factor=...):
    """
    Creates a raster layer that simultaneously displays the aspect and slope of a surface.
    :param raster: input raster
    :param z_factor: A multiplication factor that converts the vertical (elevation) values to the linear units of the horizontal (x,y) coordinate system. "Use larger values to add vertical exaggeration.
    :return: the output raster
    """
    ...

def HeatIndex(temperature_raster, relative_humidity_raster, temperature_unit=..., heat_index_unit=...):
    """
    Calculates apparent temperature based on ambient temperature and relative humidity. The apparent temperature is often described as how hot it feels to the human body.
    :param temperature_raster: the raster that represent temperature
    :param relative_humidity_raster: the raster that represent relative humidity
    :param temperature_unit: Available input units are Celsius,Fahrenheit or Kelvin
    :param heat_index_unit: Available input units are Celsius,Fahrenheit or Kelvin
    :return: the output raster
    """
    ...

def WindChill(temperature_raster, wind_speed_raster, temperature_units=..., wind_speed_units=..., wind_chill_units=...):
    """
    The Wind Chill function is useful for identifying dangerous winter conditions that, depending on exposure times to
    the elements, can result in frostbite or even hypothermia. Wind chill is a way to measure how cold an individual
    feels when wind is taken into account with already cold temperatures. The faster the wind speed, the more quickly the body will lose heat and the colder they will feel.

    :param temperature_raster:A single-band raster where pixel values represent ambient air temperature.
    :param wind_speed_raster:A single-band raster where pixel values represent wind speed.
    :param temperature_units:The unit of measurement associated with the input temperature raster. Available input units are Celsius, Fahrenheit, and Kelvin.
    :param wind_speed_units: Defines the unit of measurement for the wind-speed raster. Available input units are mph, km/h, ft/s and kn. Each represents

                        Miles Per Hour (mph)
                        Kilometers Per Hour (km/h)
                        Meters Per Second (m/s)
                        Feet Per Second (ft/s)
                        Knots (kn)
    :param wind_chill_units:The unit of measurement associated with the output raster. Available output units are Celsius, Fahrenheit, and Kelvin.
    :return: the output raster
    """
    ...

def Contour(raster, adaptive_smoothing=..., contour_type=..., z_base=..., number_of_contours=..., contour_interval=..., nth_contour_line_in_bold=..., z_factor=...):
    """
    Creates contour lines.

    :param raster: the raster from which the contour is created
    :param adaptive_smoothing(double): adaptive smooting value, e.g., 2.5
    :param contour_type(string): contour type. Available values could be "contour lines", "contour fill" or "smooth surface only"
    :param z_base(double): the z-base value, e.g., 0
    :param number_of_contours(int): the number of contours, e.g., 0
    :param contour_interval(double): the contour interval, e.g., 100
    :param nth_contour_line_in_bold(int): the nth contour line that would be rendered in bold, e.g., 5
    :param z_factor(double): the z-factor, e.g., 1
    :return:
    """
    ...

def PredictUsingTrend(raster, dimension_definition_type=..., dimension_values=..., start=..., end=..., interval_value=..., interval_unit=...):
    """
    Computes a forecasted multidimensional raster layer using the output trend raster from the generate_trend function.

    PredictUsingTrend performs on the fly processing and does not generate temporary output dataset.

    :param raster: The input raster.
    :param dimension_definition_type: Optional String. Specifies the method used to provide prediction dimension values.

                                      - BY_VALUE : The prediction will be calculated for a single dimension value. 
                                                       For example, you want to predict yearly precipitation for the years 
                                                       2050, 2100, and 2150. This is the default.
                                      - BY_INTERVAL : The prediction will be calculated for an interval of the 
                                                          dimension defined by a start and an end value. For example, 
                                                          you want to predict yearly precipitation for every year 
                                                          between 2050 and 2150.

    :param dimension_values: Optional List. The dimension value or values to be used in the prediction. The format of the time, 
                             depth, and height values must match the format of the dimension values used to 
                             generate the trend raster. If the trend raster was generated for the StdTime dimension, 
                             the format should be YYYY-MM-DDTHH:MM:SS, 
                             for example, 2050-01-01T00:00:00.

    :param start: Optional String or Integer. The start date, height, or depth of the dimension interval to be used in the prediction.
                            This parameter is required when the dimension_definition_type parameter is set to 1 (By Interval).

    :param end: Optional String or Integer. The end date, height, or depth of the dimension interval to be used in the prediction.
                          This parameter is required when the dimension_definition_type parameter is set to 1 (By Interval).
    :param interval_value: Optional Integer. The number of steps between two dimension values to be included in the prediction. The default value is 1.
                                This parameter is required when the dimension_definition_type parameter is set to 1 (By Interval).
    :param interval_unit: Optional String. The unit that will be used for the value interval. This parameter only applies when the dimension of analysis is a time dimension.

                            - HOURS - The prediction will be calculated for each hour in the range of time described by the start, end, and interval_value parameters.

                            - DAYS - The prediction will be calculated for each day in the range of time described by the start, end, and interval_value parameters.

                            - WEEKS - The prediction will be calculated for each week in the range of time described by the start, end, and interval_value parameters.

                            - MONTHS - The prediction will be calculated for each month in the range of time described by the start, end, and interval_value parameters.

                            - YEARS - The prediction will be calculated for each year in the range of time described by the start, end, and interval_value parameters.

    :return: output raster 
    """
    ...

def GenerateTrend(raster, dimension_name, regression_type=..., cycle_length=..., cycle_unit=..., harmonic_frequency=..., polynomial_order=..., ignore_nodata=..., rmse=..., r2=..., slope_p_value=..., seasonal_period=...):
    """
    Estimates the trend for each pixel along a dimension for one or more variables in a multidimensional raster.

    GenerateTrend performs on the fly processing and does not generate temporary output dataset.

    :param raster: The input multidimensional raster.
    :param dimension_name: Required String. The dimension along which a trend will be extracted for the 
                           variable or variables selected in the analysis.
    :param regression_type: Optional String. Specifies the type of line to be used to fit to the pixel values along a dimension.

                            - LINEAR : Fits the pixel values for a variable along a linear trend line. This is the default.
                            - HARMONIC : Fits the pixel values for a variable along a harmonic trend line.
                            - POLYNOMIAL : Fits the pixel values for a variable along a second-order polynomial trend line.
                            - MANN-KENDALL : Variable pixel values will be evaluated using the Mann-Kendall trend test. 
                            - SEASONAL-KENDALL : Variable pixel values will be evaluated using the Seasonal-Kendall trend test. 

    :param cycle_length: Optional Integer. The length of periodic variation to model. This parameter is required when Trend Line Type is
                         set to Harmonic. For example, leaf greenness often has one strong cycle of variation in a single year, so the 
                         cycle length is 1 year. Hourly temperature data has one strong cycle of variation throughout a single day, 
                         so the cycle length is 1 day. Default is 1.
    :param cycle_unit: Optional String. Specifies the time unit to be used for the length of harmonic cycle. Options: "DAYS", "YEARS" (This is the default).

    :param harmonic_frequency: Optional Integer. The frequency number to use in the trend fitting. This parameter specifies the 
                               frequency of cycles in a year. The default value is 1, or one harmonic cycle per year. 
                               This parameter is only included in the trend analysis for a harmonic regression (regression_type=1).
    :param polynomial_order: Optional Integer. The polynomial order number to use in the trend fitting. This parameter specifies the 
                             polynomial order. The default value is 2, or second-order polynomial. This parameter 
                             is only included in the trend analysis for a polynomial regression (regression_type=2).
    :param ignore_nodata: Optional Boolean. Specifies whether NoData values are ignored in the analysis.
                          
                          - True : The analysis will include all valid pixels along a given dimension and ignore any NoData pixels. This is the default.
                          - False : The analysis will result in NoData if there are any NoData values for the pixels along the given dimension.

    :param rmse: Optional Boolean. Specifies whether to generate the root mean square error (RMSE) of the trend fit line.

                 - True : The RMSE will be calculated and displayed when the tool is finished running. This is the default.
                 - False : The RMSE will not be calculated.

    :param r2: Optional Boolean. Specifies whether to calculate the R-squared goodness-of-fit statistic for the trend fit line.

               - True : The R-squared will be calculated and displayed when the tool is finished running.
               - False : The R-squared will not be calculated. This is the default.

    :param slope_p_value: Optional Boolean. Specifies whether to calculate the p-value statistic for the slope coefficient of the trend line.

                          - True : The p-value will be calculated and displayed when the tool is finished running. 
                          - False : The p-value will not be calculated. This is the default.

    :param seasonal_period: Optional String. Specifies the seasonal period. Default - "DAYS"
                            Possible Options - "DAYS", "MONTHS"

    :return: output raster 
    """
    ...

def TrendToRGB(raster, model_type=...):
    """
    Display the generate trend raster.
    :param raster: The input raster.
    :param model_type: Optional String. Specifies the model type.
                       - "LINEAR", "HARMONIC"

    :return: output raster 
    """
    ...

def Classify(raster1, raster2=..., classifier_definition=...):
    """
    classifies a segmented raster to a categorical raster.

    Classify performs on the fly processing and does not generate temporary output dataset.

    :param raster1: the first raster - imagery layers filtered by where clause, spatial and temporal filters
    :param raster2: Optional segmentation raster -  If provided, pixels in each segment will get same class assignments. 
                    imagery layers filtered by where clause, spatial and temporal filters
    :param classifier_definition: the classifier parameters as a Python dictionary / json format

    :return: the output raster with this function applied to it
    """
    ...

def SegMeanShift(raster, spectral_detail=..., spatial_detail=..., spectral_radius=..., spatial_radius=..., min_num_pixels_per_segment=...):
    """
    The SegMeanShift function produces a segmented output. Pixel values in the output image represent the
    converged RGB colors of the segment. The input raster needs to be a 3-band 8-bit image. If the raster is not
    a 3-band 8-bit unsigned image, you can use the Stretch function before the SegMeanShift function.

    When specifying arguments for SegMeanShift, use either spectral_detail, spatial_detail as a pair, or use
    spectral_radius, spatial_radius. They have an inverse relationship. spectral_radius = 22 - spectral_detail,
    spatial_radius = 22 - spatial_detail.

    SegMeanShift performs on the fly processing and does not generate temporary output dataset.

    The arguments for the SegMeanShift function are as follows:

    :param raster: input raster
    :param spectral_detail: double 0-21. Bigger value is faster and has more segments.
    :param spatial_detail: int 0-21. Bigger value is faster and has more segments.
    :param spectral_radius: double. Bigger value is slower and has less segments.
    :param spatial_radius: int. Bigger value is slower and has less segments.
    :param min_num_pixels_per_segment: int
    :param astype: output pixel type
    :return: the output raster

    """
    ...

def S1RadiometricCalibration(raster, calibration_type=...):
    """
    Performs different types of radiometric calibration on Sentinel-1 data.

    :param raster: The input raster.
                   The Sentinel-1 Level-1 GRD or SLC input raster you want to process.

                   The function will use the LUT file either to apply the thermal correction or to 
                   remove the correction, depending on the contents of the LUT.
    :param calibration_type: Optional string or int. one of four calibration types: 
                             "beta_nought" (0) - produces an output containing the radar brightness coefficient.
                             "sigma_nought" (1) - the backscatter returned to the antenna from a unit area on the ground, related to ground range.
                             "gamma" (2) - measurement of emitted and returned energy useful for determining antenna patterns.
                              None - Specify None to not apply a correction. This is the default.

    :return: output raster 
    """
    ...

def S1ThermalNoiseRemoval(raster, calibration_type=...):
    """
    Removes thermal noise from Sentinel-1 data.

    :param raster: The input raster.
                   The Sentinel-1 Level-1 GRD or SLC input raster you want to process.

                   The function will use the LUT file either to apply the thermal correction or to 
                   remove the correction, depending on the contents of the LUT.

    :return: output raster 
    """
    ...

def RadarCalibration(raster, calibration_type=...):
    """
    The Radar Calibration function is used to calibrate RADARSAT-2 imagery in a 
    mosaic dataset or as a raster product. Calibration is performed on radar 
    imagery so that the pixel values are a true representation of the radar backscatter.

    :param raster: The input raster.

    :param calibration_type: Optional string or int. one of four calibration types: 
                             "beta_nought" (0) - The function returns the radar reflectivity per unit area in slant range.
                             "sigma_nought" (1) - The function returns the radar reflectivity per unit area in ground range. 
                                                  Results are 32-bit floating-point values commonly in the range of 0.0 to 
                                                  1.0. No data clipping is performed if this option is selected.
                             "gamma" (2) - The function returns the radar reflectivity per unit area in the 
                                           plane perpendicular to the direction of measurement.
                              None - Specify None to not apply any calibration. This is the default.

    :return: output raster 
    """
    ...

def ApparentReflectance(raster, radiance_gain_values=..., radiance_bias_values=..., reflectance_gain_values=..., reflectance_bias_values=..., sun_elevation=..., albedo=..., scale_factor=..., offset=...):
    """
    Function calibrates the digital number (DN) values of imagery from some satellite 
    sensors. The calibration uses sun elevation, acquisition date, sensor gain and 
    bias for each band to derive Top of Atmosphere reflectance, plus sun angle correction.

    :param raster: Required raster 
    :param radiance_gain_values: Optional list. The radiance gain values
    :param radiance_bias_values: Optional list. The radiance bias values
    :param reflectance_gain_values: Optional list. The reflectance gain values
    :param reflectance_bias_values: Optional list. The reflectance bias values
    :param sun_elevation: This is sun elevation value, expressed in degrees.
    :param albedo: Optional bool The results of the Apparent Reflectance function can also 
                   be expressed as albedo, which is the percentage of the available 
                   energy reflected by the planetary surface. Albedo data is used 
                   by scientific users for complex modeling and technical 
                   remote-sensing applications.

                   False - The function returns apparent reflectance values. 
                           This is the default.
                   True - The function returns 32-bit floating-point values, 
                          which most commonly are in the range of 0.0 to 1.0. 
                          No data clipping is performed if this option is selected.
    :param scale_factor: Optional int. Your apparent reflectance output value can be expressed 
                     as an integer. The scaling factor is multiplied by the albedo to 
                     convert all floating-point values into integer values.

                     If the scale factor is either 0 or not specified, default scaling 
                     will be applied depending on the pixel type of the input data:

                     For 16-bit unsigned data types, the default scale factor is 50,000.

                     or 8-bit unsigned data types, default scale factor is 255.

                     The scaling factor is always applied when the output is apparent reflectance.
                     No scaling is applied when the output is albedo.
    :param offset: Optional int. Your scaled albedo value can optionally have an offset value:
                    For 16-bit unsigned data types, the default scale offset is 5,000.

                    For 8-bit unsigned data types, the default scale offset is 0.
                    No scaling is applied when the output is albedo.

    :return: Imagery layer

    """
    ...

def Geometric(raster, geodata_transforms=..., append_geodata_xform=..., z_factor=..., z_offset=..., constant_z=..., correct_geoid=..., tolerance=..., dem=...):
    """
    The geometric function transforms the image (for example, orthorectification) based on a sensor definition and a
    terrain model. The arguments for the geometric function are as follows:

    :param raster: The input raster.
    :param geodata_transforms: Please refer to the Geodata Transformations documentation for more details.
    :param append_geodata_xform: Optional boolean. Indicates whether the geodata transformation is appended to the existing one from the input raster. Default is False.
    :param z_factor: Optional double. Satellite rational polynomial coefficients (RPCs) are scaled for 
                     elevation datasets with vertical units in meters. If your elevation uses other 
                     vertical units, enter a Z Factor to rescale to meters. For example, if your 
                     elevation units are in feet, you would use a value of 0.3048 to convert your 
                     elevation units from feet to meters.
    :param z_offset: Optional double. The base value to be added to the elevation value in the DEM. 
                     This could be used to offset elevation values that do not start at sea level.
    :param constant_z: Optional double. Specify a constant elevation to use for the Geometric function.
    :param correct_geoid: Optional boolean. Set it to True to apply the geoid (EGM96) correction to the z-values, 
                          unless your DEM is already referenced to ellipsoidal heights. Default is False.
    :param tolerance: Optional double. Specify the maximum tolerable error in the geometric function, given in number of pixels.
    :param dem: Optional Raster. Specify the DEM to use for the Geometric function
    :return: the output raster

    """
    ...

def Buffered(raster):
    """
    The Buffered function is used to optimize the performance of complex function chains. 
    It stores the output from the part of the function chain that comes before it in memory.

    :param raster: The input raster.

    :return: output raster 
    """
    ...

def Reproject(raster, spatial_reference=..., x_cell_size=..., y_cell_size=..., x_registration_point=..., y_registration_point=...):
    """
    Modifies the projection of a raster dataset, mosaic dataset, or raster item in a 
    mosaic dataset. It can also resample the data to a new cell size and define an origin.

    :param raster: Required Raster. The raster dataset to be reprojected or resampled.
    :param spatial_reference: Optional dict. The coordinate system used to reproject the data.
                                Example:
                                {
                                "wkid" : 4176,
                                "latestWkid" : 4176
                                }
    :param x_cell_size: Optional float.The x-dimension to which the data should be resampled. 
                        This is optional. If the value is 0 or less, the output envelope 
                        (extent and cell sizes) is calculated from the input raster.
    :param y_cell_size: Optional float. The y-dimension to which the data should be resampled. 
                        This is optional. If the value is 0 or less, the output envelope 
                        (extent and cell sizes) is calculated from the input raster.
    :param x_registration_point: Optional float. The x-coordinate used to define the upper left corner 
                                 of the dataset. This coordinate must be defined in the units of 
                                 the new spatial reference. If both the x_cell_size and y_cell_size 
                                 parameters are greater than 0,  they are used along with the
                                 x_registration_point and y_registration_point
                                 parameters to define the output envelope.
    :param y_registration_point: Optional float. The y-coordinate used to define the upper left corner of the dataset. 
                                 This coordinate must be defined in the units of the new spatial reference. 
                                 If both the x_cell_size and y_cell_size parameters are greater than 0, 
                                 they are used along with the x_registration_point and y_registration_point
                                 parameters to define the output envelope.

    :returns: output raster with function applied
    """
    ...

def RasterizeFeatures(raster, feature_class, class_index_field=..., resolve_overlap_method=...):
    """
    Converts features to raster. Features are assigned pixel values based on the feature's OBJECTID (default). 
    Optionally, the pixel values can be based on a user defined value field in the input feature's attribute table.
    
    :param raster: Required raster. Input raster to define the cell size and extent for the feature conversion.
    :param feature_class: Required. The input point feature class 
    :param class_index_field: Optional string.Select the field to use to identify each feature.
    :param resolve_overlap_method: Optional string. Determine how to manage features that overlap:
                                    FIRST - The overlapping areas will be assigned a value from the first 
                                            dataset listed. This is the default option.
                                    LAST - The overlapping areas will be assigned a value from the last 
                                            dataset listed.
                                    SMALLEST - The overlapping areas will be assigned a value from the 
                                                smaller of the features.
                                    LARGEST - The overlapping areas will be assigned a value from the 
                                                larger of the features.
    
    :returns: output raster with function applied
    """
    ...

def RegionGrow(raster, seed_points, max_growth_radius_field, similarity_threshold_field, fill_value_field=...):
    """
    The Region Grow function groups neighboring pixels into groups depending on the 
    specified radius from the seed point. The group of pixels or object is assigned a 
    specified fill value.

    :param raster: Required raster. The input Imagery Layer object.
    :param seed_points: Required. A point feature class, serving as the initial seeds for the algorithm.
                          Each seed point corresponds to one entry in the attribute table, which carries 
                          the maximum growth radius, similarity threshold, and fill value information.
    :param max_growth_radius_field: Optional string. The field in the attribute table that defines the maximum growth radius, 
                              in the image's spatial reference units.
    :param similarity_threshold_field: Optional string. The field in the attribute 
                                   table that defines the similarity threshold, as 
                                   Euclidean distance in spectral space.

    :param fill_value_field: Optional string.The field in the attribute table that defines the fill value for the group of pixels. In a multiband image, all bands will be assigned this value.
    
    :returns: output raster with function applied
    """
    ...

def ZonalRemap(raster, zonal_attribute_table, zone_raster=..., zone_field=..., min_value_field_name=..., max_value_field_name=..., output_value_field_name=..., background_value=..., default_output_value=..., where_clause=...):
    """
    Creates a raster layer that simultaneously displays the aspect and slope of a surface.
    :param raster: input raster
    :param zonal_attribute_table: Required path to feature class. A table containing at least three 
                                  fields. It must have a minimum threshold value, maximum threshold 
                                  value, and target value. The target value is the field that will 
                                  contain the remapped value.
    :param zone_raster: Optional input raster. A single-band raster, where each pixel defines zones 
                        associated with a particular location. A zone is defined as all areas in 
                        the input that have the same value. The areas do not have to be contiguous.
    :param zone_field: Optional string. The field name in the zonal_attribute_table that contains 
                       the zone ID values.
                       The zone ID values are directly tied to the zone IDs in your zonal raster. 
                       They provide another level of filtering while remapping. If there is no 
                       zone ID associated with a particular record in the table, it will not 
                       participate in the remapping.
    :param min_value_field_name: Optional string. The field name containing the minimum value 
                                 above which an input pixel is remapped.
                                 If not specified, pixel values are not tested for minimum.
    :param max_value_field_name: Optional string. Optional string. The field name containing the maximum value 
                                 above which an input pixel is remapped.
                                 If not specified, pixel values are not tested for maximum.
    :param output_value_field_name: Optional string. 
    :param background_value: Optional int. The initial pixel value of the output raster, before input 
                             pixels are remapped.
    :param default_output_value: Optional int. The field name containing the target value to which an 
                                 input pixel is remapped.
                                 If not specified, remapped pixel values are set to Default Output Value.
    :param where_clause: Optional string. An optional query applied on the zonal_attribute_table. 
                         If you were using the table above as an example, the query would be 
                         "Variable1 = 'bare earth' AND Variable2 = 'California'"
    :return: the output raster
    """
    ...

def LinearUnmixing(raster, spectral_profile_file=..., spectral_profile_def=..., training_feature=..., non_negative=..., sum_to_one=...):
    """
    Performs subpixel classification and calculates the fractional abundance of different land cover types for individual pixels. 
    spectral profile can either be specified 
        - as spectral profile file (*.eed, *.ecd, *.json) using spectral_profile_file parameter
        - as spectral profile information dictionary using  spectral_profile_def parameter.
        - as training feature using training_feature parameter.                                 
    
    LinearUnmixing performs on the fly processing and does not generate temporary output dataset.

    :param raster: The input raster.
    :param spectral_profile_file: Optional string. A classifier definition file (.ecd), generated from the Train Maximum 
                                                    Likelihood Classifier tool, or a JavaScript Object Notation file (.json) 
                                                    that contains the class spectral profiles.
    :param spectral_profile_def: Optional dict. The class spectral profile information.                                
    :param training_feature: Polygon features or a training sample feature class, generated from the Training Samples Manager.
                              
    :param non_negative: Optional bool. Specifies the options to define the output pixel values.

                         - True : There will be no negative output values.
                         - False : There can be negative values of fractional land cover. This is the default.

    :param sum_to_one: Optional bool. Specifies the options to define the output pixel values.

                        - True : Class values for each pixel are provided in decimal format with the sum of all classes equal to 1. 

                          Example: 
                            Class1 = 0.16; Class2 = 0.24; Class3 = 0.60.

                        - False : The sum of all classes in a pixel can exceed 1. This is the default.

    :return: output raster 
    """
    ...

def ComputeChange(raster1, raster2, method=..., from_class_values=..., to_class_values=..., filter_method=..., define_transition_colors=..., extent_type=..., cellsize_type=..., from_class_name_field_name=..., to_class_name_field_name=...):
    """
    Produce raster outputs representing of various changes.

    ComputeChange performs on the fly processing and does not generate temporary output dataset.

    :param raster1: Required Raster. The first raster for compute change function.
    :param raster2: Required Raster. The second raster for compute change function.
    :param method: Optional String. Specifies the method to be used. Possible options are:

                    - "DIFFERENCE" - The mathematical difference, or subtraction, between the pixel 
                                     values in the raster1 parameter and the pixel values in the 
                                     raster2 parameter.

                    - "RELATIVE_DIFFERENCE" - The difference in pixel values accounting for the 
                                              quantities of the values being compared.

                    - "CATEGORICAL_DIFFERENCE" - The difference between two categorical or thematic rasters 
                                                 in which the output shows every class transition that 
                                                 occurred between the two rasters.

                    - "SPECTRAL_EUCLIDEAN_DISTANCE" - The Euclidean distance between two multiband rasters, 
                                                      where each pixel is treated as a vector. Larger values 
                                                      indicate more change between the images.

                    - "SPECTRAL_ANGLE_DIFFERENCE" - The spectral angle between two multiband rasters, where 
                                                    each pixel is treated as a vector. Larger angles indicate 
                                                    more change between the images.

                    - "BAND_WITH_MOST_CHANGE" - The band that accounts for the most change in each pixel between 
                                                two multiband rasters.

                    Example:
                        "DIFFERENCE"

                        Defines the method used to assign color for the output classes
    :param from_class_values: Optional list. The class values that define the from classes. It can be one or multiple value. 
    :param to_class_values: Optional list. The class values that define the to classes. It can be one or multiple value. 
    :param filter_method: Optional string. Default value is "CHANGED_PIXELS_ONLY".
                          Possible options are:
                              - "ALL" 
                              - "CHANGED_PIXELS_ONLY" 
                              - "UNCHANGED_PIXELS_ONLY" 

    :param define_transition_colors: Optional string. Defines the method used to assign color for the output classes
                                        - "AVERAGE" - use an average of the colors of the from class and 
                                                      to class for the output classes. This is the default.
                                        - "FROM_COLOR" - use colors of the from classes for the output
                                        - "TO_COLOR" - use the colors of the to classes for the output

     :param extent_type: Optional string. One of "FirstOf", "IntersectionOf" "UnionOf", "LastOf"
     :param cellsize_type: Optional String. One of "FirstOf", "MinOf", "MaxOf "MeanOf", "LastOf"
     :param from_class_name_field_name: Optional string. A field that stores class names in the raster1. 
                                        The function automatically searches for CLASSNAME field or CLASS_NAME field to use.
                                        Use this parameter if the input does not contain these standard field names  

                                        Example: "CLASSES" 
     :param to_class_name_field_name: Optional string. A field that stores class names in the raster2. 
                                      The function automatically searches for CLASSNAME field or CLASS_NAME field to use.
                                      Use this parameter if the input does not contain these standard field names  

                                      Example: "CLASSES" 

    :return: output raster 

    """
    ...

def DetectChangeUsingChangeAnalysis(raster, change_type=..., max_number_of_changes=..., segment_date=..., change_direction=..., filter_by_year=..., min_year=..., max_year=..., filter_by_duration=..., min_duration=..., max_duration=..., filter_by_magnitude=..., min_magnitude=..., max_magnitude=..., filter_by_start_value=..., min_start_value=..., max_start_value=..., filter_by_end_value=..., min_end_value=..., max_end_value=...):
    """
    Function generates a raster containing pixel change information using the 
    output change analysis raster from the AnalyzeChangesUsingCCDC or AnalyzeChangesUsingLandTrendr function.

    DetectChangeUsingChangeAnalysis performs on the fly processing and does not generate temporary output dataset.

    :param raster: Required raster object. The raster generated from the AnalyzeChangesUsingCCDC or AnalyzeChangesUsingLandTrendr function.
    :param change_type: Optional String. Specifies the change information to calculate.

                        - TIME_OF_LATEST_CHANGE - Each pixel will contain the date of the most recent change for that pixel in the time series. This is the default.
                        - TIME_OF_EARLIEST_CHANGE - Each pixel will contain the date of the earliest change for that pixel in the time series.
                        - TIME_OF_LARGEST_CHANGE - Each pixel will contain the date of the most significant change for that pixel in the time series.
                        - NUM_OF_CHANGES - Each pixel will contain the total number of times the pixel changed in the time series.
                        - TIME_OF_LONGEST_CHANGE -Each pixel will contain the date of change at the end of the longest transition segment in the time series.
                        - TIME_OF_SHORTEST_CHANGE -Each pixel will contain the date of change at the end of the shortest transition segment in the time series.
                        - TIME_OF_FASTEST_CHANGE -Each pixel will contain the date of change at the end of the transition that occurred most quickly.
                        - TIME_OF_SLOWEST_CHANGE -Each pixel will contain the date of change at the end of the transition that occurred most slowly.
                          Example:
                            "TIME_OF_LATEST_CHANGE"
    :param max_number_of_changes: Optional Integer. The maximum number of changes per pixel that will 
                                    be calculated when the change_type parameter is set to 
                                    TIME_OF_LATEST_CHANGE, TIME_OF_EARLIEST_CHANGE, or TIME_OF_LARGEST_CHANGE. 
                                    This number corresponds to the number of bands in the output raster. 
                                    The default is 1, meaning only one change date will be calculated, 
                                    and the output raster will contain only one band.

                                    Example:
                                    3
    :param segment_date:Optional string. Specifies whether to extract the date at the beginning of a change segment, or the end.

                        This parameter is honoured only when the input change analysis raster is the output from the 
                        Analyze Changes Using LandTrendr tool.

                        - BEGINNING_OF_SEGMENT - Extract the date at the beginning of a change segment. This is the default.
                        - END_OF_SEGMENT - Extract the date at the end of a change segment.
    :param change_direction:Optional string. The direction of change to be included in the analysis. For example, choose INCREASE to 
                            only extract date of change information for periods where the change is in the positive or 
                            increasing direction.

                            This parameter is honoured only when the input change analysis raster is the output from the Analyze Changes Using LandTrendr tool.

                            - ALL - All change directions will be included in the output. This is the default.
                            - INCREASE - Only change in the positive or increasing direction will be included in the output.
                            - DECREASE - Only change in the negative or decreasing direction will be included in the output.
    :param filter_by_year: Optional boolean. Specifies whether to filter by a range of years.
                           - True - Filter results such that only changes that occurred within a specific range of years is 
                                    included in the output.
                           - False - Do not filter results by year. This is the default.
    :param min_year: Optional double. The earliest year to use to filter results. This parameter is required if the filter_by_year parameter is set to True.
    :param max_year: Optional double. The latest year to use to filter results. This parameter is required if the filter_by_year parameter is set to True.
    :param filter_by_duration: Optional boolean. Specifies whether to filter by the change duration. This parameter is honoured only when the input change 
                               analysis raster is the output from the Analyze Changes Using LandTrendr tool.

                               - True - Filter results by duration such that only the changes that lasted a given amount of time will be included in the output.
                               - False - Do not filter results by duration. This is the default.
    :param min_duration: Optional double. The minimum number of consecutive years to include in the results. This parameter is required if the filter_by_duration parameter is set to True.
    :param max_duration:Optional double. The maximum number of consecutive years to include in the results. This parameter is required if the filter_by_duration parameter is set to True.
    :param filter_by_magnitude:Specifies whether to filter by change magnitude.
                               - True - Filter results by magnitude such that only the changes of a given magnitude will be included in the output.
                               - False - Do not filter results by magnitude. This is the default.
    :param min_magnitude:Optional double. The minimum magnitude to include in the results. This parameter is required if the filter_by_duration parameter is set to True.
    :param max_magnitude: Optional double. The maximum magnitude to include in the results. This parameter is required if the filter_by_duration parameter is set to True.
    :param filter_by_start_value: Specifies whether to filter by start value. This parameter is available only when the input change analysis raster is the output from the AnalyzeChangesUsingLandTrendr function. 
                                  - True - Filter results by start value so that only the change that starts with value defined by a range.
                                  - False - Do not filter by start value. This is the default.
    :param min_start_value: The minimum value that defines the range of start value. This parameter is required if the filter_by_start_value parameter is set to True. 
    :param max_start_value: The maximum value that defines the range of start value. This parameter is required if the filter_by_start_value parameter is set to True. 
    :param filter_by_end_value: Specifies whether to filter by end value. This parameter is available only when the input change analysis raster is the output from the AnalyzeChangesUsingLandTrendr function. 
                                - True - Filter results by end value so that only the change that ends with value defined by a range.
                                - False - Do not filter by end value. This is the default.
    :param min_end_value: The minimum value that defines the range of end value. This parameter is required if the filter_by_end_value parameter is set to True. 
    :param max_end_value: The maximum value that defines the range of end value. This parameter is required if the filter_by_end_value parameter is set to True. 
    :return: the output raster

    """
    ...

def InterpolateRasterByDimension(raster, interpolation_method=..., variables=..., dimension_definition=..., dimension_values=..., dimension=..., start_value=..., end_value=..., interval_value=..., interval_unit=..., target_raster=..., ignore_nodata=...):
    """
    Interpolates a multidimensional raster at a specified dimension value using adjacent values.

    :param raster: The input raster.
    :param interpolation_method: Optional string. Specifies the interpolation method. Possible values are - LINEAR, NEARESTNEIGHBOR
                                 Default is LINEAR
    :param variables: Optional List. The list of variables that will be included in the interpolation. If not specified the function will take all variables by default.
    :param dimension_definition: Optional String. Specifies the dimension definition. It can be one of the following:

                                    - BY_VALUES 

                                    - BY_INTERVAL

                                    - BY_TARGET_RASTER

    :param dimension_values: Optional List of Dicts. This slices the data based on the dimension name and the value specified.
                             This parameter is required when the dimension_definition is set to BY_VALUES.

                             If dimension is StdTime, then the value must be specified in
                             human readable time format (YYYY-MM-DDTHH:MM:SS). The input should be specified as:
                             [{"dimension":"dimension_name", "value":"dimension_value"},{"dimension":"dimension_name", "value":"dimension_value"}]

                             Example:
                                 [{"dimension":"StdTime", "value":"2012-01-15T03:00:00"}]

    :param dimension: Optional String. The dimension along which the variables will be interpolated.
                      This parameter is required when the dimension_definition is set to BY_INTERVAL.

    :param start_value: Optional String. The beginning of the interval.
                        This parameter is required when the dimension_definition is set to BY_INTERVAL
    :param end_value: Optional String. The end of the interval.
                      This parameter is required when the dimension_definition is set to BY_INTERVAL
    :param interval_value: Optional Float. The frequency with which the data will be sliced.
                           This parameter is required when the dimension_definition is set to BY_INTERVAL
    :param interval_unit: Optional String. Specifies the interval unit.
                           This parameter is required when the dimension_definition is set to BY_INTERVAL
                           and the dimension parameter is set to StdTime.

                            - HOURS - Uses hours as the specified unit of time.

                            - DAYS - Uses days as the specified unit of time.

                            - WEEKS - Uses weeks as the specified unit of time.

                            - MONTHS - Uses months as the specified unit of time.

                            - YEARS -Uses years as the specified unit of time.
    :param target_raster: Optional String. Parameter used to specify the target raster from which the dimension definition would be taken.
                          Required when dimension_definition is set to BY_TARGET_RASTER
    :param ignore_nodata: Optional Boolean. Specifies whether NoData values are ignored in the interpolation.
                          
                          - True : Only the cells that are have noData values will be used in interpolation. This is the default.
                          - False : The cells that have noData values will be used in interpolation.

    :return: output raster 
    """
    ...

def Max(rasters, extent_type=..., cellsize_type=..., ignore_nodata=..., process_as_multiband=...):
    """
    The Max function determines the maximum value from multiple rasters, on a pixel-by-pixel basis. 

    :param rasters: Required list of Rasters. If a scalar is needed for the operation, the scalar can be a float.
    :param extent_type: Optional string. Specifies the extent to be used for the function.

                        - "FirstOf" - Use the extent of the first input raster to determine the processing extent. This is the default.

                        - "IntersectionOf" - Use the extent of the overlapping pixels to determine the processing extent.

                        - "UnionOf" - Use the extent of all the rasters to determine the processing extent.

                        - "LastOf" - Use the extent of the last input raster to determine the processing extent.
    :param cellsize_type: Optional string. Specifies the cell size to be used for the function.
                          - "FirstOf" - Use the first cell size of the input rasters. This is the default.

                          - "MinOf" - Use the smallest cell size of all the input rasters.

                          - "MaxOf" - Use the largest cell size of all the input rasters.

                          - "MeanOf" - Use the mean cell size of all the input rasters.

                          - "LastOf" - Use the last cell size of the input rasters.
    :param ignore_nodata: Optional Boolean. Specifies whether NoData values are ignored in the interpolation.
                          
                          - True : Only the cells that are have noData values will be used in calculation. This is the default.
                          - False : The cells that have noData values will be used in calculation.

    :param process_as_multiband: Optional boolean. Set to True to process as multiband.

    :return: output raster 
    """
    ...

def Mean(rasters, extent_type=..., cellsize_type=..., ignore_nodata=..., process_as_multiband=...):
    """
    The Mean function determines the average value from multiple rasters, on a pixel-by-pixel basis.

    :param rasters: Required list of Rasters. If a scalar is needed for the operation, the scalar can be a float.
    :param extent_type: Optional string. Specifies the extent to be used for the function.

                        - "FirstOf" - Use the extent of the first input raster to determine the processing extent. This is the default.

                        - "IntersectionOf" - Use the extent of the overlapping pixels to determine the processing extent.

                        - "UnionOf" - Use the extent of all the rasters to determine the processing extent.

                        - "LastOf" - Use the extent of the last input raster to determine the processing extent.
    :param cellsize_type: Optional string. Specifies the cell size to be used for the function.
                          - "FirstOf" - Use the first cell size of the input rasters. This is the default.

                          - "MinOf" - Use the smallest cell size of all the input rasters.

                          - "MaxOf" - Use the largest cell size of all the input rasters.

                          - "MeanOf" - Use the mean cell size of all the input rasters.

                          - "LastOf" - Use the last cell size of the input rasters.
    :param ignore_nodata: Optional Boolean. Specifies whether NoData values are ignored in the interpolation.
                          
                          - True : Only the cells that are have noData values will be used in calculation. This is the default.
                          - False : The cells that have noData values will be used in calculation.

    :param process_as_multiband: Optional boolean. Set to True to process as multiband.

    :return: output raster 
    """
    ...

def Median(rasters, percentile_interpolation_type=..., extent_type=..., cellsize_type=..., ignore_nodata=..., process_as_multiband=...):
    """
    The Median function calculates the middle value of the pixels from multiple rasters, on a pixel-by-pixel basis.

    :param rasters: Required list of Rasters. If a scalar is needed for the operation, the scalar can be a float.
    :param percentile_interpolation_type: Optional string. Specifies the method of interpolation to be used when
                                          the median lies between two input cell values.

                                             - AUTO_DETECT-If the input rasters are of integer pixel type, the NEAREST
                                               method is used. If the input rasters are of floating point pixel type,
                                               the LINEAR method is used. This is the default.

                                             - NEAREST-The nearest available value to the desired percentile is used.
                                               In this case, the output pixel type is the same as that of the input rasters.

                                             - LINEAR-The weighted average of the two surrounding values from the desired
                                               percentile is used. In this case, the output pixel type is floating point.
    :param extent_type: Optional string. Specifies the extent to be used for the function.

                        - "FirstOf" - Use the extent of the first input raster to determine the processing extent. This is the default.

                        - "IntersectionOf" - Use the extent of the overlapping pixels to determine the processing extent.

                        - "UnionOf" - Use the extent of all the rasters to determine the processing extent.

                        - "LastOf" - Use the extent of the last input raster to determine the processing extent.
    :param cellsize_type: Optional string. Specifies the cell size to be used for the function.
                          - "FirstOf" - Use the first cell size of the input rasters. This is the default.

                          - "MinOf" - Use the smallest cell size of all the input rasters.

                          - "MaxOf" - Use the largest cell size of all the input rasters.

                          - "MeanOf" - Use the mean cell size of all the input rasters.

                          - "LastOf" - Use the last cell size of the input rasters.
    :param ignore_nodata: Optional Boolean. Specifies whether NoData values are ignored in the interpolation.
                          
                          - True : Only the cells that are have noData values will be used in calculation. This is the default.
                          - False : The cells that have noData values will be used in calculation.

    :param process_as_multiband: Optional boolean. Set to True to process as multiband.

    :return: output raster 
    """
    ...

def Min(rasters, extent_type=..., cellsize_type=..., ignore_nodata=..., process_as_multiband=...):
    """
    The Min function determines the smallest value from multiple rasters, on a pixel-by-pixel basis.

    :param rasters: Required list of Rasters. If a scalar is needed for the operation, the scalar can be a float.
    :param extent_type: Optional string. Specifies the extent to be used for the function.

                        - "FirstOf" - Use the extent of the first input raster to determine the processing extent. This is the default.

                        - "IntersectionOf" - Use the extent of the overlapping pixels to determine the processing extent.

                        - "UnionOf" - Use the extent of all the rasters to determine the processing extent.

                        - "LastOf" - Use the extent of the last input raster to determine the processing extent.
    :param cellsize_type: Optional string. Specifies the cell size to be used for the function.
                          - "FirstOf" - Use the first cell size of the input rasters. This is the default.

                          - "MinOf" - Use the smallest cell size of all the input rasters.

                          - "MaxOf" - Use the largest cell size of all the input rasters.

                          - "MeanOf" - Use the mean cell size of all the input rasters.

                          - "LastOf" - Use the last cell size of the input rasters.
    :param ignore_nodata: Optional Boolean. Specifies whether NoData values are ignored in the interpolation.
                          
                          - True : Only the cells that are have noData values will be used in calculation. This is the default.
                          - False : The cells that have noData values will be used in calculation.

    :param process_as_multiband: Optional boolean. Set to True to process as multiband.

    :return: output raster 
    """
    ...

def Minority(rasters, extent_type=..., cellsize_type=..., ignore_nodata=..., process_as_multiband=...):
    """
    The Minority function determines the value that occurs least often from multiple rasters, on a pixel-by-pixel basis.

    :param rasters: Required list of Rasters. If a scalar is needed for the operation, the scalar can be a float.
    :param extent_type: Optional string. Specifies the extent to be used for the function.

                        - "FirstOf" - Use the extent of the first input raster to determine the processing extent. This is the default.

                        - "IntersectionOf" - Use the extent of the overlapping pixels to determine the processing extent.

                        - "UnionOf" - Use the extent of all the rasters to determine the processing extent.

                        - "LastOf" - Use the extent of the last input raster to determine the processing extent.
    :param cellsize_type: Optional string. Specifies the cell size to be used for the function.
                          - "FirstOf" - Use the first cell size of the input rasters. This is the default.

                          - "MinOf" - Use the smallest cell size of all the input rasters.

                          - "MaxOf" - Use the largest cell size of all the input rasters.

                          - "MeanOf" - Use the mean cell size of all the input rasters.

                          - "LastOf" - Use the last cell size of the input rasters.
    :param ignore_nodata: Optional Boolean. Specifies whether NoData values are ignored in the interpolation.
                          
                          - True : Only the cells that are have noData values will be used in calculation. This is the default.
                          - False : The cells that have noData values will be used in calculation.

    :param process_as_multiband: Optional boolean. Set to True to process as multiband.

    :return: output raster 
    """
    ...

def Majority(rasters, extent_type=..., cellsize_type=..., ignore_nodata=..., process_as_multiband=...):
    """
    The Majority function determines the value that occurs most often from multiple rasters, on a pixel-by-pixel basis.

    :param rasters: Required list of Rasters. If a scalar is needed for the operation, the scalar can be a float.
    :param extent_type: Optional string. Specifies the extent to be used for the function.

                        - "FirstOf" - Use the extent of the first input raster to determine the processing extent. This is the default.

                        - "IntersectionOf" - Use the extent of the overlapping pixels to determine the processing extent.

                        - "UnionOf" - Use the extent of all the rasters to determine the processing extent.

                        - "LastOf" - Use the extent of the last input raster to determine the processing extent.
    :param cellsize_type: Optional string. Specifies the cell size to be used for the function.
                          - "FirstOf" - Use the first cell size of the input rasters. This is the default.

                          - "MinOf" - Use the smallest cell size of all the input rasters.

                          - "MaxOf" - Use the largest cell size of all the input rasters.

                          - "MeanOf" - Use the mean cell size of all the input rasters.

                          - "LastOf" - Use the last cell size of the input rasters.
    :param ignore_nodata: Optional Boolean. Specifies whether NoData values are ignored in the interpolation.
                          
                          - True : Only the cells that are have noData values will be used in calculation. This is the default.
                          - False : The cells that have noData values will be used in calculation.

    :param process_as_multiband: Optional boolean. Set to True to process as multiband.

    :return: output raster 
    """
    ...

def Range(rasters, extent_type=..., cellsize_type=..., ignore_nodata=..., process_as_multiband=...):
    """
    The CellStatsRange function calculates the difference between the largest and the smallest values of a raster on a pixel-by-pixel basis.

    :param rasters: Required list of Rasters. If a scalar is needed for the operation, the scalar can be a float.
    :param extent_type: Optional string. Specifies the extent to be used for the function.

                        - "FirstOf" - Use the extent of the first input raster to determine the processing extent. This is the default.

                        - "IntersectionOf" - Use the extent of the overlapping pixels to determine the processing extent.

                        - "UnionOf" - Use the extent of all the rasters to determine the processing extent.

                        - "LastOf" - Use the extent of the last input raster to determine the processing extent.
    :param cellsize_type: Optional string. Specifies the cell size to be used for the function.
                          - "FirstOf" - Use the first cell size of the input rasters. This is the default.

                          - "MinOf" - Use the smallest cell size of all the input rasters.

                          - "MaxOf" - Use the largest cell size of all the input rasters.

                          - "MeanOf" - Use the mean cell size of all the input rasters.

                          - "LastOf" - Use the last cell size of the input rasters.
    :param ignore_nodata: Optional Boolean. Specifies whether NoData values are ignored in the interpolation.
                          
                          - True : Only the cells that are have noData values will be used in calculation. This is the default.
                          - False : The cells that have noData values will be used in calculation.

    :param process_as_multiband: Optional boolean. Set to True to process as multiband.

    :return: output raster 
    """
    ...

def StdDev(rasters, extent_type=..., cellsize_type=..., ignore_nodata=..., process_as_multiband=...):
    """
    The StdDev function calculates the standard deviation of the pixels of a raster on a pixel-by-pixel basis.

    :param rasters: Required list of Rasters. If a scalar is needed for the operation, the scalar can be a float.
    :param extent_type: Optional string. Specifies the extent to be used for the function.

                        - "FirstOf" - Use the extent of the first input raster to determine the processing extent. This is the default.

                        - "IntersectionOf" - Use the extent of the overlapping pixels to determine the processing extent.

                        - "UnionOf" - Use the extent of all the rasters to determine the processing extent.

                        - "LastOf" - Use the extent of the last input raster to determine the processing extent.
    :param cellsize_type: Optional string. Specifies the cell size to be used for the function.
                          - "FirstOf" - Use the first cell size of the input rasters. This is the default.

                          - "MinOf" - Use the smallest cell size of all the input rasters.

                          - "MaxOf" - Use the largest cell size of all the input rasters.

                          - "MeanOf" - Use the mean cell size of all the input rasters.

                          - "LastOf" - Use the last cell size of the input rasters.
    :param ignore_nodata: Optional Boolean. Specifies whether NoData values are ignored in the interpolation.
                          
                          - True : Only the cells that are have noData values will be used in calculation. This is the default.
                          - False : The cells that have noData values will be used in calculation.

    :param process_as_multiband: Optional boolean. Set to True to process as multiband.

    :return: output raster 
    """
    ...

def Sum(rasters, extent_type=..., cellsize_type=..., ignore_nodata=..., process_as_multiband=...):
    """
    The Sum function adds the values of the rasters on a pixel-by-pixel basis.

    :param rasters: Required list of Rasters. If a scalar is needed for the operation, the scalar can be a float.
    :param extent_type: Optional string. Specifies the extent to be used for the function.

                        - "FirstOf" - Use the extent of the first input raster to determine the processing extent. This is the default.

                        - "IntersectionOf" - Use the extent of the overlapping pixels to determine the processing extent.

                        - "UnionOf" - Use the extent of all the rasters to determine the processing extent.

                        - "LastOf" - Use the extent of the last input raster to determine the processing extent.
    :param cellsize_type: Optional string. Specifies the cell size to be used for the function.
                          - "FirstOf" - Use the first cell size of the input rasters. This is the default.

                          - "MinOf" - Use the smallest cell size of all the input rasters.

                          - "MaxOf" - Use the largest cell size of all the input rasters.

                          - "MeanOf" - Use the mean cell size of all the input rasters.

                          - "LastOf" - Use the last cell size of the input rasters.
    :param ignore_nodata: Optional Boolean. Specifies whether NoData values are ignored in the interpolation.
                          
                          - True : Only the cells that are have noData values will be used in calculation. This is the default.
                          - False : The cells that have noData values will be used in calculation.

    :param process_as_multiband: Optional boolean. Set to True to process as multiband.

    :return: output raster 
    """
    ...

def Variety(rasters, extent_type=..., cellsize_type=..., ignore_nodata=..., process_as_multiband=...):
    """
    The Variety function calculates the number of unique values of a raster on a pixel-by-pixel basis.

    :param rasters: Required list of Rasters. If a scalar is needed for the operation, the scalar can be a float.
    :param extent_type: Optional string. Specifies the extent to be used for the function.

                        - "FirstOf" - Use the extent of the first input raster to determine the processing extent. This is the default.

                        - "IntersectionOf" - Use the extent of the overlapping pixels to determine the processing extent.

                        - "UnionOf" - Use the extent of all the rasters to determine the processing extent.

                        - "LastOf" - Use the extent of the last input raster to determine the processing extent.
    :param cellsize_type: Optional string. Specifies the cell size to be used for the function.
                          - "FirstOf" - Use the first cell size of the input rasters. This is the default.

                          - "MinOf" - Use the smallest cell size of all the input rasters.

                          - "MaxOf" - Use the largest cell size of all the input rasters.

                          - "MeanOf" - Use the mean cell size of all the input rasters.

                          - "LastOf" - Use the last cell size of the input rasters.
    :param ignore_nodata: Optional Boolean. Specifies whether NoData values are ignored in the interpolation.
                          
                          - True : Only the cells that are have noData values will be used in calculation. This is the default.
                          - False : The cells that have noData values will be used in calculation.

    :param process_as_multiband: Optional boolean. Set to True to process as multiband.

    :return: output raster 
    """
    ...

def Percentile(rasters, percentile_value=..., percentile_interpolation_type=..., extent_type=..., cellsize_type=..., ignore_nodata=..., process_as_multiband=...):
    """
    The Percentile function calculates the percentile of the inputs.

    :param rasters: Required list of Rasters. If a scalar is needed for the operation, the scalar can be a float.
    :param percentile_value: Optional float. The percentile to calculate. The default is 90, indicating the 90th percentile.
                             The values can range from 0 to 100. The 0th percentile is essentially equivalent to the minimum
                             statistic, and the 100th percentile is equivalent to maximum. A value of 50 will produce
                             essentially the same result as the median statistic.
    :param percentile_interpolation_type: Optional string. Specifies the method of interpolation to be used when
                                          the median lies between two input cell values.

                                             - AUTO_DETECT-If the input rasters are of integer pixel type, the NEAREST
                                               method is used. If the input rasters are of floating point pixel type,
                                               the LINEAR method is used. This is the default.

                                             - NEAREST-The nearest available value to the desired percentile is used.
                                               In this case, the output pixel type is the same as that of the input rasters.

                                             - LINEAR-The weighted average of the two surrounding values from the desired
                                               percentile is used. In this case, the output pixel type is floating point.
    :param extent_type: Optional string. Specifies the extent to be used for the function.

                        - "FirstOf" - Use the extent of the first input raster to determine the processing extent. This is the default.

                        - "IntersectionOf" - Use the extent of the overlapping pixels to determine the processing extent.

                        - "UnionOf" - Use the extent of all the rasters to determine the processing extent.

                        - "LastOf" - Use the extent of the last input raster to determine the processing extent.
    :param cellsize_type: Optional string. Specifies the cell size to be used for the function.
                          - "FirstOf" - Use the first cell size of the input rasters. This is the default.

                          - "MinOf" - Use the smallest cell size of all the input rasters.

                          - "MaxOf" - Use the largest cell size of all the input rasters.

                          - "MeanOf" - Use the mean cell size of all the input rasters.

                          - "LastOf" - Use the last cell size of the input rasters.
    :param ignore_nodata: Optional Boolean. Specifies whether NoData values are ignored in the interpolation.
                          
                          - True : Only the cells that are have noData values will be used in calculation. This is the default.
                          - False : The cells that have noData values will be used in calculation.

    :param process_as_multiband: Optional boolean. Set to True to process as multiband.

    :return: output raster 
    """
    ...

def GeometricMedian(rasters, epsilon=..., max_iteration=..., extent_type=..., cellsize_type=...):
    """
    Calculates the geometric median across pixels in a time series of multiband imagery.

    :param rasters: Required list of Rasters. The input multiband rasters.
    :param epsilon: Optional float. Specifies the convergence value between two 
                    consecutive iterations. When epsilon is less than or equal to the 
                    specified value, the iteration will stop, and the result of the 
                    last iteration will be used.
    :param max_iteration: Optional int. Specifies the maximum number of iterations to complete. 
                          The computation will end once this value is reached, regardless of the 
                          epsilon setting.
    :param extent_type: Optional string. Specifies the extent to be used for the function.

                        - "FirstOf" - Use the extent of the first input raster to determine the processing extent. This is the default.

                        - "IntersectionOf" - Use the extent of the overlapping pixels to determine the processing extent.

                        - "UnionOf" - Use the extent of all the rasters to determine the processing extent.

                        - "LastOf" - Use the extent of the last input raster to determine the processing extent.
    :param cellsize_type: Optional string. Specifies the cell size to be used for the function.
                          - "FirstOf" - Use the first cell size of the input rasters. This is the default.

                          - "MinOf" - Use the smallest cell size of all the input rasters.

                          - "MaxOf" - Use the largest cell size of all the input rasters.

                          - "MeanOf" - Use the mean cell size of all the input rasters.

                          - "LastOf" - Use the last cell size of the input rasters.

    :return: output raster 
    """
    ...

def EqualToFrequency(value_raster, rasters, extent_type=..., cellsize_type=..., process_as_multiband=...):
    """
    Evaluates on a cell-by-cell basis the number of times the values in a set of rasters are equal to another raster.

    :param value_raster: Required value raster. For each cell location in the input value raster, the number of occurrences (frequency) 
                         where a raster in the input list has an equal value is counted.
    :param rasters: Required list of Rasters. The list of rasters that will be compared to the value raster.
    :param extent_type: Optional string. Specifies the extent to be used for the function.

                        - "FirstOf" - Use the extent of the first input raster to determine the processing extent. This is the default.

                        - "IntersectionOf" - Use the extent of the overlapping pixels to determine the processing extent.

                        - "UnionOf" - Use the extent of all the rasters to determine the processing extent.

                        - "LastOf" - Use the extent of the last input raster to determine the processing extent.
    :param cellsize_type: Optional string. Specifies the cell size to be used for the function.
                          - "FirstOf" - Use the first cell size of the input rasters. This is the default.

                          - "MinOf" - Use the smallest cell size of all the input rasters.

                          - "MaxOf" - Use the largest cell size of all the input rasters.

                          - "MeanOf" - Use the mean cell size of all the input rasters.

                          - "LastOf" - Use the last cell size of the input rasters.
    :param process_as_multiband: Optional boolean. Set to True to process as multiband.

    :return: output raster 
    """
    ...

def GreaterThanFrequency(value_raster, rasters, extent_type=..., cellsize_type=..., process_as_multiband=...):
    """
    Evaluates on a cell-by-cell basis the number of times a set of rasters is greater than another raster.

    :param value_raster: Required value raster. For each cell location in the input value raster, the number of occurrences (frequency) 
                         where a raster in the input list has a greater value is counted.
    :param rasters: Required list of Rasters. The list of rasters that will be compared to the value raster.
    :param extent_type: Optional string. Specifies the extent to be used for the function.

                        - "FirstOf" - Use the extent of the first input raster to determine the processing extent. This is the default.

                        - "IntersectionOf" - Use the extent of the overlapping pixels to determine the processing extent.

                        - "UnionOf" - Use the extent of all the rasters to determine the processing extent.

                        - "LastOf" - Use the extent of the last input raster to determine the processing extent.
    :param cellsize_type: Optional string. Specifies the cell size to be used for the function.
                          - "FirstOf" - Use the first cell size of the input rasters. This is the default.

                          - "MinOf" - Use the smallest cell size of all the input rasters.

                          - "MaxOf" - Use the largest cell size of all the input rasters.

                          - "MeanOf" - Use the mean cell size of all the input rasters.

                          - "LastOf" - Use the last cell size of the input rasters.
    :param process_as_multiband: Optional boolean. Set to True to process as multiband.

    :return: output raster 
    """
    ...

def LessThanFrequency(value_raster, rasters, extent_type=..., cellsize_type=..., process_as_multiband=...):
    """
    Evaluates on a cell-by-cell basis the number of times a set of rasters is less than another raster.

    :param value_raster: Required value raster. For each cell location in the input value raster, the number of occurrences (frequency) 
                         where a raster in the input list has a lesser value is counted.
    :param rasters: Required list of Rasters. The list of rasters that will be compared to the value raster.
    :param extent_type: Optional string. Specifies the extent to be used for the function.

                        - "FirstOf" - Use the extent of the first input raster to determine the processing extent. This is the default.

                        - "IntersectionOf" - Use the extent of the overlapping pixels to determine the processing extent.

                        - "UnionOf" - Use the extent of all the rasters to determine the processing extent.

                        - "LastOf" - Use the extent of the last input raster to determine the processing extent.
    :param cellsize_type: Optional string. Specifies the cell size to be used for the function.
                          - "FirstOf" - Use the first cell size of the input rasters. This is the default.

                          - "MinOf" - Use the smallest cell size of all the input rasters.

                          - "MaxOf" - Use the largest cell size of all the input rasters.

                          - "MeanOf" - Use the mean cell size of all the input rasters.

                          - "LastOf" - Use the last cell size of the input rasters.
    :param process_as_multiband: Optional boolean. Set to True to process as multiband.

    :return: output raster 
    """
    ...

def HighestPosition(rasters, extent_type=..., cellsize_type=...):
    """
    Determines on a cell-by-cell basis the position of the raster with the maximum value in a set of rasters.

    :param rasters: Required list of Rasters. The list of input rasters for which the position of the input with the highest value will be determined.
    :param extent_type: Optional string. Specifies the extent to be used for the function.

                        - "FirstOf" - Use the extent of the first input raster to determine the processing extent. This is the default.

                        - "IntersectionOf" - Use the extent of the overlapping pixels to determine the processing extent.

                        - "UnionOf" - Use the extent of all the rasters to determine the processing extent.

                        - "LastOf" - Use the extent of the last input raster to determine the processing extent.
    :param cellsize_type: Optional string. Specifies the cell size to be used for the function.
                          - "FirstOf" - Use the first cell size of the input rasters. This is the default.

                          - "MinOf" - Use the smallest cell size of all the input rasters.

                          - "MaxOf" - Use the largest cell size of all the input rasters.

                          - "MeanOf" - Use the mean cell size of all the input rasters.

                          - "LastOf" - Use the last cell size of the input rasters.

    :return: output raster 
    """
    ...

def LowestPosition(rasters, extent_type=..., cellsize_type=...):
    """
    Determines on a cell-by-cell basis the position of the raster with the minimum value in a set of rasters.

    :param rasters: Required list of Rasters. The list of input rasters for which the position of the input with the lowest value will be determined.
    :param extent_type: Optional string. Specifies the extent to be used for the function.

                        - "FirstOf" - Use the extent of the first input raster to determine the processing extent. This is the default.

                        - "IntersectionOf" - Use the extent of the overlapping pixels to determine the processing extent.

                        - "UnionOf" - Use the extent of all the rasters to determine the processing extent.

                        - "LastOf" - Use the extent of the last input raster to determine the processing extent.
    :param cellsize_type: Optional string. Specifies the cell size to be used for the function.
                          - "FirstOf" - Use the first cell size of the input rasters. This is the default.

                          - "MinOf" - Use the smallest cell size of all the input rasters.

                          - "MaxOf" - Use the largest cell size of all the input rasters.

                          - "MeanOf" - Use the mean cell size of all the input rasters.

                          - "LastOf" - Use the last cell size of the input rasters.

    :return: output raster 
    """
    ...

def Popularity(popularity_raster, rasters, extent_type=..., cellsize_type=..., process_as_multiband=...):
    """
    Determines the value in an argument list that is at a certain level of popularity on a cell-by-cell basis. 
    The particular level of popularity (the number of occurrences of each value) is specified by the first argument.

    :param popularity_raster: Required popularity raster. The input raster that defines the popularity position to be returned.
    :param rasters: Required list of Rasters. The list of input rasters used to evaluate the popularity of the values for each cell location.
    :param extent_type: Optional string. Specifies the extent to be used for the function.

                        - "FirstOf" - Use the extent of the first input raster to determine the processing extent. This is the default.

                        - "IntersectionOf" - Use the extent of the overlapping pixels to determine the processing extent.

                        - "UnionOf" - Use the extent of all the rasters to determine the processing extent.

                        - "LastOf" - Use the extent of the last input raster to determine the processing extent.
    :param cellsize_type: Optional string. Specifies the cell size to be used for the function.
                          - "FirstOf" - Use the first cell size of the input rasters. This is the default.

                          - "MinOf" - Use the smallest cell size of all the input rasters.

                          - "MaxOf" - Use the largest cell size of all the input rasters.

                          - "MeanOf" - Use the mean cell size of all the input rasters.

                          - "LastOf" - Use the last cell size of the input rasters.
    :param process_as_multiband: Optional boolean. Set to True to process as multiband.

    :return: output raster 
    """
    ...

def Rank(rank_raster, rasters, extent_type=..., cellsize_type=..., process_as_multiband=...):
    """
    Ranks on a cell-by-cell basis the values from a set of input rasters and determines which values are returned based on the value of the rank input raster..

    :param rank_raster: Required rank raster. The input raster that defines the rank position to be returned.
    :param rasters: Required list of Rasters. The list of input rasters from which the cell value of the raster at the specified rank position will be obtained.
    :param extent_type: Optional string. Specifies the extent to be used for the function.

                        - "FirstOf" - Use the extent of the first input raster to determine the processing extent. This is the default.

                        - "IntersectionOf" - Use the extent of the overlapping pixels to determine the processing extent.

                        - "UnionOf" - Use the extent of all the rasters to determine the processing extent.

                        - "LastOf" - Use the extent of the last input raster to determine the processing extent.
    :param cellsize_type: Optional string. Specifies the cell size to be used for the function.
                          - "FirstOf" - Use the first cell size of the input rasters. This is the default.

                          - "MinOf" - Use the smallest cell size of all the input rasters.

                          - "MaxOf" - Use the largest cell size of all the input rasters.

                          - "MeanOf" - Use the mean cell size of all the input rasters.

                          - "LastOf" - Use the last cell size of the input rasters.
    :param process_as_multiband: Optional boolean. Set to True to process as multiband.

    :return: output raster 
    """
    ...

